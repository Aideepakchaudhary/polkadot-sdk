#![feature(prelude_import)]
//! # Staking Pallet
//!
//! The Staking pallet is used to manage funds at stake by network maintainers.
//!
//! - [`Config`]
//! - [`Call`]
//! - [`Pallet`]
//!
//! ## Overview
//!
//! The Staking pallet is the means by which a set of network maintainers (known as _authorities_ in
//! some contexts and _validators_ in others) are chosen based upon those who voluntarily place
//! funds under deposit. Under deposit, those funds are rewarded under normal operation but are held
//! at pain of _slash_ (expropriation) should the staked maintainer be found not to be discharging
//! its duties properly.
//!
//! ### Terminology
//! <!-- Original author of paragraph: @gavofyork -->
//!
//! - Staking: The process of locking up funds for some time, placing them at risk of slashing
//!   (loss) in order to become a rewarded maintainer of the network.
//! - Validating: The process of running a node to actively maintain the network, either by
//!   producing blocks or guaranteeing finality of the chain.
//! - Nominating: The process of placing staked funds behind one or more validators in order to
//!   share in any reward, and punishment, they take.
//! - Stash account: The account holding an owner's funds used for staking.
//! - Controller account (being deprecated): The account that controls an owner's funds for staking.
//! - Era: A (whole) number of sessions, which is the period that the validator set (and each
//!   validator's active nominator set) is recalculated and where rewards are paid out.
//! - Slash: The punishment of a staker by reducing its funds.
//!
//! ### Goals
//! <!-- Original author of paragraph: @gavofyork -->
//!
//! The staking system in Substrate NPoS is designed to make the following possible:
//!
//! - Stake funds that are controlled by a cold wallet.
//! - Withdraw some, or deposit more, funds without interrupting the role of an entity.
//! - Switch between roles (nominator, validator, idle) with minimal overhead.
//!
//! ### Scenarios
//!
//! #### Staking
//!
//! Almost any interaction with the Staking pallet requires a process of _**bonding**_ (also known
//! as being a _staker_). To become *bonded*, a fund-holding register known as the _stash account_,
//! which holds some or all of the funds that become frozen in place as part of the staking process.
//! The controller account, which this pallet now assigns the stash account to, issues instructions
//! on how funds shall be used.
//!
//! An account can become a bonded stash account using the [`bond`](Call::bond) call.
//!
//! In the event stash accounts registered a unique controller account before the controller account
//! deprecation, they can update their associated controller back to the stash account using the
//! [`set_controller`](Call::set_controller) call.
//!
//! There are three possible roles that any staked account pair can be in: `Validator`, `Nominator`
//! and `Idle` (defined in [`StakerStatus`]). There are three corresponding instructions to change
//! between roles, namely: [`validate`](Call::validate), [`nominate`](Call::nominate), and
//! [`chill`](Call::chill).
//!
//! #### Validating
//!
//! A **validator** takes the role of either validating blocks or ensuring their finality,
//! maintaining the veracity of the network. A validator should avoid both any sort of malicious
//! misbehavior and going offline. Bonded accounts that state interest in being a validator do NOT
//! get immediately chosen as a validator. Instead, they are declared as a _candidate_ and they
//! _might_ get elected at the _next era_ as a validator. The result of the election is determined
//! by nominators and their votes.
//!
//! An account can become a validator candidate via the [`validate`](Call::validate) call.
//!
//! #### Nomination
//!
//! A **nominator** does not take any _direct_ role in maintaining the network, instead, it votes on
//! a set of validators to be elected. Once interest in nomination is stated by an account, it takes
//! effect at the next election round. The funds in the nominator's stash account indicate the
//! _weight_ of its vote. Both the rewards and any punishment that a validator earns are shared
//! between the validator and its nominators. This rule incentivizes the nominators to NOT vote for
//! the misbehaving/offline validators as much as possible, simply because the nominators will also
//! lose funds if they vote poorly.
//!
//! An account can become a nominator via the [`nominate`](Call::nominate) call.
//!
//! #### Voting
//!
//! Staking is closely related to elections; actual validators are chosen from among all potential
//! validators via election by the potential validators and nominators. To reduce use of the phrase
//! "potential validators and nominators", we often use the term **voters**, who are simply the
//! union of potential validators and nominators.
//!
//! #### Rewards and Slash
//!
//! The **reward and slashing** procedure is the core of the Staking pallet, attempting to _embrace
//! valid behavior_ while _punishing any misbehavior or lack of availability_.
//!
//! Rewards must be claimed for each era before it gets too old by
//! [`HistoryDepth`](`Config::HistoryDepth`) using the `payout_stakers` call. Any account can call
//! `payout_stakers`, which pays the reward to the validator as well as its nominators. Only
//! [`Config::MaxExposurePageSize`] nominator rewards can be claimed in a single call. When the
//! number of nominators exceeds [`Config::MaxExposurePageSize`], then the exposed nominators are
//! stored in multiple pages, with each page containing up to [`Config::MaxExposurePageSize`]
//! nominators. To pay out all nominators, `payout_stakers` must be called once for each available
//! page. Paging exists to limit the i/o cost to mutate storage for each nominator's account.
//!
//! Slashing can occur at any point in time, once misbehavior is reported. Once slashing is
//! determined, a value is deducted from the balance of the validator and all the nominators who
//! voted for this validator (values are deducted from the _stash_ account of the slashed entity).
//!
//! Slashing logic is further described in the documentation of the `slashing` pallet.
//!
//! Similar to slashing, rewards are also shared among a validator and its associated nominators.
//! Yet, the reward funds are not always transferred to the stash account and can be configured. See
//! [Reward Calculation](#reward-calculation) for more details.
//!
//! #### Chilling
//!
//! Finally, any of the roles above can choose to step back temporarily and just chill for a while.
//! This means that if they are a nominator, they will not be considered as voters anymore and if
//! they are validators, they will no longer be a candidate for the next election.
//!
//! An account can step back via the [`chill`](Call::chill) call.
//!
//! ### Session managing
//!
//! The pallet implement the trait `SessionManager`. Which is the only API to query new validator
//! set and allowing these validator set to be rewarded once their era is ended.
//!
//! ## Interface
//!
//! ### Dispatchable Functions
//!
//! The dispatchable functions of the Staking pallet enable the steps needed for entities to accept
//! and change their role, alongside some helper functions to get/set the metadata of the pallet.
//!
//! ### Public Functions
//!
//! The Staking pallet contains many public storage items and (im)mutable functions.
//!
//! ## Usage
//!
//! ### Example: Rewarding a validator by id.
//!
//! ```
//! use pallet_staking::{self as staking};
//!
//! #[frame_support::pallet(dev_mode)]
//! pub mod pallet {
//!   use super::*;
//!   use frame_support::pallet_prelude::*;
//!   use frame_system::pallet_prelude::*;
//!
//!   #[pallet::pallet]
//!   pub struct Pallet<T>(_);
//!
//!   #[pallet::config]
//!   pub trait Config: frame_system::Config + staking::Config {}
//!
//!   #[pallet::call]
//!   impl<T: Config> Pallet<T> {
//!         /// Reward a validator.
//!         #[pallet::weight(0)]
//!         pub fn reward_myself(origin: OriginFor<T>) -> DispatchResult {
//!             let reported = ensure_signed(origin)?;
//!             <staking::Pallet<T>>::reward_by_ids(vec![(reported, 10)]);
//!             Ok(())
//!         }
//!     }
//! }
//! # fn main() { }
//! ```
//!
//! ## Implementation Details
//!
//! ### Era payout
//!
//! The era payout is computed using yearly inflation curve defined at [`Config::EraPayout`] as
//! such:
//!
//! ```nocompile
//! staker_payout = yearly_inflation(npos_token_staked / total_tokens) * total_tokens / era_per_year
//! ```
//! This payout is used to reward stakers as defined in next section
//!
//! ```nocompile
//! remaining_payout = max_yearly_inflation * total_tokens / era_per_year - staker_payout
//! ```
//!
//! Note, however, that it is possible to set a cap on the total `staker_payout` for the era through
//! the `MaxStakersRewards` storage type. The `era_payout` implementor must ensure that the
//! `max_payout = remaining_payout + (staker_payout * max_stakers_rewards)`. The excess payout that
//! is not allocated for stakers is the era remaining reward.
//!
//! The remaining reward is send to the configurable end-point [`Config::RewardRemainder`].
//!
//! ### Reward Calculation
//!
//! Validators and nominators are rewarded at the end of each era. The total reward of an era is
//! calculated using the era duration and the staking rate (the total amount of tokens staked by
//! nominators and validators, divided by the total token supply). It aims to incentivize toward a
//! defined staking rate. The full specification can be found
//! [here](https://research.web3.foundation/en/latest/polkadot/Token%20Economics.html#inflation-model).
//!
//! Total reward is split among validators and their nominators depending on the number of points
//! they received during the era. Points are added to a validator using
//! [`reward_by_ids`](Pallet::reward_by_ids).
//!
//! [`Pallet`] implements [`pallet_authorship::EventHandler`] to add reward points to block producer
//! and block producer of referenced uncles.
//!
//! The validator and its nominator split their reward as following:
//!
//! The validator can declare an amount, named [`commission`](ValidatorPrefs::commission), that does
//! not get shared with the nominators at each reward payout through its [`ValidatorPrefs`]. This
//! value gets deducted from the total reward that is paid to the validator and its nominators. The
//! remaining portion is split pro rata among the validator and the nominators that nominated the
//! validator, proportional to the value staked behind the validator (_i.e._ dividing the
//! [`own`](Exposure::own) or [`others`](Exposure::others) by [`total`](Exposure::total) in
//! [`Exposure`]). Note that payouts are made in pages with each page capped at
//! [`Config::MaxExposurePageSize`] nominators. The distribution of nominators across pages may be
//! unsorted. The total commission is paid out proportionally across pages based on the total stake
//! of the page.
//!
//! All entities who receive a reward have the option to choose their reward destination through the
//! [`Payee`] storage item (see [`set_payee`](Call::set_payee)), to be one of the following:
//!
//! - Stash account, not increasing the staked value.
//! - Stash account, also increasing the staked value.
//! - Any other account, sent as free balance.
//!
//! ### Additional Fund Management Operations
//!
//! Any funds already placed into stash can be the target of the following operations:
//!
//! The controller account can free a portion (or all) of the funds using the
//! [`unbond`](Call::unbond) call. Note that the funds are not immediately accessible. Instead, a
//! duration denoted by [`Config::BondingDuration`] (in number of eras) must pass until the funds
//! can actually be removed. Once the `BondingDuration` is over, the
//! [`withdraw_unbonded`](Call::withdraw_unbonded) call can be used to actually withdraw the funds.
//!
//! Note that there is a limitation to the number of fund-chunks that can be scheduled to be
//! unlocked in the future via [`unbond`](Call::unbond). In case this maximum
//! (`MAX_UNLOCKING_CHUNKS`) is reached, the bonded account _must_ first wait until a successful
//! call to `withdraw_unbonded` to remove some of the chunks.
//!
//! ### Election Algorithm
//!
//! The current election algorithm is implemented based on Phragmén. The reference implementation
//! can be found [here](https://github.com/w3f/consensus/tree/master/NPoS).
//!
//! The election algorithm, aside from electing the validators with the most stake value and votes,
//! tries to divide the nominator votes among candidates in an equal manner. To further assure this,
//! an optional post-processing can be applied that iteratively normalizes the nominator staked
//! values until the total difference among votes of a particular nominator are less than a
//! threshold.
//!
//! ## GenesisConfig
//!
//! The Staking pallet depends on the [`GenesisConfig`]. The `GenesisConfig` is optional and allow
//! to set some initial stakers.
//!
//! ## Related Modules
//!
//! - [Balances](../pallet_balances/index.html): Used to manage values at stake.
//! - [Session](../pallet_session/index.html): Used to manage sessions. Also, a list of new
//!   validators is stored in the Session pallet's `Validators` at the end of each era.
#![recursion_limit = "256"]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub mod asset {
    //! Contains all the interactions with [`Config::Currency`] to manipulate the underlying staking
    //! asset.
    use frame_support::traits::{Currency, InspectLockableCurrency, LockableCurrency};
    use crate::{BalanceOf, Config, NegativeImbalanceOf, PositiveImbalanceOf};
    /// Existential deposit for the chain.
    pub fn existential_deposit<T: Config>() -> BalanceOf<T> {
        T::Currency::minimum_balance()
    }
    /// Total issuance of the chain.
    pub fn total_issuance<T: Config>() -> BalanceOf<T> {
        T::Currency::total_issuance()
    }
    /// Total balance of `who`. Includes both, free and reserved.
    pub fn total_balance<T: Config>(who: &T::AccountId) -> BalanceOf<T> {
        T::Currency::total_balance(who)
    }
    /// Stakeable balance of `who`.
    ///
    /// This includes balance free to stake along with any balance that is already staked.
    pub fn stakeable_balance<T: Config>(who: &T::AccountId) -> BalanceOf<T> {
        T::Currency::free_balance(who)
    }
    /// Balance of `who` that is currently at stake.
    ///
    /// The staked amount is locked and cannot be transferred out of `who`s account.
    pub fn staked<T: Config>(who: &T::AccountId) -> BalanceOf<T> {
        T::Currency::balance_locked(crate::STAKING_ID, who)
    }
    /// Update `amount` at stake for `who`.
    ///
    /// Overwrites the existing stake amount. If passed amount is lower than the existing stake, the
    /// difference is unlocked.
    pub fn update_stake<T: Config>(who: &T::AccountId, amount: BalanceOf<T>) {
        T::Currency::set_lock(
            crate::STAKING_ID,
            who,
            amount,
            frame_support::traits::WithdrawReasons::all(),
        );
    }
    /// Kill the stake of `who`.
    ///
    /// All locked amount is unlocked.
    pub fn kill_stake<T: Config>(who: &T::AccountId) {
        T::Currency::remove_lock(crate::STAKING_ID, who);
    }
    /// Slash the value from `who`.
    ///
    /// A negative imbalance is returned which can be resolved to deposit the slashed value.
    pub fn slash<T: Config>(
        who: &T::AccountId,
        value: BalanceOf<T>,
    ) -> (NegativeImbalanceOf<T>, BalanceOf<T>) {
        T::Currency::slash(who, value)
    }
    /// Mint `value` into an existing account `who`.
    ///
    /// This does not increase the total issuance.
    pub fn mint_existing<T: Config>(
        who: &T::AccountId,
        value: BalanceOf<T>,
    ) -> Option<PositiveImbalanceOf<T>> {
        T::Currency::deposit_into_existing(who, value).ok()
    }
    /// Mint reward and create account for `who` if it does not exist.
    ///
    /// This does not increase the total issuance.
    pub fn mint_creating<T: Config>(
        who: &T::AccountId,
        value: BalanceOf<T>,
    ) -> PositiveImbalanceOf<T> {
        T::Currency::deposit_creating(who, value)
    }
    /// Deposit newly issued or slashed `value` into `who`.
    pub fn deposit_slashed<T: Config>(
        who: &T::AccountId,
        value: NegativeImbalanceOf<T>,
    ) {
        T::Currency::resolve_creating(who, value)
    }
    /// Issue `value` increasing total issuance.
    ///
    /// Creates a negative imbalance.
    pub fn issue<T: Config>(value: BalanceOf<T>) -> NegativeImbalanceOf<T> {
        T::Currency::issue(value)
    }
}
pub mod election_size_tracker {
    //! ## A static size tracker for the election snapshot data.
    //!
    //! ### Overview
    //!
    //! The goal of the size tracker is to provide a static, no-allocation byte tracker to be
    //! used by the election data provider when preparing the results of
    //! [`ElectionDataProvider::electing_voters`]. The [`StaticTracker`] implementation uses
    //! [`codec::Encode::size_hint`] to estimate the SCALE encoded size of the snapshot voters struct
    //! as it is being constructed without requiring extra stack allocations.
    //!
    //! The [`StaticTracker::try_register_voter`] is called to update the static tracker internal
    //! state, if It will return an error if the resulting SCALE encoded size (in bytes) is larger than
    //! the provided `DataProviderBounds`.
    //!
    //! ### Example
    //!
    //! ```ignore
    //! use pallet_staking::election_size_tracker::*;
    //!
    //! // instantiates a new tracker.
    //! let mut size_tracker = StaticTracker::<Staking>::default();
    //!
    //! let voter_bounds = ElectionBoundsBuilder::default().voter_size(1_00.into()).build().voters;
    //!
    //! let mut sorted_voters = T::VoterList.iter();
    //! let mut selected_voters = vec![];
    //!
    //! // fit as many voters in the vec as the bounds permit.
    //! for v in sorted_voters {
    //!     let voter = (v, weight_of(&v), targets_of(&v));
    //!     if size_tracker.try_register_voter(&voter, &voter_bounds).is_err() {
    //!         // voter bounds size exhausted
    //!         break;
    //!     }
    //!     selected_voters.push(voter);
    //! }
    //!
    //! // The SCALE encoded size in bytes of `selected_voters` is guaranteed to be below
    //! // `voter_bounds`.
    //! debug_assert!(
    //!     selected_voters.encoded_size() <=
    //!     SizeTracker::<Staking>::final_byte_size_of(size_tracker.num_voters, size_tracker.size)
    //! );
    //! ```
    //!
    //! ### Implementation Details
    //!
    //! The current implementation of the static tracker is tightly coupled with the staking pallet
    //! implementation, namely the representation of a voter ([`VoterOf`]). The SCALE encoded byte size
    //! is calculated using [`Encode::size_hint`] of each type in the voter tuple. Each voter's byte
    //! size is the sum of:
    //! - 1 * [`Encode::size_hint`] of the `AccountId` type;
    //! - 1 * [`Encode::size_hint`] of the `VoteWeight` type;
    //! - `num_votes` * [`Encode::size_hint`] of the `AccountId` type.
    use codec::Encode;
    use frame_election_provider_support::{
        bounds::{DataProviderBounds, SizeBound},
        ElectionDataProvider, VoterOf,
    };
    /// Keeps track of the SCALE encoded byte length of the snapshot's voters or targets.
    ///
    /// The tracker calculates the bytes used based on static rules, without requiring any actual
    /// encoding or extra allocations.
    pub struct StaticTracker<DataProvider> {
        pub size: usize,
        pub counter: usize,
        _marker: core::marker::PhantomData<DataProvider>,
    }
    #[automatically_derived]
    impl<DataProvider: ::core::clone::Clone> ::core::clone::Clone
    for StaticTracker<DataProvider> {
        #[inline]
        fn clone(&self) -> StaticTracker<DataProvider> {
            StaticTracker {
                size: ::core::clone::Clone::clone(&self.size),
                counter: ::core::clone::Clone::clone(&self.counter),
                _marker: ::core::clone::Clone::clone(&self._marker),
            }
        }
    }
    #[automatically_derived]
    impl<DataProvider: ::core::marker::Copy> ::core::marker::Copy
    for StaticTracker<DataProvider> {}
    #[automatically_derived]
    impl<DataProvider: ::core::fmt::Debug> ::core::fmt::Debug
    for StaticTracker<DataProvider> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "StaticTracker",
                "size",
                &self.size,
                "counter",
                &self.counter,
                "_marker",
                &&self._marker,
            )
        }
    }
    impl<DataProvider> Default for StaticTracker<DataProvider> {
        fn default() -> Self {
            Self {
                size: 0,
                counter: 0,
                _marker: Default::default(),
            }
        }
    }
    impl<DataProvider> StaticTracker<DataProvider>
    where
        DataProvider: ElectionDataProvider,
    {
        /// Tries to register a new voter.
        ///
        /// If the new voter exhausts the provided bounds, return an error. Otherwise, the internal
        /// state of the tracker is updated with the new registered voter.
        pub fn try_register_voter(
            &mut self,
            voter: &VoterOf<DataProvider>,
            bounds: &DataProviderBounds,
        ) -> Result<(), ()> {
            let tracker_size_after = {
                let voter_hint = Self::voter_size_hint(voter);
                Self::final_byte_size_of(
                    self.counter + 1,
                    self.size.saturating_add(voter_hint),
                )
            };
            match bounds.size_exhausted(SizeBound(tracker_size_after as u32)) {
                true => Err(()),
                false => {
                    self.size = tracker_size_after;
                    self.counter += 1;
                    Ok(())
                }
            }
        }
        /// Calculates the size of the voter to register based on [`Encode::size_hint`].
        fn voter_size_hint(voter: &VoterOf<DataProvider>) -> usize {
            let (voter_account, vote_weight, targets) = voter;
            voter_account
                .size_hint()
                .saturating_add(vote_weight.size_hint())
                .saturating_add(voter_account.size_hint().saturating_mul(targets.len()))
        }
        /// Tries to register a new target.
        ///
        /// If the new target exhausts the provided bounds, return an error. Otherwise, the internal
        /// state of the tracker is updated with the new registered target.
        pub fn try_register_target(
            &mut self,
            target: DataProvider::AccountId,
            bounds: &DataProviderBounds,
        ) -> Result<(), ()> {
            let tracker_size_after = Self::final_byte_size_of(
                self.counter + 1,
                self.size.saturating_add(target.size_hint()),
            );
            match bounds.size_exhausted(SizeBound(tracker_size_after as u32)) {
                true => Err(()),
                false => {
                    self.size = tracker_size_after;
                    self.counter += 1;
                    Ok(())
                }
            }
        }
        /// Size of the SCALE encoded prefix with a given length.
        #[inline]
        fn length_prefix(len: usize) -> usize {
            use codec::{Compact, CompactLen};
            Compact::<u32>::compact_len(&(len as u32))
        }
        /// Calculates the final size in bytes of the SCALE encoded snapshot voter struct.
        fn final_byte_size_of(num_voters: usize, size: usize) -> usize {
            Self::length_prefix(num_voters).saturating_add(size)
        }
    }
}
pub mod inflation {
    //! This module expose one function `P_NPoS` (Payout NPoS) or `compute_total_payout` which returns
    //! the total payout for the era given the era duration and the staking rate in NPoS.
    //! The staking rate in NPoS is the total amount of tokens staked by nominators and validators,
    //! divided by the total token supply.
    use sp_runtime::{curve::PiecewiseLinear, traits::AtLeast32BitUnsigned, Perbill};
    /// The total payout to all validators (and their nominators) per era and maximum payout.
    ///
    /// Defined as such:
    /// `staker-payout = yearly_inflation(npos_token_staked / total_tokens) * total_tokens /
    /// era_per_year` `maximum-payout = max_yearly_inflation * total_tokens / era_per_year`
    ///
    /// `era_duration` is expressed in millisecond.
    pub fn compute_total_payout<N>(
        yearly_inflation: &PiecewiseLinear<'static>,
        npos_token_staked: N,
        total_tokens: N,
        era_duration: u64,
    ) -> (N, N)
    where
        N: AtLeast32BitUnsigned + Clone,
    {
        const MILLISECONDS_PER_YEAR: u64 = 1000 * 3600 * 24 * 36525 / 100;
        let portion = Perbill::from_rational(era_duration as u64, MILLISECONDS_PER_YEAR);
        let payout = portion
            * yearly_inflation
                .calculate_for_fraction_times_denominator(
                    npos_token_staked,
                    total_tokens.clone(),
                );
        let maximum = portion * (yearly_inflation.maximum * total_tokens);
        (payout, maximum)
    }
}
pub mod ledger {
    //! A Ledger implementation for stakers.
    //!
    //! A [`StakingLedger`] encapsulates all the state and logic related to the stake of bonded
    //! stakers, namely, it handles the following storage items:
    //! * [`Bonded`]: mutates and reads the state of the controller <> stash bond map (to be deprecated
    //! soon);
    //! * [`Ledger`]: mutates and reads the state of all the stakers. The [`Ledger`] storage item stores
    //!   instances of [`StakingLedger`] keyed by the staker's controller account and should be mutated
    //!   and read through the [`StakingLedger`] API;
    //! * [`Payee`]: mutates and reads the reward destination preferences for a bonded stash.
    //! * Staking locks: mutates the locks for staking.
    //!
    //! NOTE: All the storage operations related to the staking ledger (both reads and writes) *MUST* be
    //! performed through the methods exposed by the [`StakingLedger`] implementation in order to ensure
    //! state consistency.
    use frame_support::{defensive, ensure, traits::Defensive};
    use sp_staking::{StakingAccount, StakingInterface};
    use crate::{
        asset, BalanceOf, Bonded, Config, Error, Ledger, Pallet, Payee,
        RewardDestination, StakingLedger, VirtualStakers,
    };
    impl<T: Config> StakingLedger<T> {
        /// Returns a new instance of a staking ledger.
        ///
        /// The [`Ledger`] storage is not mutated. In order to store, `StakingLedger::update` must be
        /// called on the returned staking ledger.
        ///
        /// Note: as the controller accounts are being deprecated, the stash account is the same as the
        /// controller account.
        pub fn new(stash: T::AccountId, stake: BalanceOf<T>) -> Self {
            Self {
                stash: stash.clone(),
                active: stake,
                total: stake,
                unlocking: Default::default(),
                legacy_claimed_rewards: Default::default(),
                controller: Some(stash),
            }
        }
        /// Returns the paired account, if any.
        ///
        /// A "pair" refers to the tuple (stash, controller). If the input is a
        /// [`StakingAccount::Stash`] variant, its pair account will be of type
        /// [`StakingAccount::Controller`] and vice-versa.
        ///
        /// This method is meant to abstract from the runtime development the difference between stash
        /// and controller. This will be deprecated once the controller is fully deprecated as well.
        pub(crate) fn paired_account(
            account: StakingAccount<T::AccountId>,
        ) -> Option<T::AccountId> {
            match account {
                StakingAccount::Stash(stash) => <Bonded<T>>::get(stash),
                StakingAccount::Controller(controller) => {
                    <Ledger<T>>::get(&controller).map(|ledger| ledger.stash)
                }
            }
        }
        /// Returns whether a given account is bonded.
        pub(crate) fn is_bonded(account: StakingAccount<T::AccountId>) -> bool {
            match account {
                StakingAccount::Stash(stash) => <Bonded<T>>::contains_key(stash),
                StakingAccount::Controller(controller) => {
                    <Ledger<T>>::contains_key(controller)
                }
            }
        }
        /// Returns a staking ledger, if it is bonded and it exists in storage.
        ///
        /// This getter can be called with either a controller or stash account, provided that the
        /// account is properly wrapped in the respective [`StakingAccount`] variant. This is meant to
        /// abstract the concept of controller/stash accounts from the caller.
        ///
        /// Returns [`Error::BadState`] when a bond is in "bad state". A bond is in a bad state when a
        /// stash has a controller which is bonding a ledger associated with another stash.
        pub(crate) fn get(
            account: StakingAccount<T::AccountId>,
        ) -> Result<StakingLedger<T>, Error<T>> {
            let (stash, controller) = match account.clone() {
                StakingAccount::Stash(stash) => {
                    (
                        stash.clone(),
                        <Bonded<T>>::get(&stash).ok_or(Error::<T>::NotStash)?,
                    )
                }
                StakingAccount::Controller(controller) => {
                    (
                        Ledger::<T>::get(&controller)
                            .map(|l| l.stash)
                            .ok_or(Error::<T>::NotController)?,
                        controller,
                    )
                }
            };
            let ledger = <Ledger<T>>::get(&controller)
                .map(|mut ledger| {
                    ledger.controller = Some(controller.clone());
                    ledger
                })
                .ok_or(Error::<T>::NotController)?;
            {
                if !(Bonded::<T>::get(&stash) == Some(controller)
                    && ledger.stash == stash)
                {
                    {
                        return Err(Error::<T>::BadState.into());
                    };
                }
            };
            Ok(ledger)
        }
        /// Returns the reward destination of a staking ledger, stored in [`Payee`].
        ///
        /// Note: if the stash is not bonded and/or does not have an entry in [`Payee`], it returns the
        /// default reward destination.
        pub(crate) fn reward_destination(
            account: StakingAccount<T::AccountId>,
        ) -> Option<RewardDestination<T::AccountId>> {
            let stash = match account {
                StakingAccount::Stash(stash) => Some(stash),
                StakingAccount::Controller(controller) => {
                    Self::paired_account(StakingAccount::Controller(controller))
                }
            };
            if let Some(stash) = stash {
                <Payee<T>>::get(stash)
            } else {
                {
                    let lvl = ::log::Level::Error;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "{0}: {1:?}: {2:?}",
                                ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                                "fetched reward destination from unbonded stash {}",
                                stash,
                            ),
                            lvl,
                            &(
                                "runtime::defensive",
                                "pallet_staking::ledger",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                };
                if true {
                    if !false {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "{0}: {1:?}: {2:?}",
                                    ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                    "fetched reward destination from unbonded stash {}",
                                    stash,
                                ),
                            );
                        }
                    }
                }
                None
            }
        }
        /// Returns the controller account of a staking ledger.
        ///
        /// Note: it will fallback into querying the [`Bonded`] storage with the ledger stash if the
        /// controller is not set in `self`, which most likely means that self was fetched directly from
        /// [`Ledger`] instead of through the methods exposed in [`StakingLedger`]. If the ledger does
        /// not exist in storage, it returns `None`.
        pub(crate) fn controller(&self) -> Option<T::AccountId> {
            self.controller
                .clone()
                .or_else(|| {
                    {
                        let lvl = ::log::Level::Error;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "{0}: {1:?}",
                                    ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                                    "fetched a controller on a ledger instance without it.",
                                ),
                                lvl,
                                &(
                                    "runtime::defensive",
                                    "pallet_staking::ledger",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if true {
                        if !false {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "{0}: {1:?}",
                                        ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                        "fetched a controller on a ledger instance without it.",
                                    ),
                                );
                            }
                        }
                    }
                    Self::paired_account(StakingAccount::Stash(self.stash.clone()))
                })
        }
        /// Inserts/updates a staking ledger account.
        ///
        /// Bonds the ledger if it is not bonded yet, signalling that this is a new ledger. The staking
        /// locks of the stash account are updated accordingly.
        ///
        /// Note: To ensure lock consistency, all the [`Ledger`] storage updates should be made through
        /// this helper function.
        pub(crate) fn update(self) -> Result<(), Error<T>> {
            if !<Bonded<T>>::contains_key(&self.stash) {
                return Err(Error::<T>::NotStash);
            }
            if !Pallet::<T>::is_virtual_staker(&self.stash) {
                asset::update_stake::<T>(&self.stash, self.total);
            }
            Ledger::<
                T,
            >::insert(
                &self
                    .controller()
                    .ok_or_else(|| {
                        {
                            let lvl = ::log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "{0}: {1:?}",
                                        ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                                        "update called on a ledger that is not bonded.",
                                    ),
                                    lvl,
                                    &(
                                        "runtime::defensive",
                                        "pallet_staking::ledger",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        if true {
                            if !false {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "{0}: {1:?}",
                                            ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                            "update called on a ledger that is not bonded.",
                                        ),
                                    );
                                }
                            }
                        }
                        Error::<T>::NotController
                    })?,
                &self,
            );
            Ok(())
        }
        /// Bonds a ledger.
        ///
        /// It sets the reward preferences for the bonded stash.
        pub(crate) fn bond(
            self,
            payee: RewardDestination<T::AccountId>,
        ) -> Result<(), Error<T>> {
            if <Bonded<T>>::contains_key(&self.stash) {
                return Err(Error::<T>::AlreadyBonded);
            }
            <Payee<T>>::insert(&self.stash, payee);
            <Bonded<T>>::insert(&self.stash, &self.stash);
            self.update()
        }
        /// Sets the ledger Payee.
        pub(crate) fn set_payee(
            self,
            payee: RewardDestination<T::AccountId>,
        ) -> Result<(), Error<T>> {
            if !<Bonded<T>>::contains_key(&self.stash) {
                return Err(Error::<T>::NotStash);
            }
            <Payee<T>>::insert(&self.stash, payee);
            Ok(())
        }
        /// Sets the ledger controller to its stash.
        pub(crate) fn set_controller_to_stash(self) -> Result<(), Error<T>> {
            let controller = self
                .controller
                .as_ref()
                .defensive_proof(
                    "Ledger's controller field didn't exist. The controller should have been fetched using StakingLedger.",
                )
                .ok_or(Error::<T>::NotController)?;
            {
                if !(self.stash != *controller) {
                    {
                        return Err(Error::<T>::AlreadyPaired.into());
                    };
                }
            };
            if let Some(bonded_ledger) = Ledger::<T>::get(&self.stash) {
                {
                    if !(bonded_ledger.stash == self.stash) {
                        {
                            return Err(Error::<T>::BadState.into());
                        };
                    }
                };
            }
            <Ledger<T>>::remove(&controller);
            <Ledger<T>>::insert(&self.stash, &self);
            <Bonded<T>>::insert(&self.stash, &self.stash);
            Ok(())
        }
        /// Clears all data related to a staking ledger and its bond in both [`Ledger`] and [`Bonded`]
        /// storage items and updates the stash staking lock.
        pub(crate) fn kill(stash: &T::AccountId) -> Result<(), Error<T>> {
            let controller = <Bonded<T>>::get(stash).ok_or(Error::<T>::NotStash)?;
            <Ledger<T>>::get(&controller)
                .ok_or(Error::<T>::NotController)
                .map(|ledger| {
                    Ledger::<T>::remove(controller);
                    <Bonded<T>>::remove(&stash);
                    <Payee<T>>::remove(&stash);
                    if <VirtualStakers<T>>::take(&stash).is_none() {
                        asset::kill_stake::<T>(&ledger.stash);
                    }
                    Ok(())
                })?
        }
    }
}
pub mod migrations {
    //! Storage migrations for the Staking pallet. The changelog for this is maintained at
    //! [CHANGELOG.md](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/staking/CHANGELOG.md).
    use super::*;
    use frame_election_provider_support::SortedListProvider;
    use frame_support::{
        migrations::VersionedMigration, pallet_prelude::ValueQuery, storage_alias,
        traits::{GetStorageVersion, OnRuntimeUpgrade, UncheckedOnRuntimeUpgrade},
    };
    /// Used for release versioning up to v12.
    ///
    /// Obsolete from v13. Keeping around to make encoding/decoding of old migration code easier.
    enum ObsoleteReleases {
        V1_0_0Ancient,
        V2_0_0,
        V3_0_0,
        V4_0_0,
        V5_0_0,
        V6_0_0,
        V7_0_0,
        V8_0_0,
        V9_0_0,
        V10_0_0,
        V11_0_0,
        V12_0_0,
    }
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl ::codec::Encode for ObsoleteReleases {
            fn size_hint(&self) -> usize {
                1_usize
                    + match *self {
                        ObsoleteReleases::V1_0_0Ancient => 0_usize,
                        ObsoleteReleases::V2_0_0 => 0_usize,
                        ObsoleteReleases::V3_0_0 => 0_usize,
                        ObsoleteReleases::V4_0_0 => 0_usize,
                        ObsoleteReleases::V5_0_0 => 0_usize,
                        ObsoleteReleases::V6_0_0 => 0_usize,
                        ObsoleteReleases::V7_0_0 => 0_usize,
                        ObsoleteReleases::V8_0_0 => 0_usize,
                        ObsoleteReleases::V9_0_0 => 0_usize,
                        ObsoleteReleases::V10_0_0 => 0_usize,
                        ObsoleteReleases::V11_0_0 => 0_usize,
                        ObsoleteReleases::V12_0_0 => 0_usize,
                        _ => 0_usize,
                    }
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    ObsoleteReleases::V1_0_0Ancient => {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                    }
                    ObsoleteReleases::V2_0_0 => {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                    }
                    ObsoleteReleases::V3_0_0 => {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_dest_edqy.push_byte(2usize as ::core::primitive::u8);
                    }
                    ObsoleteReleases::V4_0_0 => {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_dest_edqy.push_byte(3usize as ::core::primitive::u8);
                    }
                    ObsoleteReleases::V5_0_0 => {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_dest_edqy.push_byte(4usize as ::core::primitive::u8);
                    }
                    ObsoleteReleases::V6_0_0 => {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_dest_edqy.push_byte(5usize as ::core::primitive::u8);
                    }
                    ObsoleteReleases::V7_0_0 => {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_dest_edqy.push_byte(6usize as ::core::primitive::u8);
                    }
                    ObsoleteReleases::V8_0_0 => {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_dest_edqy.push_byte(7usize as ::core::primitive::u8);
                    }
                    ObsoleteReleases::V9_0_0 => {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_dest_edqy.push_byte(8usize as ::core::primitive::u8);
                    }
                    ObsoleteReleases::V10_0_0 => {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_dest_edqy.push_byte(9usize as ::core::primitive::u8);
                    }
                    ObsoleteReleases::V11_0_0 => {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_dest_edqy.push_byte(10usize as ::core::primitive::u8);
                    }
                    ObsoleteReleases::V12_0_0 => {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_dest_edqy.push_byte(11usize as ::core::primitive::u8);
                    }
                    _ => {}
                }
            }
        }
        #[automatically_derived]
        impl ::codec::EncodeLike for ObsoleteReleases {}
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl ::codec::Decode for ObsoleteReleases {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                match __codec_input_edqy
                    .read_byte()
                    .map_err(|e| {
                        e
                            .chain(
                                "Could not decode `ObsoleteReleases`, failed to read variant byte",
                            )
                    })?
                {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_x_edqy if __codec_x_edqy
                        == 0usize as ::core::primitive::u8 => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Ok(ObsoleteReleases::V1_0_0Ancient)
                        })();
                    }
                    #[allow(clippy::unnecessary_cast)]
                    __codec_x_edqy if __codec_x_edqy
                        == 1usize as ::core::primitive::u8 => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Ok(ObsoleteReleases::V2_0_0)
                        })();
                    }
                    #[allow(clippy::unnecessary_cast)]
                    __codec_x_edqy if __codec_x_edqy
                        == 2usize as ::core::primitive::u8 => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Ok(ObsoleteReleases::V3_0_0)
                        })();
                    }
                    #[allow(clippy::unnecessary_cast)]
                    __codec_x_edqy if __codec_x_edqy
                        == 3usize as ::core::primitive::u8 => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Ok(ObsoleteReleases::V4_0_0)
                        })();
                    }
                    #[allow(clippy::unnecessary_cast)]
                    __codec_x_edqy if __codec_x_edqy
                        == 4usize as ::core::primitive::u8 => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Ok(ObsoleteReleases::V5_0_0)
                        })();
                    }
                    #[allow(clippy::unnecessary_cast)]
                    __codec_x_edqy if __codec_x_edqy
                        == 5usize as ::core::primitive::u8 => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Ok(ObsoleteReleases::V6_0_0)
                        })();
                    }
                    #[allow(clippy::unnecessary_cast)]
                    __codec_x_edqy if __codec_x_edqy
                        == 6usize as ::core::primitive::u8 => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Ok(ObsoleteReleases::V7_0_0)
                        })();
                    }
                    #[allow(clippy::unnecessary_cast)]
                    __codec_x_edqy if __codec_x_edqy
                        == 7usize as ::core::primitive::u8 => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Ok(ObsoleteReleases::V8_0_0)
                        })();
                    }
                    #[allow(clippy::unnecessary_cast)]
                    __codec_x_edqy if __codec_x_edqy
                        == 8usize as ::core::primitive::u8 => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Ok(ObsoleteReleases::V9_0_0)
                        })();
                    }
                    #[allow(clippy::unnecessary_cast)]
                    __codec_x_edqy if __codec_x_edqy
                        == 9usize as ::core::primitive::u8 => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Ok(ObsoleteReleases::V10_0_0)
                        })();
                    }
                    #[allow(clippy::unnecessary_cast)]
                    __codec_x_edqy if __codec_x_edqy
                        == 10usize as ::core::primitive::u8 => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Ok(ObsoleteReleases::V11_0_0)
                        })();
                    }
                    #[allow(clippy::unnecessary_cast)]
                    __codec_x_edqy if __codec_x_edqy
                        == 11usize as ::core::primitive::u8 => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Ok(ObsoleteReleases::V12_0_0)
                        })();
                    }
                    _ => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Err(
                                <_ as ::core::convert::Into<
                                    _,
                                >>::into(
                                    "Could not decode `ObsoleteReleases`, variant doesn't exist",
                                ),
                            )
                        })();
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for ObsoleteReleases {
        #[inline]
        fn clone(&self) -> ObsoleteReleases {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ObsoleteReleases {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ObsoleteReleases {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ObsoleteReleases {
        #[inline]
        fn eq(&self, other: &ObsoleteReleases) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for ObsoleteReleases {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    impl core::fmt::Debug for ObsoleteReleases {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self {
                Self::V1_0_0Ancient => {
                    fmt.debug_tuple("ObsoleteReleases::V1_0_0Ancient").finish()
                }
                Self::V2_0_0 => fmt.debug_tuple("ObsoleteReleases::V2_0_0").finish(),
                Self::V3_0_0 => fmt.debug_tuple("ObsoleteReleases::V3_0_0").finish(),
                Self::V4_0_0 => fmt.debug_tuple("ObsoleteReleases::V4_0_0").finish(),
                Self::V5_0_0 => fmt.debug_tuple("ObsoleteReleases::V5_0_0").finish(),
                Self::V6_0_0 => fmt.debug_tuple("ObsoleteReleases::V6_0_0").finish(),
                Self::V7_0_0 => fmt.debug_tuple("ObsoleteReleases::V7_0_0").finish(),
                Self::V8_0_0 => fmt.debug_tuple("ObsoleteReleases::V8_0_0").finish(),
                Self::V9_0_0 => fmt.debug_tuple("ObsoleteReleases::V9_0_0").finish(),
                Self::V10_0_0 => fmt.debug_tuple("ObsoleteReleases::V10_0_0").finish(),
                Self::V11_0_0 => fmt.debug_tuple("ObsoleteReleases::V11_0_0").finish(),
                Self::V12_0_0 => fmt.debug_tuple("ObsoleteReleases::V12_0_0").finish(),
                _ => Ok(()),
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl ::scale_info::TypeInfo for ObsoleteReleases {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder()
                    .path(
                        ::scale_info::Path::new_with_replace(
                            "ObsoleteReleases",
                            "pallet_staking::migrations",
                            &[],
                        ),
                    )
                    .type_params(::alloc::vec::Vec::new())
                    .docs(
                        &[
                            "Used for release versioning up to v12.",
                            "",
                            "Obsolete from v13. Keeping around to make encoding/decoding of old migration code easier.",
                        ],
                    )
                    .variant(
                        ::scale_info::build::Variants::new()
                            .variant(
                                "V1_0_0Ancient",
                                |v| v.index(0usize as ::core::primitive::u8),
                            )
                            .variant(
                                "V2_0_0",
                                |v| v.index(1usize as ::core::primitive::u8),
                            )
                            .variant(
                                "V3_0_0",
                                |v| v.index(2usize as ::core::primitive::u8),
                            )
                            .variant(
                                "V4_0_0",
                                |v| v.index(3usize as ::core::primitive::u8),
                            )
                            .variant(
                                "V5_0_0",
                                |v| v.index(4usize as ::core::primitive::u8),
                            )
                            .variant(
                                "V6_0_0",
                                |v| v.index(5usize as ::core::primitive::u8),
                            )
                            .variant(
                                "V7_0_0",
                                |v| v.index(6usize as ::core::primitive::u8),
                            )
                            .variant(
                                "V8_0_0",
                                |v| v.index(7usize as ::core::primitive::u8),
                            )
                            .variant(
                                "V9_0_0",
                                |v| v.index(8usize as ::core::primitive::u8),
                            )
                            .variant(
                                "V10_0_0",
                                |v| v.index(9usize as ::core::primitive::u8),
                            )
                            .variant(
                                "V11_0_0",
                                |v| v.index(10usize as ::core::primitive::u8),
                            )
                            .variant(
                                "V12_0_0",
                                |v| v.index(11usize as ::core::primitive::u8),
                            ),
                    )
            }
        }
    };
    const _: () = {
        impl ::codec::MaxEncodedLen for ObsoleteReleases {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize
                    .max(0_usize)
                    .max(0_usize)
                    .max(0_usize)
                    .max(0_usize)
                    .max(0_usize)
                    .max(0_usize)
                    .max(0_usize)
                    .max(0_usize)
                    .max(0_usize)
                    .max(0_usize)
                    .max(0_usize)
                    .max(0_usize)
                    .saturating_add(1)
            }
        }
    };
    impl Default for ObsoleteReleases {
        fn default() -> Self {
            ObsoleteReleases::V12_0_0
        }
    }
    #[allow(non_camel_case_types)]
    struct StorageVersion_Storage_Instance<T: Config>(::core::marker::PhantomData<(T)>);
    impl<T: Config> frame_support::traits::StorageInstance
    for StorageVersion_Storage_Instance<T> {
        fn pallet_prefix() -> &'static str {
            <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
        }
        const STORAGE_PREFIX: &'static str = "StorageVersion";
        fn storage_prefix_hash() -> [u8; 16] {
            [
                48u8,
                140u8,
                233u8,
                97u8,
                93u8,
                224u8,
                119u8,
                90u8,
                130u8,
                248u8,
                169u8,
                77u8,
                195u8,
                210u8,
                133u8,
                161u8,
            ]
        }
    }
    /// Alias to the old storage item used for release versioning. Obsolete since v13.
    type StorageVersion<T> = frame_support::storage::types::StorageValue<
        StorageVersion_Storage_Instance<T>,
        ObsoleteReleases,
        ValueQuery,
    >;
    /// Migrating `OffendingValidators` from `Vec<(u32, bool)>` to `Vec<u32>`
    pub mod v15 {
        use super::*;
        type DefaultDisablingStrategy = UpToLimitDisablingStrategy;
        pub struct VersionUncheckedMigrateV14ToV15<T>(core::marker::PhantomData<T>);
        impl<T: Config> UncheckedOnRuntimeUpgrade
        for VersionUncheckedMigrateV14ToV15<T> {
            fn on_runtime_upgrade() -> Weight {
                let mut migrated = v14::OffendingValidators::<T>::take()
                    .into_iter()
                    .filter(|p| p.1)
                    .map(|p| p.0)
                    .collect::<Vec<_>>();
                migrated
                    .truncate(
                        DefaultDisablingStrategy::disable_limit(
                            T::SessionInterface::validators().len(),
                        ),
                    );
                DisabledValidators::<T>::set(migrated);
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "[{0:?}] 💸 v15 applied successfully.",
                                <frame_system::Pallet<T>>::block_number(),
                            ),
                            lvl,
                            &(
                                crate::LOG_TARGET,
                                "pallet_staking::migrations::v15",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                };
                T::DbWeight::get().reads_writes(1, 1)
            }
        }
        pub type MigrateV14ToV15<T> = VersionedMigration<
            14,
            15,
            VersionUncheckedMigrateV14ToV15<T>,
            Pallet<T>,
            <T as frame_system::Config>::DbWeight,
        >;
    }
    /// Migration of era exposure storage items to paged exposures.
    /// Changelog: [v14.](https://github.com/paritytech/substrate/blob/ankan/paged-rewards-rebased2/frame/staking/CHANGELOG.md#14)
    pub mod v14 {
        use super::*;
        #[allow(non_camel_case_types)]
        pub(crate) struct OffendingValidators_Storage_Instance<T: Config>(
            ::core::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for OffendingValidators_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "OffendingValidators";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    162u8,
                    114u8,
                    27u8,
                    95u8,
                    220u8,
                    1u8,
                    159u8,
                    242u8,
                    72u8,
                    47u8,
                    145u8,
                    114u8,
                    171u8,
                    136u8,
                    42u8,
                    120u8,
                ]
            }
        }
        pub(crate) type OffendingValidators<T> = frame_support::storage::types::StorageValue<
            OffendingValidators_Storage_Instance<T>,
            Vec<(u32, bool)>,
            ValueQuery,
        >;
        pub struct MigrateToV14<T>(core::marker::PhantomData<T>);
        impl<T: Config> OnRuntimeUpgrade for MigrateToV14<T> {
            fn on_runtime_upgrade() -> Weight {
                let in_code = Pallet::<T>::in_code_storage_version();
                let on_chain = Pallet::<T>::on_chain_storage_version();
                if in_code == 14 && on_chain == 13 {
                    in_code.put::<Pallet<T>>();
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "[{0:?}] 💸 staking v14 applied successfully.",
                                    <frame_system::Pallet<T>>::block_number(),
                                ),
                                lvl,
                                &(
                                    crate::LOG_TARGET,
                                    "pallet_staking::migrations::v14",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    T::DbWeight::get().reads_writes(1, 1)
                } else {
                    {
                        let lvl = ::log::Level::Warn;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "[{0:?}] 💸 staking v14 not applied.",
                                    <frame_system::Pallet<T>>::block_number(),
                                ),
                                lvl,
                                &(
                                    crate::LOG_TARGET,
                                    "pallet_staking::migrations::v14",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    T::DbWeight::get().reads(1)
                }
            }
        }
    }
    pub mod v13 {
        use super::*;
        pub struct MigrateToV13<T>(core::marker::PhantomData<T>);
        impl<T: Config> OnRuntimeUpgrade for MigrateToV13<T> {
            fn on_runtime_upgrade() -> Weight {
                let in_code = Pallet::<T>::in_code_storage_version();
                let onchain = StorageVersion::<T>::get();
                if in_code == 13 && onchain == ObsoleteReleases::V12_0_0 {
                    StorageVersion::<T>::kill();
                    in_code.put::<Pallet<T>>();
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "[{0:?}] 💸 v13 applied successfully",
                                    <frame_system::Pallet<T>>::block_number(),
                                ),
                                lvl,
                                &(
                                    crate::LOG_TARGET,
                                    "pallet_staking::migrations::v13",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    T::DbWeight::get().reads_writes(1, 2)
                } else {
                    {
                        let lvl = ::log::Level::Warn;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "[{0:?}] 💸 Skipping v13, should be removed",
                                    <frame_system::Pallet<T>>::block_number(),
                                ),
                                lvl,
                                &(
                                    crate::LOG_TARGET,
                                    "pallet_staking::migrations::v13",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    T::DbWeight::get().reads(1)
                }
            }
        }
    }
    pub mod v12 {
        use super::*;
        use frame_support::{pallet_prelude::ValueQuery, storage_alias};
        #[allow(non_camel_case_types)]
        struct HistoryDepth_Storage_Instance<T: Config>(
            ::core::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for HistoryDepth_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "HistoryDepth";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    172u8,
                    10u8,
                    44u8,
                    191u8,
                    142u8,
                    53u8,
                    95u8,
                    94u8,
                    166u8,
                    203u8,
                    45u8,
                    232u8,
                    114u8,
                    123u8,
                    251u8,
                    12u8,
                ]
            }
        }
        type HistoryDepth<T> = frame_support::storage::types::StorageValue<
            HistoryDepth_Storage_Instance<T>,
            u32,
            ValueQuery,
        >;
        /// Clean up `T::HistoryDepth` from storage.
        ///
        /// We will be depending on the configurable value of `T::HistoryDepth` post
        /// this release.
        pub struct MigrateToV12<T>(core::marker::PhantomData<T>);
        impl<T: Config> OnRuntimeUpgrade for MigrateToV12<T> {
            fn on_runtime_upgrade() -> frame_support::weights::Weight {
                if StorageVersion::<T>::get() == ObsoleteReleases::V11_0_0 {
                    HistoryDepth::<T>::kill();
                    StorageVersion::<T>::put(ObsoleteReleases::V12_0_0);
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "[{0:?}] 💸 v12 applied successfully",
                                    <frame_system::Pallet<T>>::block_number(),
                                ),
                                lvl,
                                &(
                                    crate::LOG_TARGET,
                                    "pallet_staking::migrations::v12",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    T::DbWeight::get().reads_writes(1, 2)
                } else {
                    {
                        let lvl = ::log::Level::Warn;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "[{0:?}] 💸 Skipping v12, should be removed",
                                    <frame_system::Pallet<T>>::block_number(),
                                ),
                                lvl,
                                &(
                                    crate::LOG_TARGET,
                                    "pallet_staking::migrations::v12",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    T::DbWeight::get().reads(1)
                }
            }
        }
    }
    pub mod v11 {
        use super::*;
        use frame_support::{
            storage::migration::move_pallet,
            traits::{GetStorageVersion, PalletInfoAccess},
        };
        pub struct MigrateToV11<T, P, N>(core::marker::PhantomData<(T, P, N)>);
        impl<
            T: Config,
            P: GetStorageVersion + PalletInfoAccess,
            N: Get<&'static str>,
        > OnRuntimeUpgrade for MigrateToV11<T, P, N> {
            /// Migrate the entire storage of this pallet to a new prefix.
            ///
            /// This new prefix must be the same as the one set in construct_runtime. For safety, use
            /// `PalletInfo` to get it, as:
            /// `<Runtime as frame_system::Config>::PalletInfo::name::<VoterBagsList>`.
            ///
            /// The migration will look into the storage version in order to avoid triggering a
            /// migration on an up to date storage.
            fn on_runtime_upgrade() -> Weight {
                let old_pallet_name = N::get();
                let new_pallet_name = <P as PalletInfoAccess>::name();
                if StorageVersion::<T>::get() == ObsoleteReleases::V10_0_0 {
                    StorageVersion::<T>::put(ObsoleteReleases::V11_0_0);
                    if new_pallet_name == old_pallet_name {
                        {
                            let lvl = ::log::Level::Warn;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "[{0:?}] 💸 new bags-list name is equal to the old one, only bumping the version",
                                        <frame_system::Pallet<T>>::block_number(),
                                    ),
                                    lvl,
                                    &(
                                        crate::LOG_TARGET,
                                        "pallet_staking::migrations::v11",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        return T::DbWeight::get()
                            .reads(1)
                            .saturating_add(T::DbWeight::get().writes(1));
                    }
                    move_pallet(old_pallet_name.as_bytes(), new_pallet_name.as_bytes());
                    <T as frame_system::Config>::BlockWeights::get().max_block
                } else {
                    {
                        let lvl = ::log::Level::Warn;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "[{0:?}] 💸 v11::migrate should be removed.",
                                    <frame_system::Pallet<T>>::block_number(),
                                ),
                                lvl,
                                &(
                                    crate::LOG_TARGET,
                                    "pallet_staking::migrations::v11",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    T::DbWeight::get().reads(1)
                }
            }
        }
    }
    pub mod v10 {
        use super::*;
        use frame_support::storage_alias;
        #[allow(non_camel_case_types)]
        struct EarliestUnappliedSlash_Storage_Instance<T: Config>(
            ::core::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for EarliestUnappliedSlash_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "EarliestUnappliedSlash";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    96u8,
                    91u8,
                    44u8,
                    4u8,
                    107u8,
                    85u8,
                    9u8,
                    3u8,
                    127u8,
                    63u8,
                    21u8,
                    139u8,
                    151u8,
                    65u8,
                    208u8,
                    55u8,
                ]
            }
        }
        type EarliestUnappliedSlash<T> = frame_support::storage::types::StorageValue<
            EarliestUnappliedSlash_Storage_Instance<T>,
            EraIndex,
        >;
        /// Apply any pending slashes that where queued.
        ///
        /// That means we might slash someone a bit too early, but we will definitely
        /// won't forget to slash them. The cap of 512 is somewhat randomly taken to
        /// prevent us from iterating over an arbitrary large number of keys `on_runtime_upgrade`.
        pub struct MigrateToV10<T>(core::marker::PhantomData<T>);
        impl<T: Config> OnRuntimeUpgrade for MigrateToV10<T> {
            fn on_runtime_upgrade() -> frame_support::weights::Weight {
                if StorageVersion::<T>::get() == ObsoleteReleases::V9_0_0 {
                    let pending_slashes = UnappliedSlashes::<T>::iter().take(512);
                    for (era, slashes) in pending_slashes {
                        for slash in slashes {
                            {
                                let lvl = ::log::Level::Warn;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        format_args!(
                                            "[{0:?}] 💸 prematurely applying a slash ({1:?}) for era {2:?}",
                                            <frame_system::Pallet<T>>::block_number(),
                                            slash,
                                            era,
                                        ),
                                        lvl,
                                        &(
                                            crate::LOG_TARGET,
                                            "pallet_staking::migrations::v10",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            };
                            slashing::apply_slash::<T>(slash, era);
                        }
                    }
                    EarliestUnappliedSlash::<T>::kill();
                    StorageVersion::<T>::put(ObsoleteReleases::V10_0_0);
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "[{0:?}] 💸 MigrateToV10 executed successfully",
                                    <frame_system::Pallet<T>>::block_number(),
                                ),
                                lvl,
                                &(
                                    crate::LOG_TARGET,
                                    "pallet_staking::migrations::v10",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    T::DbWeight::get().reads_writes(1, 2)
                } else {
                    {
                        let lvl = ::log::Level::Warn;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "[{0:?}] 💸 MigrateToV10 should be removed.",
                                    <frame_system::Pallet<T>>::block_number(),
                                ),
                                lvl,
                                &(
                                    crate::LOG_TARGET,
                                    "pallet_staking::migrations::v10",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    T::DbWeight::get().reads(1)
                }
            }
        }
    }
    pub mod v9 {
        use super::*;
        /// Migration implementation that injects all validators into sorted list.
        ///
        /// This is only useful for chains that started their `VoterList` just based on nominators.
        pub struct InjectValidatorsIntoVoterList<T>(core::marker::PhantomData<T>);
        impl<T: Config> OnRuntimeUpgrade for InjectValidatorsIntoVoterList<T> {
            fn on_runtime_upgrade() -> Weight {
                if StorageVersion::<T>::get() == ObsoleteReleases::V8_0_0 {
                    let prev_count = T::VoterList::count();
                    let weight_of_cached = Pallet::<T>::weight_of_fn();
                    for (v, _) in Validators::<T>::iter() {
                        let weight = weight_of_cached(&v);
                        let _ = T::VoterList::on_insert(v.clone(), weight)
                            .map_err(|err| {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            format_args!(
                                                "[{0:?}] 💸 failed to insert {1:?} into VoterList: {2:?}",
                                                <frame_system::Pallet<T>>::block_number(),
                                                v,
                                                err,
                                            ),
                                            lvl,
                                            &(
                                                crate::LOG_TARGET,
                                                "pallet_staking::migrations::v9",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            });
                    }
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "[{0:?}] 💸 injected a total of {1} new voters, prev count: {2} next count: {3}, updating to version 9",
                                    <frame_system::Pallet<T>>::block_number(),
                                    Validators::<T>::count(),
                                    prev_count,
                                    T::VoterList::count(),
                                ),
                                lvl,
                                &(
                                    crate::LOG_TARGET,
                                    "pallet_staking::migrations::v9",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    StorageVersion::<T>::put(ObsoleteReleases::V9_0_0);
                    T::BlockWeights::get().max_block
                } else {
                    {
                        let lvl = ::log::Level::Warn;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "[{0:?}] 💸 InjectValidatorsIntoVoterList being executed on the wrong storage version, expected ObsoleteReleases::V8_0_0",
                                    <frame_system::Pallet<T>>::block_number(),
                                ),
                                lvl,
                                &(
                                    crate::LOG_TARGET,
                                    "pallet_staking::migrations::v9",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    T::DbWeight::get().reads(1)
                }
            }
        }
    }
    pub mod v8 {
        use super::*;
        use crate::{Config, Nominators, Pallet, Weight};
        use frame_election_provider_support::SortedListProvider;
        use frame_support::traits::Get;
        /// Migration to sorted `VoterList`.
        pub fn migrate<T: Config>() -> Weight {
            if StorageVersion::<T>::get() == ObsoleteReleases::V7_0_0 {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "[{0:?}] 💸 migrating staking to ObsoleteReleases::V8_0_0",
                                <frame_system::Pallet<T>>::block_number(),
                            ),
                            lvl,
                            &(
                                crate::LOG_TARGET,
                                "pallet_staking::migrations::v8",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                };
                let migrated = T::VoterList::unsafe_regenerate(
                    Nominators::<T>::iter().map(|(id, _)| id),
                    Pallet::<T>::weight_of_fn(),
                );
                StorageVersion::<T>::put(ObsoleteReleases::V8_0_0);
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "[{0:?}] 💸 👜 completed staking migration to ObsoleteReleases::V8_0_0 with {1} voters migrated",
                                <frame_system::Pallet<T>>::block_number(),
                                migrated,
                            ),
                            lvl,
                            &(
                                crate::LOG_TARGET,
                                "pallet_staking::migrations::v8",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                };
                T::BlockWeights::get().max_block
            } else {
                T::DbWeight::get().reads(1)
            }
        }
    }
    pub mod v7 {
        use super::*;
        use frame_support::storage_alias;
        #[allow(non_camel_case_types)]
        struct CounterForValidators_Storage_Instance<T: Config>(
            ::core::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for CounterForValidators_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "CounterForValidators";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    109u8,
                    220u8,
                    120u8,
                    9u8,
                    198u8,
                    218u8,
                    155u8,
                    182u8,
                    9u8,
                    62u8,
                    226u8,
                    46u8,
                    15u8,
                    218u8,
                    75u8,
                    168u8,
                ]
            }
        }
        type CounterForValidators<T> = frame_support::storage::types::StorageValue<
            CounterForValidators_Storage_Instance<T>,
            u32,
        >;
        #[allow(non_camel_case_types)]
        struct CounterForNominators_Storage_Instance<T: Config>(
            ::core::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for CounterForNominators_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "CounterForNominators";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    249u8,
                    155u8,
                    37u8,
                    133u8,
                    45u8,
                    61u8,
                    105u8,
                    65u8,
                    152u8,
                    130u8,
                    218u8,
                    101u8,
                    19u8,
                    117u8,
                    205u8,
                    179u8,
                ]
            }
        }
        type CounterForNominators<T> = frame_support::storage::types::StorageValue<
            CounterForNominators_Storage_Instance<T>,
            u32,
        >;
        pub fn pre_migrate<T: Config>() -> Result<(), &'static str> {
            if !CounterForValidators::<T>::get().unwrap().is_zero() {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("CounterForValidators already set."),
                    );
                }
            }
            if !CounterForNominators::<T>::get().unwrap().is_zero() {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("CounterForNominators already set."),
                    );
                }
            }
            if !Validators::<T>::count().is_zero() {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("Validators already set."),
                    );
                }
            }
            if !Nominators::<T>::count().is_zero() {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("Nominators already set."),
                    );
                }
            }
            if !(StorageVersion::<T>::get() == ObsoleteReleases::V6_0_0) {
                ::core::panicking::panic(
                    "assertion failed: StorageVersion::<T>::get() == ObsoleteReleases::V6_0_0",
                )
            }
            Ok(())
        }
        pub fn migrate<T: Config>() -> Weight {
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!(
                            "[{0:?}] 💸 Migrating staking to ObsoleteReleases::V7_0_0",
                            <frame_system::Pallet<T>>::block_number(),
                        ),
                        lvl,
                        &(
                            crate::LOG_TARGET,
                            "pallet_staking::migrations::v7",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            };
            let validator_count = Validators::<T>::iter().count() as u32;
            let nominator_count = Nominators::<T>::iter().count() as u32;
            CounterForValidators::<T>::put(validator_count);
            CounterForNominators::<T>::put(nominator_count);
            StorageVersion::<T>::put(ObsoleteReleases::V7_0_0);
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!(
                            "[{0:?}] 💸 Completed staking migration to ObsoleteReleases::V7_0_0",
                            <frame_system::Pallet<T>>::block_number(),
                        ),
                        lvl,
                        &(
                            crate::LOG_TARGET,
                            "pallet_staking::migrations::v7",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            };
            T::DbWeight::get()
                .reads_writes(validator_count.saturating_add(nominator_count).into(), 2)
        }
    }
    pub mod v6 {
        use super::*;
        use frame_support::{storage_alias, traits::Get, weights::Weight};
        #[allow(non_camel_case_types)]
        struct SnapshotValidators_Storage_Instance<T: Config>(
            ::core::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for SnapshotValidators_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "SnapshotValidators";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    126u8,
                    0u8,
                    108u8,
                    38u8,
                    214u8,
                    156u8,
                    76u8,
                    151u8,
                    246u8,
                    86u8,
                    72u8,
                    171u8,
                    129u8,
                    90u8,
                    39u8,
                    68u8,
                ]
            }
        }
        type SnapshotValidators<T> = frame_support::storage::types::StorageValue<
            SnapshotValidators_Storage_Instance<T>,
            (),
        >;
        #[allow(non_camel_case_types)]
        struct SnapshotNominators_Storage_Instance<T: Config>(
            ::core::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for SnapshotNominators_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "SnapshotNominators";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    247u8,
                    226u8,
                    87u8,
                    201u8,
                    67u8,
                    111u8,
                    230u8,
                    126u8,
                    44u8,
                    77u8,
                    157u8,
                    76u8,
                    237u8,
                    125u8,
                    69u8,
                    76u8,
                ]
            }
        }
        type SnapshotNominators<T> = frame_support::storage::types::StorageValue<
            SnapshotNominators_Storage_Instance<T>,
            (),
        >;
        #[allow(non_camel_case_types)]
        struct QueuedElected_Storage_Instance<T: Config>(
            ::core::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for QueuedElected_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "QueuedElected";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    80u8,
                    109u8,
                    34u8,
                    179u8,
                    53u8,
                    5u8,
                    182u8,
                    127u8,
                    82u8,
                    93u8,
                    129u8,
                    189u8,
                    0u8,
                    91u8,
                    22u8,
                    135u8,
                ]
            }
        }
        type QueuedElected<T> = frame_support::storage::types::StorageValue<
            QueuedElected_Storage_Instance<T>,
            (),
        >;
        #[allow(non_camel_case_types)]
        struct QueuedScore_Storage_Instance<T: Config>(::core::marker::PhantomData<(T)>);
        impl<T: Config> frame_support::traits::StorageInstance
        for QueuedScore_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "QueuedScore";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    179u8,
                    182u8,
                    147u8,
                    10u8,
                    243u8,
                    119u8,
                    186u8,
                    116u8,
                    247u8,
                    232u8,
                    55u8,
                    158u8,
                    68u8,
                    178u8,
                    199u8,
                    127u8,
                ]
            }
        }
        type QueuedScore<T> = frame_support::storage::types::StorageValue<
            QueuedScore_Storage_Instance<T>,
            (),
        >;
        #[allow(non_camel_case_types)]
        struct EraElectionStatus_Storage_Instance<T: Config>(
            ::core::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for EraElectionStatus_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "EraElectionStatus";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    225u8,
                    121u8,
                    21u8,
                    119u8,
                    228u8,
                    239u8,
                    203u8,
                    8u8,
                    63u8,
                    220u8,
                    60u8,
                    178u8,
                    30u8,
                    133u8,
                    178u8,
                    228u8,
                ]
            }
        }
        type EraElectionStatus<T> = frame_support::storage::types::StorageValue<
            EraElectionStatus_Storage_Instance<T>,
            (),
        >;
        #[allow(non_camel_case_types)]
        struct IsCurrentSessionFinal_Storage_Instance<T: Config>(
            ::core::marker::PhantomData<(T)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for IsCurrentSessionFinal_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "IsCurrentSessionFinal";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    163u8,
                    246u8,
                    221u8,
                    41u8,
                    154u8,
                    211u8,
                    175u8,
                    166u8,
                    133u8,
                    128u8,
                    162u8,
                    90u8,
                    115u8,
                    246u8,
                    234u8,
                    191u8,
                ]
            }
        }
        type IsCurrentSessionFinal<T> = frame_support::storage::types::StorageValue<
            IsCurrentSessionFinal_Storage_Instance<T>,
            (),
        >;
        /// check to execute prior to migration.
        pub fn pre_migrate<T: Config>() -> Result<(), &'static str> {
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!(
                            "[{0:?}] 💸 SnapshotValidators.exits()? {1:?}",
                            <frame_system::Pallet<T>>::block_number(),
                            SnapshotValidators::<T>::exists(),
                        ),
                        lvl,
                        &(
                            crate::LOG_TARGET,
                            "pallet_staking::migrations::v6",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            };
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!(
                            "[{0:?}] 💸 SnapshotNominators.exits()? {1:?}",
                            <frame_system::Pallet<T>>::block_number(),
                            SnapshotNominators::<T>::exists(),
                        ),
                        lvl,
                        &(
                            crate::LOG_TARGET,
                            "pallet_staking::migrations::v6",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            };
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!(
                            "[{0:?}] 💸 QueuedElected.exits()? {1:?}",
                            <frame_system::Pallet<T>>::block_number(),
                            QueuedElected::<T>::exists(),
                        ),
                        lvl,
                        &(
                            crate::LOG_TARGET,
                            "pallet_staking::migrations::v6",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            };
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!(
                            "[{0:?}] 💸 QueuedScore.exits()? {1:?}",
                            <frame_system::Pallet<T>>::block_number(),
                            QueuedScore::<T>::exists(),
                        ),
                        lvl,
                        &(
                            crate::LOG_TARGET,
                            "pallet_staking::migrations::v6",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            };
            if !IsCurrentSessionFinal::<T>::exists() {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("IsCurrentSessionFinal storage item not found!"),
                    );
                }
            }
            if !EraElectionStatus::<T>::exists() {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("EraElectionStatus storage item not found!"),
                    );
                }
            }
            Ok(())
        }
        /// Migrate storage to v6.
        pub fn migrate<T: Config>() -> Weight {
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!(
                            "[{0:?}] 💸 Migrating staking to ObsoleteReleases::V6_0_0",
                            <frame_system::Pallet<T>>::block_number(),
                        ),
                        lvl,
                        &(
                            crate::LOG_TARGET,
                            "pallet_staking::migrations::v6",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            };
            SnapshotValidators::<T>::kill();
            SnapshotNominators::<T>::kill();
            QueuedElected::<T>::kill();
            QueuedScore::<T>::kill();
            EraElectionStatus::<T>::kill();
            IsCurrentSessionFinal::<T>::kill();
            StorageVersion::<T>::put(ObsoleteReleases::V6_0_0);
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!(
                            "[{0:?}] 💸 Done.",
                            <frame_system::Pallet<T>>::block_number(),
                        ),
                        lvl,
                        &(
                            crate::LOG_TARGET,
                            "pallet_staking::migrations::v6",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            };
            T::DbWeight::get().writes(6 + 1)
        }
    }
}
pub mod slashing {
    //! A slashing implementation for NPoS systems.
    //!
    //! For the purposes of the economic model, it is easiest to think of each validator as a nominator
    //! which nominates only its own identity.
    //!
    //! The act of nomination signals intent to unify economic identity with the validator - to take
    //! part in the rewards of a job well done, and to take part in the punishment of a job done badly.
    //!
    //! There are 3 main difficulties to account for with slashing in NPoS:
    //!   - A nominator can nominate multiple validators and be slashed via any of them.
    //!   - Until slashed, stake is reused from era to era. Nominating with N coins for E eras in a row
    //!     does not mean you have N*E coins to be slashed - you've only ever had N.
    //!   - Slashable offences can be found after the fact and out of order.
    //!
    //! The algorithm implemented in this module tries to balance these 3 difficulties.
    //!
    //! First, we only slash participants for the _maximum_ slash they receive in some time period,
    //! rather than the sum. This ensures a protection from overslashing.
    //!
    //! Second, we do not want the time period (or "span") that the maximum is computed
    //! over to last indefinitely. That would allow participants to begin acting with
    //! impunity after some point, fearing no further repercussions. For that reason, we
    //! automatically "chill" validators and withdraw a nominator's nomination after a slashing event,
    //! requiring them to re-enlist voluntarily (acknowledging the slash) and begin a new
    //! slashing span.
    //!
    //! Typically, you will have a single slashing event per slashing span. Only in the case
    //! where a validator releases many misbehaviors at once, or goes "back in time" to misbehave in
    //! eras that have already passed, would you encounter situations where a slashing span
    //! has multiple misbehaviors. However, accounting for such cases is necessary
    //! to deter a class of "rage-quit" attacks.
    //!
    //! Based on research at <https://research.web3.foundation/en/latest/polkadot/slashing/npos.html>
    use crate::{
        asset, BalanceOf, Config, DisabledValidators, DisablingStrategy, Error, Exposure,
        NegativeImbalanceOf, NominatorSlashInEra, Pallet, Perbill, SessionInterface,
        SpanSlash, UnappliedSlash, ValidatorSlashInEra,
    };
    use alloc::vec::Vec;
    use codec::{Decode, Encode, MaxEncodedLen};
    use frame_support::{
        ensure, traits::{Defensive, DefensiveSaturating, Imbalance, OnUnbalanced},
    };
    use scale_info::TypeInfo;
    use sp_runtime::{
        traits::{Saturating, Zero},
        DispatchResult, RuntimeDebug,
    };
    use sp_staking::{EraIndex, StakingInterface};
    /// The proportion of the slashing reward to be paid out on the first slashing detection.
    /// This is f_1 in the paper.
    const REWARD_F1: Perbill = Perbill::from_percent(50);
    /// The index of a slashing span - unique to each stash.
    pub type SpanIndex = u32;
    pub(crate) struct SlashingSpan {
        pub(crate) index: SpanIndex,
        pub(crate) start: EraIndex,
        pub(crate) length: Option<EraIndex>,
    }
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl ::codec::Encode for SlashingSpan {
            fn size_hint(&self) -> usize {
                0_usize
                    .saturating_add(::codec::Encode::size_hint(&self.index))
                    .saturating_add(::codec::Encode::size_hint(&self.start))
                    .saturating_add(::codec::Encode::size_hint(&self.length))
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                ::codec::Encode::encode_to(&self.index, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.start, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.length, __codec_dest_edqy);
            }
        }
        #[automatically_derived]
        impl ::codec::EncodeLike for SlashingSpan {}
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl ::codec::Decode for SlashingSpan {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(SlashingSpan {
                    index: {
                        let __codec_res_edqy = <SpanIndex as ::codec::Decode>::decode(
                            __codec_input_edqy,
                        );
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `SlashingSpan::index`"),
                                );
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                __codec_res_edqy
                            }
                        }
                    },
                    start: {
                        let __codec_res_edqy = <EraIndex as ::codec::Decode>::decode(
                            __codec_input_edqy,
                        );
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `SlashingSpan::start`"),
                                );
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                __codec_res_edqy
                            }
                        }
                    },
                    length: {
                        let __codec_res_edqy = <Option<
                            EraIndex,
                        > as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `SlashingSpan::length`"),
                                );
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                __codec_res_edqy
                            }
                        }
                    },
                })
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl ::scale_info::TypeInfo for SlashingSpan {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder()
                    .path(
                        ::scale_info::Path::new_with_replace(
                            "SlashingSpan",
                            "pallet_staking::slashing",
                            &[],
                        ),
                    )
                    .type_params(::alloc::vec::Vec::new())
                    .composite(
                        ::scale_info::build::Fields::named()
                            .field(|f| {
                                f.ty::<SpanIndex>().name("index").type_name("SpanIndex")
                            })
                            .field(|f| {
                                f.ty::<EraIndex>().name("start").type_name("EraIndex")
                            })
                            .field(|f| {
                                f
                                    .ty::<Option<EraIndex>>()
                                    .name("length")
                                    .type_name("Option<EraIndex>")
                            }),
                    )
            }
        }
    };
    impl SlashingSpan {
        fn contains_era(&self, era: EraIndex) -> bool {
            self.start <= era
                && self.length.map_or(true, |l| self.start.saturating_add(l) > era)
        }
    }
    /// An encoding of all of a nominator's slashing spans.
    pub struct SlashingSpans {
        span_index: SpanIndex,
        last_start: EraIndex,
        last_nonzero_slash: EraIndex,
        prior: Vec<EraIndex>,
    }
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl ::codec::Encode for SlashingSpans {
            fn size_hint(&self) -> usize {
                0_usize
                    .saturating_add(::codec::Encode::size_hint(&self.span_index))
                    .saturating_add(::codec::Encode::size_hint(&self.last_start))
                    .saturating_add(::codec::Encode::size_hint(&self.last_nonzero_slash))
                    .saturating_add(::codec::Encode::size_hint(&self.prior))
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                ::codec::Encode::encode_to(&self.span_index, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.last_start, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.last_nonzero_slash, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.prior, __codec_dest_edqy);
            }
        }
        #[automatically_derived]
        impl ::codec::EncodeLike for SlashingSpans {}
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl ::codec::Decode for SlashingSpans {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(SlashingSpans {
                    span_index: {
                        let __codec_res_edqy = <SpanIndex as ::codec::Decode>::decode(
                            __codec_input_edqy,
                        );
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `SlashingSpans::span_index`"),
                                );
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                __codec_res_edqy
                            }
                        }
                    },
                    last_start: {
                        let __codec_res_edqy = <EraIndex as ::codec::Decode>::decode(
                            __codec_input_edqy,
                        );
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `SlashingSpans::last_start`"),
                                );
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                __codec_res_edqy
                            }
                        }
                    },
                    last_nonzero_slash: {
                        let __codec_res_edqy = <EraIndex as ::codec::Decode>::decode(
                            __codec_input_edqy,
                        );
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e
                                        .chain(
                                            "Could not decode `SlashingSpans::last_nonzero_slash`",
                                        ),
                                );
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                __codec_res_edqy
                            }
                        }
                    },
                    prior: {
                        let __codec_res_edqy = <Vec<
                            EraIndex,
                        > as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `SlashingSpans::prior`"),
                                );
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                __codec_res_edqy
                            }
                        }
                    },
                })
            }
        }
    };
    impl core::fmt::Debug for SlashingSpans {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_struct("SlashingSpans")
                .field("span_index", &self.span_index)
                .field("last_start", &self.last_start)
                .field("last_nonzero_slash", &self.last_nonzero_slash)
                .field("prior", &self.prior)
                .finish()
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl ::scale_info::TypeInfo for SlashingSpans {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder()
                    .path(
                        ::scale_info::Path::new_with_replace(
                            "SlashingSpans",
                            "pallet_staking::slashing",
                            &[],
                        ),
                    )
                    .type_params(::alloc::vec::Vec::new())
                    .docs(&["An encoding of all of a nominator's slashing spans."])
                    .composite(
                        ::scale_info::build::Fields::named()
                            .field(|f| {
                                f
                                    .ty::<SpanIndex>()
                                    .name("span_index")
                                    .type_name("SpanIndex")
                            })
                            .field(|f| {
                                f.ty::<EraIndex>().name("last_start").type_name("EraIndex")
                            })
                            .field(|f| {
                                f
                                    .ty::<EraIndex>()
                                    .name("last_nonzero_slash")
                                    .type_name("EraIndex")
                            })
                            .field(|f| {
                                f
                                    .ty::<Vec<EraIndex>>()
                                    .name("prior")
                                    .type_name("Vec<EraIndex>")
                            }),
                    )
            }
        }
    };
    impl SlashingSpans {
        pub(crate) fn new(window_start: EraIndex) -> Self {
            SlashingSpans {
                span_index: 0,
                last_start: window_start,
                last_nonzero_slash: 0,
                prior: Vec::new(),
            }
        }
        pub(crate) fn end_span(&mut self, now: EraIndex) -> bool {
            let next_start = now.defensive_saturating_add(1);
            if next_start <= self.last_start {
                return false;
            }
            let last_length = next_start.defensive_saturating_sub(self.last_start);
            self.prior.insert(0, last_length);
            self.last_start = next_start;
            self.span_index.defensive_saturating_accrue(1);
            true
        }
        pub(crate) fn iter(&'_ self) -> impl Iterator<Item = SlashingSpan> + '_ {
            let mut last_start = self.last_start;
            let mut index = self.span_index;
            let last = SlashingSpan {
                index,
                start: last_start,
                length: None,
            };
            let prior = self
                .prior
                .iter()
                .cloned()
                .map(move |length| {
                    let start = last_start.defensive_saturating_sub(length);
                    last_start = start;
                    index.defensive_saturating_reduce(1);
                    SlashingSpan {
                        index,
                        start,
                        length: Some(length),
                    }
                });
            core::iter::once(last).chain(prior)
        }
        /// Yields the era index where the most recent non-zero slash occurred.
        pub fn last_nonzero_slash(&self) -> EraIndex {
            self.last_nonzero_slash
        }
        fn prune(&mut self, window_start: EraIndex) -> Option<(SpanIndex, SpanIndex)> {
            let old_idx = self
                .iter()
                .skip(1)
                .position(|span| {
                    span.length
                        .map_or(
                            false,
                            |len| {
                                span.start.defensive_saturating_add(len) <= window_start
                            },
                        )
                });
            let earliest_span_index = self
                .span_index
                .defensive_saturating_sub(self.prior.len() as SpanIndex);
            let pruned = match old_idx {
                Some(o) => {
                    self.prior.truncate(o);
                    let new_earliest = self
                        .span_index
                        .defensive_saturating_sub(self.prior.len() as SpanIndex);
                    Some((earliest_span_index, new_earliest))
                }
                None => None,
            };
            self.last_start = core::cmp::max(self.last_start, window_start);
            pruned
        }
    }
    /// A slashing-span record for a particular stash.
    pub(crate) struct SpanRecord<Balance> {
        slashed: Balance,
        paid_out: Balance,
    }
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<Balance> ::codec::Encode for SpanRecord<Balance>
        where
            Balance: ::codec::Encode,
            Balance: ::codec::Encode,
            Balance: ::codec::Encode,
            Balance: ::codec::Encode,
        {
            fn size_hint(&self) -> usize {
                0_usize
                    .saturating_add(::codec::Encode::size_hint(&self.slashed))
                    .saturating_add(::codec::Encode::size_hint(&self.paid_out))
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                ::codec::Encode::encode_to(&self.slashed, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.paid_out, __codec_dest_edqy);
            }
        }
        #[automatically_derived]
        impl<Balance> ::codec::EncodeLike for SpanRecord<Balance>
        where
            Balance: ::codec::Encode,
            Balance: ::codec::Encode,
            Balance: ::codec::Encode,
            Balance: ::codec::Encode,
        {}
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<Balance> ::codec::Decode for SpanRecord<Balance>
        where
            Balance: ::codec::Decode,
            Balance: ::codec::Decode,
            Balance: ::codec::Decode,
            Balance: ::codec::Decode,
        {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(SpanRecord::<Balance> {
                    slashed: {
                        let __codec_res_edqy = <Balance as ::codec::Decode>::decode(
                            __codec_input_edqy,
                        );
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `SpanRecord::slashed`"),
                                );
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                __codec_res_edqy
                            }
                        }
                    },
                    paid_out: {
                        let __codec_res_edqy = <Balance as ::codec::Decode>::decode(
                            __codec_input_edqy,
                        );
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `SpanRecord::paid_out`"),
                                );
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                __codec_res_edqy
                            }
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    impl<Balance: ::core::default::Default> ::core::default::Default
    for SpanRecord<Balance> {
        #[inline]
        fn default() -> SpanRecord<Balance> {
            SpanRecord {
                slashed: ::core::default::Default::default(),
                paid_out: ::core::default::Default::default(),
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl<Balance> ::scale_info::TypeInfo for SpanRecord<Balance>
        where
            Balance: ::scale_info::TypeInfo + 'static,
            Balance: ::scale_info::TypeInfo + 'static,
            Balance: ::scale_info::TypeInfo + 'static,
        {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder()
                    .path(
                        ::scale_info::Path::new_with_replace(
                            "SpanRecord",
                            "pallet_staking::slashing",
                            &[],
                        ),
                    )
                    .type_params(
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                ::scale_info::TypeParameter::new(
                                    "Balance",
                                    ::core::option::Option::Some(
                                        ::scale_info::meta_type::<Balance>(),
                                    ),
                                ),
                            ]),
                        ),
                    )
                    .docs(&["A slashing-span record for a particular stash."])
                    .composite(
                        ::scale_info::build::Fields::named()
                            .field(|f| {
                                f.ty::<Balance>().name("slashed").type_name("Balance")
                            })
                            .field(|f| {
                                f.ty::<Balance>().name("paid_out").type_name("Balance")
                            }),
                    )
            }
        }
    };
    const _: () = {
        impl<Balance> ::codec::MaxEncodedLen for SpanRecord<Balance>
        where
            Balance: ::codec::MaxEncodedLen,
            Balance: ::codec::MaxEncodedLen,
            Balance: ::codec::MaxEncodedLen,
            Balance: ::codec::MaxEncodedLen,
        {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize
                    .saturating_add(<Balance>::max_encoded_len())
                    .saturating_add(<Balance>::max_encoded_len())
            }
        }
    };
    impl<Balance> SpanRecord<Balance> {}
    /// Parameters for performing a slash.
    pub(crate) struct SlashParams<'a, T: 'a + Config> {
        /// The stash account being slashed.
        pub(crate) stash: &'a T::AccountId,
        /// The proportion of the slash.
        pub(crate) slash: Perbill,
        /// The exposure of the stash and all nominators.
        pub(crate) exposure: &'a Exposure<T::AccountId, BalanceOf<T>>,
        /// The era where the offence occurred.
        pub(crate) slash_era: EraIndex,
        /// The first era in the current bonding period.
        pub(crate) window_start: EraIndex,
        /// The current era.
        pub(crate) now: EraIndex,
        /// The maximum percentage of a slash that ever gets paid out.
        /// This is f_inf in the paper.
        pub(crate) reward_proportion: Perbill,
    }
    #[automatically_derived]
    impl<'a, T: ::core::clone::Clone + 'a + Config> ::core::clone::Clone
    for SlashParams<'a, T>
    where
        T::AccountId: ::core::clone::Clone,
        T::AccountId: ::core::clone::Clone,
    {
        #[inline]
        fn clone(&self) -> SlashParams<'a, T> {
            SlashParams {
                stash: ::core::clone::Clone::clone(&self.stash),
                slash: ::core::clone::Clone::clone(&self.slash),
                exposure: ::core::clone::Clone::clone(&self.exposure),
                slash_era: ::core::clone::Clone::clone(&self.slash_era),
                window_start: ::core::clone::Clone::clone(&self.window_start),
                now: ::core::clone::Clone::clone(&self.now),
                reward_proportion: ::core::clone::Clone::clone(&self.reward_proportion),
            }
        }
    }
    /// Computes a slash of a validator and nominators. It returns an unapplied
    /// record to be applied at some later point. Slashing metadata is updated in storage,
    /// since unapplied records are only rarely intended to be dropped.
    ///
    /// The pending slash record returned does not have initialized reporters. Those have
    /// to be set at a higher level, if any.
    pub(crate) fn compute_slash<T: Config>(
        params: SlashParams<T>,
    ) -> Option<UnappliedSlash<T::AccountId, BalanceOf<T>>> {
        let mut reward_payout = Zero::zero();
        let mut val_slashed = Zero::zero();
        let own_slash = params.slash * params.exposure.own;
        if params.slash * params.exposure.total == Zero::zero() {
            kick_out_if_recent::<T>(params);
            return None;
        }
        let prior_slash_p = ValidatorSlashInEra::<
            T,
        >::get(&params.slash_era, params.stash)
            .map_or(Zero::zero(), |(prior_slash_proportion, _)| prior_slash_proportion);
        if params.slash.deconstruct() > prior_slash_p.deconstruct() {
            ValidatorSlashInEra::<
                T,
            >::insert(&params.slash_era, params.stash, &(params.slash, own_slash));
        } else {
            return None
        }
        {
            let mut spans = fetch_spans::<
                T,
            >(
                params.stash,
                params.window_start,
                &mut reward_payout,
                &mut val_slashed,
                params.reward_proportion,
            );
            let target_span = spans
                .compare_and_update_span_slash(params.slash_era, own_slash);
            if target_span == Some(spans.span_index()) {
                spans.end_span(params.now);
            }
        }
        add_offending_validator::<T>(&params);
        let mut nominators_slashed = Vec::new();
        reward_payout
            += slash_nominators::<
                T,
            >(params.clone(), prior_slash_p, &mut nominators_slashed);
        Some(UnappliedSlash {
            validator: params.stash.clone(),
            own: val_slashed,
            others: nominators_slashed,
            reporters: Vec::new(),
            payout: reward_payout,
        })
    }
    fn kick_out_if_recent<T: Config>(params: SlashParams<T>) {
        let mut reward_payout = Zero::zero();
        let mut val_slashed = Zero::zero();
        let mut spans = fetch_spans::<
            T,
        >(
            params.stash,
            params.window_start,
            &mut reward_payout,
            &mut val_slashed,
            params.reward_proportion,
        );
        if spans.era_span(params.slash_era).map(|s| s.index) == Some(spans.span_index())
        {
            spans.end_span(params.now);
        }
        add_offending_validator::<T>(&params);
    }
    /// Inform the [`DisablingStrategy`] implementation about the new offender and disable the list of
    /// validators provided by [`make_disabling_decision`].
    fn add_offending_validator<T: Config>(params: &SlashParams<T>) {
        DisabledValidators::<
            T,
        >::mutate(|disabled| {
            if let Some(offender) = T::DisablingStrategy::decision(
                params.stash,
                params.slash_era,
                &disabled,
            ) {
                if let Err(index) = disabled
                    .binary_search_by_key(&offender, |index| *index)
                {
                    disabled.insert(index, offender);
                    T::SessionInterface::disable_validator(offender);
                }
            }
        });
        if true {
            if !DisabledValidators::<T>::get().windows(2).all(|pair| pair[0] < pair[1]) {
                ::core::panicking::panic(
                    "assertion failed: DisabledValidators::<T>::get().windows(2).all(|pair| pair[0] < pair[1])",
                )
            }
        }
    }
    /// Slash nominators. Accepts general parameters and the prior slash percentage of the validator.
    ///
    /// Returns the amount of reward to pay out.
    fn slash_nominators<T: Config>(
        params: SlashParams<T>,
        prior_slash_p: Perbill,
        nominators_slashed: &mut Vec<(T::AccountId, BalanceOf<T>)>,
    ) -> BalanceOf<T> {
        let mut reward_payout = Zero::zero();
        nominators_slashed.reserve(params.exposure.others.len());
        for nominator in &params.exposure.others {
            let stash = &nominator.who;
            let mut nom_slashed = Zero::zero();
            let era_slash = {
                let own_slash_prior = prior_slash_p * nominator.value;
                let own_slash_by_validator = params.slash * nominator.value;
                let own_slash_difference = own_slash_by_validator
                    .saturating_sub(own_slash_prior);
                let mut era_slash = NominatorSlashInEra::<
                    T,
                >::get(&params.slash_era, stash)
                    .unwrap_or_else(Zero::zero);
                era_slash += own_slash_difference;
                NominatorSlashInEra::<T>::insert(&params.slash_era, stash, &era_slash);
                era_slash
            };
            {
                let mut spans = fetch_spans::<
                    T,
                >(
                    stash,
                    params.window_start,
                    &mut reward_payout,
                    &mut nom_slashed,
                    params.reward_proportion,
                );
                let target_span = spans
                    .compare_and_update_span_slash(params.slash_era, era_slash);
                if target_span == Some(spans.span_index()) {
                    spans.end_span(params.now);
                }
            }
            nominators_slashed.push((stash.clone(), nom_slashed));
        }
        reward_payout
    }
    struct InspectingSpans<'a, T: Config + 'a> {
        dirty: bool,
        window_start: EraIndex,
        stash: &'a T::AccountId,
        spans: SlashingSpans,
        paid_out: &'a mut BalanceOf<T>,
        slash_of: &'a mut BalanceOf<T>,
        reward_proportion: Perbill,
        _marker: core::marker::PhantomData<T>,
    }
    fn fetch_spans<'a, T: Config + 'a>(
        stash: &'a T::AccountId,
        window_start: EraIndex,
        paid_out: &'a mut BalanceOf<T>,
        slash_of: &'a mut BalanceOf<T>,
        reward_proportion: Perbill,
    ) -> InspectingSpans<'a, T> {
        let spans = crate::SlashingSpans::<T>::get(stash)
            .unwrap_or_else(|| {
                let spans = SlashingSpans::new(window_start);
                crate::SlashingSpans::<T>::insert(stash, &spans);
                spans
            });
        InspectingSpans {
            dirty: false,
            window_start,
            stash,
            spans,
            slash_of,
            paid_out,
            reward_proportion,
            _marker: core::marker::PhantomData,
        }
    }
    impl<'a, T: 'a + Config> InspectingSpans<'a, T> {
        fn span_index(&self) -> SpanIndex {
            self.spans.span_index
        }
        fn end_span(&mut self, now: EraIndex) {
            self.dirty = self.spans.end_span(now) || self.dirty;
        }
        fn add_slash(&mut self, amount: BalanceOf<T>, slash_era: EraIndex) {
            *self.slash_of += amount;
            self.spans.last_nonzero_slash = core::cmp::max(
                self.spans.last_nonzero_slash,
                slash_era,
            );
        }
        fn era_span(&self, era: EraIndex) -> Option<SlashingSpan> {
            self.spans.iter().find(|span| span.contains_era(era))
        }
        fn compare_and_update_span_slash(
            &mut self,
            slash_era: EraIndex,
            slash: BalanceOf<T>,
        ) -> Option<SpanIndex> {
            let target_span = self.era_span(slash_era)?;
            let span_slash_key = (self.stash.clone(), target_span.index);
            let mut span_record = SpanSlash::<T>::get(&span_slash_key);
            let mut changed = false;
            let reward = if span_record.slashed < slash {
                let difference = slash.defensive_saturating_sub(span_record.slashed);
                span_record.slashed = slash;
                let reward = REWARD_F1
                    * (self.reward_proportion * slash)
                        .saturating_sub(span_record.paid_out);
                self.add_slash(difference, slash_era);
                changed = true;
                reward
            } else if span_record.slashed == slash {
                REWARD_F1
                    * (self.reward_proportion * slash)
                        .saturating_sub(span_record.paid_out)
            } else {
                Zero::zero()
            };
            if !reward.is_zero() {
                changed = true;
                span_record.paid_out += reward;
                *self.paid_out += reward;
            }
            if changed {
                self.dirty = true;
                SpanSlash::<T>::insert(&span_slash_key, &span_record);
            }
            Some(target_span.index)
        }
    }
    impl<'a, T: 'a + Config> Drop for InspectingSpans<'a, T> {
        fn drop(&mut self) {
            if !self.dirty {
                return;
            }
            if let Some((start, end)) = self.spans.prune(self.window_start) {
                for span_index in start..end {
                    SpanSlash::<T>::remove(&(self.stash.clone(), span_index));
                }
            }
            crate::SlashingSpans::<T>::insert(self.stash, &self.spans);
        }
    }
    /// Clear slashing metadata for an obsolete era.
    pub(crate) fn clear_era_metadata<T: Config>(obsolete_era: EraIndex) {
        #[allow(deprecated)]
        ValidatorSlashInEra::<T>::remove_prefix(&obsolete_era, None);
        #[allow(deprecated)]
        NominatorSlashInEra::<T>::remove_prefix(&obsolete_era, None);
    }
    /// Clear slashing metadata for a dead account.
    pub(crate) fn clear_stash_metadata<T: Config>(
        stash: &T::AccountId,
        num_slashing_spans: u32,
    ) -> DispatchResult {
        let spans = match crate::SlashingSpans::<T>::get(stash) {
            None => return Ok(()),
            Some(s) => s,
        };
        {
            if !(num_slashing_spans as usize >= spans.iter().count()) {
                {
                    return Err(Error::<T>::IncorrectSlashingSpans.into());
                };
            }
        };
        crate::SlashingSpans::<T>::remove(stash);
        for span in spans.iter() {
            SpanSlash::<T>::remove(&(stash.clone(), span.index));
        }
        Ok(())
    }
    pub fn do_slash<T: Config>(
        stash: &T::AccountId,
        value: BalanceOf<T>,
        reward_payout: &mut BalanceOf<T>,
        slashed_imbalance: &mut NegativeImbalanceOf<T>,
        slash_era: EraIndex,
    ) {
        let mut ledger = match Pallet::<
            T,
        >::ledger(sp_staking::StakingAccount::Stash(stash.clone()))
            .defensive()
        {
            Ok(ledger) => ledger,
            Err(_) => return,
        };
        let value = ledger.slash(value, asset::existential_deposit::<T>(), slash_era);
        if value.is_zero() {
            return;
        }
        if !Pallet::<T>::is_virtual_staker(stash) {
            let (imbalance, missing) = asset::slash::<T>(stash, value);
            slashed_imbalance.subsume(imbalance);
            if !missing.is_zero() {
                *reward_payout = reward_payout.saturating_sub(missing);
            }
        }
        let _ = ledger
            .update()
            .defensive_proof(
                "ledger fetched from storage so it exists in storage; qed.",
            );
        <Pallet<
            T,
        >>::deposit_event(super::Event::<T>::Slashed {
            staker: stash.clone(),
            amount: value,
        });
    }
    /// Apply a previously-unapplied slash.
    pub(crate) fn apply_slash<T: Config>(
        unapplied_slash: UnappliedSlash<T::AccountId, BalanceOf<T>>,
        slash_era: EraIndex,
    ) {
        let mut slashed_imbalance = NegativeImbalanceOf::<T>::zero();
        let mut reward_payout = unapplied_slash.payout;
        do_slash::<
            T,
        >(
            &unapplied_slash.validator,
            unapplied_slash.own,
            &mut reward_payout,
            &mut slashed_imbalance,
            slash_era,
        );
        for &(ref nominator, nominator_slash) in &unapplied_slash.others {
            do_slash::<
                T,
            >(
                nominator,
                nominator_slash,
                &mut reward_payout,
                &mut slashed_imbalance,
                slash_era,
            );
        }
        pay_reporters::<T>(reward_payout, slashed_imbalance, &unapplied_slash.reporters);
    }
    /// Apply a reward payout to some reporters, paying the rewards out of the slashed imbalance.
    fn pay_reporters<T: Config>(
        reward_payout: BalanceOf<T>,
        slashed_imbalance: NegativeImbalanceOf<T>,
        reporters: &[T::AccountId],
    ) {
        if reward_payout.is_zero() || reporters.is_empty() {
            T::Slash::on_unbalanced(slashed_imbalance);
            return;
        }
        let reward_payout = reward_payout.min(slashed_imbalance.peek());
        let (mut reward_payout, mut value_slashed) = slashed_imbalance
            .split(reward_payout);
        let per_reporter = reward_payout.peek() / (reporters.len() as u32).into();
        for reporter in reporters {
            let (reporter_reward, rest) = reward_payout.split(per_reporter);
            reward_payout = rest;
            asset::deposit_slashed::<T>(reporter, reporter_reward);
        }
        value_slashed.subsume(reward_payout);
        T::Slash::on_unbalanced(value_slashed);
    }
}
pub mod weights {
    //! Autogenerated weights for `pallet_staking`
    //!
    //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 32.0.0
    //! DATE: 2024-04-09, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
    //! WORST CASE MAP SIZE: `1000000`
    //! HOSTNAME: `runner-anb7yjbi-project-674-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
    //! WASM-EXECUTION: `Compiled`, CHAIN: `Some("dev")`, DB CACHE: `1024`
    #![allow(unused_parens)]
    #![allow(unused_imports)]
    #![allow(missing_docs)]
    use frame_support::{traits::Get, weights::{Weight, constants::RocksDbWeight}};
    use core::marker::PhantomData;
    /// Weight functions needed for `pallet_staking`.
    pub trait WeightInfo {
        fn bond() -> Weight;
        fn bond_extra() -> Weight;
        fn unbond() -> Weight;
        fn withdraw_unbonded_update(s: u32) -> Weight;
        fn withdraw_unbonded_kill(s: u32) -> Weight;
        fn validate() -> Weight;
        fn kick(k: u32) -> Weight;
        fn nominate(n: u32) -> Weight;
        fn chill() -> Weight;
        fn set_payee() -> Weight;
        fn update_payee() -> Weight;
        fn set_controller() -> Weight;
        fn set_validator_count() -> Weight;
        fn force_no_eras() -> Weight;
        fn force_new_era() -> Weight;
        fn force_new_era_always() -> Weight;
        fn set_invulnerables(v: u32) -> Weight;
        fn deprecate_controller_batch(i: u32) -> Weight;
        fn force_unstake(s: u32) -> Weight;
        fn cancel_deferred_slash(s: u32) -> Weight;
        fn payout_stakers_alive_staked(n: u32) -> Weight;
        fn rebond(l: u32) -> Weight;
        fn reap_stash(s: u32) -> Weight;
        fn new_era(v: u32, n: u32) -> Weight;
        fn get_npos_voters(v: u32, n: u32) -> Weight;
        fn get_npos_targets(v: u32) -> Weight;
        fn set_staking_configs_all_set() -> Weight;
        fn set_staking_configs_all_remove() -> Weight;
        fn chill_other() -> Weight;
        fn force_apply_min_commission() -> Weight;
        fn set_min_commission() -> Weight;
        fn restore_ledger() -> Weight;
    }
    /// Weights for `pallet_staking` using the Substrate node and recommended hardware.
    pub struct SubstrateWeight<T>(PhantomData<T>);
    impl<T: frame_system::Config> WeightInfo for SubstrateWeight<T> {
        /// Storage: `Staking::Bonded` (r:1 w:1)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:0 w:1)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        fn bond() -> Weight {
            Weight::from_parts(48_459_000, 4764)
                .saturating_add(T::DbWeight::get().reads(4_u64))
                .saturating_add(T::DbWeight::get().writes(4_u64))
        }
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:3 w:3)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:2 w:2)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        fn bond_extra() -> Weight {
            Weight::from_parts(93_619_000, 8877)
                .saturating_add(T::DbWeight::get().reads(9_u64))
                .saturating_add(T::DbWeight::get().writes(7_u64))
        }
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:0)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinNominatorBond` (r:1 w:0)
        /// Proof: `Staking::MinNominatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:3 w:3)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:2 w:2)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        fn unbond() -> Weight {
            Weight::from_parts(101_440_000, 8877)
                .saturating_add(T::DbWeight::get().reads(12_u64))
                .saturating_add(T::DbWeight::get().writes(7_u64))
        }
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::ReversePoolIdLookup` (r:1 w:0)
        /// Proof: `NominationPools::ReversePoolIdLookup` (`max_values`: None, `max_size`: Some(44), added: 2519, mode: `MaxEncodedLen`)
        /// The range of component `s` is `[0, 100]`.
        fn withdraw_unbonded_update(s: u32) -> Weight {
            Weight::from_parts(52_396_327, 4764)
                .saturating_add(Weight::from_parts(51_406, 0).saturating_mul(s.into()))
                .saturating_add(T::DbWeight::get().reads(6_u64))
                .saturating_add(T::DbWeight::get().writes(2_u64))
        }
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:1)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::SlashingSpans` (r:1 w:1)
        /// Proof: `Staking::SlashingSpans` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:1)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForNominators` (r:1 w:1)
        /// Proof: `Staking::CounterForNominators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:2 w:2)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:0 w:1)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        /// Storage: `Staking::SpanSlash` (r:0 w:100)
        /// Proof: `Staking::SpanSlash` (`max_values`: None, `max_size`: Some(76), added: 2551, mode: `MaxEncodedLen`)
        /// The range of component `s` is `[0, 100]`.
        fn withdraw_unbonded_kill(s: u32) -> Weight {
            Weight::from_parts(101_398_156, 6248)
                .saturating_add(
                    Weight::from_parts(1_377_850, 0).saturating_mul(s.into()),
                )
                .saturating_add(T::DbWeight::get().reads(13_u64))
                .saturating_add(T::DbWeight::get().writes(11_u64))
                .saturating_add(
                    T::DbWeight::get().writes((1_u64).saturating_mul(s.into())),
                )
                .saturating_add(Weight::from_parts(0, 4).saturating_mul(s.into()))
        }
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinValidatorBond` (r:1 w:0)
        /// Proof: `Staking::MinValidatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinCommission` (r:1 w:0)
        /// Proof: `Staking::MinCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:1)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxValidatorsCount` (r:1 w:0)
        /// Proof: `Staking::MaxValidatorsCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:0)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:1 w:1)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForValidators` (r:1 w:1)
        /// Proof: `Staking::CounterForValidators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn validate() -> Weight {
            Weight::from_parts(58_372_000, 4556)
                .saturating_add(T::DbWeight::get().reads(11_u64))
                .saturating_add(T::DbWeight::get().writes(5_u64))
        }
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:128 w:128)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// The range of component `k` is `[1, 128]`.
        fn kick(k: u32) -> Weight {
            Weight::from_parts(38_811_308, 4556)
                .saturating_add(
                    Weight::from_parts(6_527_398, 0).saturating_mul(k.into()),
                )
                .saturating_add(T::DbWeight::get().reads(2_u64))
                .saturating_add(
                    T::DbWeight::get().reads((1_u64).saturating_mul(k.into())),
                )
                .saturating_add(
                    T::DbWeight::get().writes((1_u64).saturating_mul(k.into())),
                )
                .saturating_add(Weight::from_parts(0, 3033).saturating_mul(k.into()))
        }
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinNominatorBond` (r:1 w:0)
        /// Proof: `Staking::MinNominatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:1)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxNominatorsCount` (r:1 w:0)
        /// Proof: `Staking::MaxNominatorsCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:17 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:2 w:2)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForNominators` (r:1 w:1)
        /// Proof: `Staking::CounterForNominators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// The range of component `n` is `[1, 16]`.
        fn nominate(n: u32) -> Weight {
            Weight::from_parts(66_831_185, 6248)
                .saturating_add(
                    Weight::from_parts(4_031_635, 0).saturating_mul(n.into()),
                )
                .saturating_add(T::DbWeight::get().reads(12_u64))
                .saturating_add(
                    T::DbWeight::get().reads((1_u64).saturating_mul(n.into())),
                )
                .saturating_add(T::DbWeight::get().writes(6_u64))
                .saturating_add(Weight::from_parts(0, 2520).saturating_mul(n.into()))
        }
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:1)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForNominators` (r:1 w:1)
        /// Proof: `Staking::CounterForNominators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:2 w:2)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn chill() -> Weight {
            Weight::from_parts(62_471_000, 6248)
                .saturating_add(T::DbWeight::get().reads(9_u64))
                .saturating_add(T::DbWeight::get().writes(6_u64))
        }
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:0 w:1)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        fn set_payee() -> Weight {
            Weight::from_parts(20_690_000, 4556)
                .saturating_add(T::DbWeight::get().reads(2_u64))
                .saturating_add(T::DbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:1 w:1)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        fn update_payee() -> Weight {
            Weight::from_parts(24_409_000, 4556)
                .saturating_add(T::DbWeight::get().reads(3_u64))
                .saturating_add(T::DbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::Bonded` (r:1 w:1)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:2 w:2)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        fn set_controller() -> Weight {
            Weight::from_parts(24_502_000, 8122)
                .saturating_add(T::DbWeight::get().reads(3_u64))
                .saturating_add(T::DbWeight::get().writes(3_u64))
        }
        /// Storage: `Staking::ValidatorCount` (r:0 w:1)
        /// Proof: `Staking::ValidatorCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn set_validator_count() -> Weight {
            Weight::from_parts(2_802_000, 0)
                .saturating_add(T::DbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::ForceEra` (r:0 w:1)
        /// Proof: `Staking::ForceEra` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
        fn force_no_eras() -> Weight {
            Weight::from_parts(7_413_000, 0)
                .saturating_add(T::DbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::ForceEra` (r:0 w:1)
        /// Proof: `Staking::ForceEra` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
        fn force_new_era() -> Weight {
            Weight::from_parts(7_353_000, 0)
                .saturating_add(T::DbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::ForceEra` (r:0 w:1)
        /// Proof: `Staking::ForceEra` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
        fn force_new_era_always() -> Weight {
            Weight::from_parts(7_463_000, 0)
                .saturating_add(T::DbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::Invulnerables` (r:0 w:1)
        /// Proof: `Staking::Invulnerables` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
        /// The range of component `v` is `[0, 1000]`.
        fn set_invulnerables(v: u32) -> Weight {
            Weight::from_parts(3_328_130, 0)
                .saturating_add(Weight::from_parts(10_058, 0).saturating_mul(v.into()))
                .saturating_add(T::DbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::Ledger` (r:11800 w:11800)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:5900 w:5900)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:5900 w:0)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        /// The range of component `i` is `[0, 5900]`.
        fn deprecate_controller_batch(i: u32) -> Weight {
            Weight::from_parts(5_437_000, 990)
                .saturating_add(
                    Weight::from_parts(30_172_457, 0).saturating_mul(i.into()),
                )
                .saturating_add(
                    T::DbWeight::get().reads((4_u64).saturating_mul(i.into())),
                )
                .saturating_add(
                    T::DbWeight::get().writes((3_u64).saturating_mul(i.into())),
                )
                .saturating_add(Weight::from_parts(0, 7132).saturating_mul(i.into()))
        }
        /// Storage: `Staking::SlashingSpans` (r:1 w:1)
        /// Proof: `Staking::SlashingSpans` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Staking::Bonded` (r:1 w:1)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:1 w:1)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:1)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForNominators` (r:1 w:1)
        /// Proof: `Staking::CounterForNominators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:2 w:2)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:0 w:1)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        /// Storage: `Staking::SpanSlash` (r:0 w:100)
        /// Proof: `Staking::SpanSlash` (`max_values`: None, `max_size`: Some(76), added: 2551, mode: `MaxEncodedLen`)
        /// The range of component `s` is `[0, 100]`.
        fn force_unstake(s: u32) -> Weight {
            Weight::from_parts(96_386_462, 6248)
                .saturating_add(
                    Weight::from_parts(1_370_585, 0).saturating_mul(s.into()),
                )
                .saturating_add(T::DbWeight::get().reads(13_u64))
                .saturating_add(T::DbWeight::get().writes(12_u64))
                .saturating_add(
                    T::DbWeight::get().writes((1_u64).saturating_mul(s.into())),
                )
                .saturating_add(Weight::from_parts(0, 4).saturating_mul(s.into()))
        }
        /// Storage: `Staking::UnappliedSlashes` (r:1 w:1)
        /// Proof: `Staking::UnappliedSlashes` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// The range of component `s` is `[1, 1000]`.
        fn cancel_deferred_slash(s: u32) -> Weight {
            Weight::from_parts(1_167_895_222, 70137)
                .saturating_add(
                    Weight::from_parts(6_487_305, 0).saturating_mul(s.into()),
                )
                .saturating_add(T::DbWeight::get().reads(1_u64))
                .saturating_add(T::DbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::Bonded` (r:257 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:257 w:257)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ErasStakersClipped` (r:1 w:0)
        /// Proof: `Staking::ErasStakersClipped` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Staking::ErasStakersOverview` (r:1 w:0)
        /// Proof: `Staking::ErasStakersOverview` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ClaimedRewards` (r:1 w:1)
        /// Proof: `Staking::ClaimedRewards` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ErasValidatorReward` (r:1 w:0)
        /// Proof: `Staking::ErasValidatorReward` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:257 w:257)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:257 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:257 w:257)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ErasStakersPaged` (r:1 w:0)
        /// Proof: `Staking::ErasStakersPaged` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Staking::ErasRewardPoints` (r:1 w:0)
        /// Proof: `Staking::ErasRewardPoints` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Staking::ErasValidatorPrefs` (r:1 w:0)
        /// Proof: `Staking::ErasValidatorPrefs` (`max_values`: None, `max_size`: Some(57), added: 2532, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:257 w:0)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        /// The range of component `n` is `[0, 256]`.
        fn payout_stakers_alive_staked(n: u32) -> Weight {
            Weight::from_parts(192_836_012, 30944)
                .saturating_add(
                    Weight::from_parts(47_646_642, 0).saturating_mul(n.into()),
                )
                .saturating_add(T::DbWeight::get().reads(14_u64))
                .saturating_add(
                    T::DbWeight::get().reads((6_u64).saturating_mul(n.into())),
                )
                .saturating_add(T::DbWeight::get().writes(4_u64))
                .saturating_add(
                    T::DbWeight::get().writes((3_u64).saturating_mul(n.into())),
                )
                .saturating_add(Weight::from_parts(0, 3774).saturating_mul(n.into()))
        }
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:3 w:3)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:2 w:2)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// The range of component `l` is `[1, 32]`.
        fn rebond(l: u32) -> Weight {
            Weight::from_parts(91_391_254, 8877)
                .saturating_add(Weight::from_parts(103_443, 0).saturating_mul(l.into()))
                .saturating_add(T::DbWeight::get().reads(9_u64))
                .saturating_add(T::DbWeight::get().writes(7_u64))
        }
        /// Storage: `Staking::Bonded` (r:1 w:1)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::SlashingSpans` (r:1 w:1)
        /// Proof: `Staking::SlashingSpans` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:1)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForNominators` (r:1 w:1)
        /// Proof: `Staking::CounterForNominators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:2 w:2)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:0 w:1)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        /// Storage: `Staking::SpanSlash` (r:0 w:100)
        /// Proof: `Staking::SpanSlash` (`max_values`: None, `max_size`: Some(76), added: 2551, mode: `MaxEncodedLen`)
        /// The range of component `s` is `[1, 100]`.
        fn reap_stash(s: u32) -> Weight {
            Weight::from_parts(102_537_670, 6248)
                .saturating_add(
                    Weight::from_parts(1_353_142, 0).saturating_mul(s.into()),
                )
                .saturating_add(T::DbWeight::get().reads(12_u64))
                .saturating_add(T::DbWeight::get().writes(11_u64))
                .saturating_add(
                    T::DbWeight::get().writes((1_u64).saturating_mul(s.into())),
                )
                .saturating_add(Weight::from_parts(0, 4).saturating_mul(s.into()))
        }
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:0)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:200 w:0)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:110 w:0)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:110 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:110 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:110 w:0)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:11 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForValidators` (r:1 w:0)
        /// Proof: `Staking::CounterForValidators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ValidatorCount` (r:1 w:0)
        /// Proof: `Staking::ValidatorCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinimumValidatorCount` (r:1 w:0)
        /// Proof: `Staking::MinimumValidatorCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:1)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ErasValidatorPrefs` (r:0 w:10)
        /// Proof: `Staking::ErasValidatorPrefs` (`max_values`: None, `max_size`: Some(57), added: 2532, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ErasStakersPaged` (r:0 w:10)
        /// Proof: `Staking::ErasStakersPaged` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Staking::ErasStakersOverview` (r:0 w:10)
        /// Proof: `Staking::ErasStakersOverview` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ErasTotalStake` (r:0 w:1)
        /// Proof: `Staking::ErasTotalStake` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ErasStartSessionIndex` (r:0 w:1)
        /// Proof: `Staking::ErasStartSessionIndex` (`max_values`: None, `max_size`: Some(16), added: 2491, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinimumActiveStake` (r:0 w:1)
        /// Proof: `Staking::MinimumActiveStake` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// The range of component `v` is `[1, 10]`.
        /// The range of component `n` is `[0, 100]`.
        fn new_era(v: u32, n: u32) -> Weight {
            Weight::from_parts(613_663_000, 512390)
                .saturating_add(
                    Weight::from_parts(72_108_001, 0).saturating_mul(v.into()),
                )
                .saturating_add(
                    Weight::from_parts(20_314_085, 0).saturating_mul(n.into()),
                )
                .saturating_add(T::DbWeight::get().reads(206_u64))
                .saturating_add(
                    T::DbWeight::get().reads((5_u64).saturating_mul(v.into())),
                )
                .saturating_add(
                    T::DbWeight::get().reads((4_u64).saturating_mul(n.into())),
                )
                .saturating_add(T::DbWeight::get().writes(3_u64))
                .saturating_add(
                    T::DbWeight::get().writes((3_u64).saturating_mul(v.into())),
                )
                .saturating_add(Weight::from_parts(0, 3566).saturating_mul(n.into()))
                .saturating_add(Weight::from_parts(0, 3566).saturating_mul(v.into()))
        }
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:0)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:200 w:0)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:2000 w:0)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:2000 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:2000 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:2000 w:0)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1000 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinimumActiveStake` (r:0 w:1)
        /// Proof: `Staking::MinimumActiveStake` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// The range of component `v` is `[500, 1000]`.
        /// The range of component `n` is `[500, 1000]`.
        fn get_npos_voters(v: u32, n: u32) -> Weight {
            Weight::from_parts(37_488_937_000, 512390)
                .saturating_add(
                    Weight::from_parts(8_086_367, 0).saturating_mul(v.into()),
                )
                .saturating_add(
                    Weight::from_parts(3_108_193, 0).saturating_mul(n.into()),
                )
                .saturating_add(T::DbWeight::get().reads(201_u64))
                .saturating_add(
                    T::DbWeight::get().reads((5_u64).saturating_mul(v.into())),
                )
                .saturating_add(
                    T::DbWeight::get().reads((4_u64).saturating_mul(n.into())),
                )
                .saturating_add(T::DbWeight::get().writes(1_u64))
                .saturating_add(Weight::from_parts(0, 3566).saturating_mul(n.into()))
                .saturating_add(Weight::from_parts(0, 3566).saturating_mul(v.into()))
        }
        /// Storage: `Staking::CounterForValidators` (r:1 w:0)
        /// Proof: `Staking::CounterForValidators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1001 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// The range of component `v` is `[500, 1000]`.
        fn get_npos_targets(v: u32) -> Weight {
            Weight::from_parts(382_882_595, 3510)
                .saturating_add(
                    Weight::from_parts(4_695_820, 0).saturating_mul(v.into()),
                )
                .saturating_add(T::DbWeight::get().reads(2_u64))
                .saturating_add(
                    T::DbWeight::get().reads((1_u64).saturating_mul(v.into())),
                )
                .saturating_add(Weight::from_parts(0, 2520).saturating_mul(v.into()))
        }
        /// Storage: `Staking::MinCommission` (r:0 w:1)
        /// Proof: `Staking::MinCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinValidatorBond` (r:0 w:1)
        /// Proof: `Staking::MinValidatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxValidatorsCount` (r:0 w:1)
        /// Proof: `Staking::MaxValidatorsCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxStakedRewards` (r:0 w:1)
        /// Proof: `Staking::MaxStakedRewards` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ChillThreshold` (r:0 w:1)
        /// Proof: `Staking::ChillThreshold` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxNominatorsCount` (r:0 w:1)
        /// Proof: `Staking::MaxNominatorsCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinNominatorBond` (r:0 w:1)
        /// Proof: `Staking::MinNominatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        fn set_staking_configs_all_set() -> Weight {
            Weight::from_parts(6_529_000, 0)
                .saturating_add(T::DbWeight::get().writes(7_u64))
        }
        /// Storage: `Staking::MinCommission` (r:0 w:1)
        /// Proof: `Staking::MinCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinValidatorBond` (r:0 w:1)
        /// Proof: `Staking::MinValidatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxValidatorsCount` (r:0 w:1)
        /// Proof: `Staking::MaxValidatorsCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxStakedRewards` (r:0 w:1)
        /// Proof: `Staking::MaxStakedRewards` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ChillThreshold` (r:0 w:1)
        /// Proof: `Staking::ChillThreshold` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxNominatorsCount` (r:0 w:1)
        /// Proof: `Staking::MaxNominatorsCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinNominatorBond` (r:0 w:1)
        /// Proof: `Staking::MinNominatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        fn set_staking_configs_all_remove() -> Weight {
            Weight::from_parts(5_451_000, 0)
                .saturating_add(T::DbWeight::get().writes(7_u64))
        }
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:1)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ChillThreshold` (r:1 w:0)
        /// Proof: `Staking::ChillThreshold` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxNominatorsCount` (r:1 w:0)
        /// Proof: `Staking::MaxNominatorsCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForNominators` (r:1 w:1)
        /// Proof: `Staking::CounterForNominators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinNominatorBond` (r:1 w:0)
        /// Proof: `Staking::MinNominatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:2 w:2)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn chill_other() -> Weight {
            Weight::from_parts(75_184_000, 6248)
                .saturating_add(T::DbWeight::get().reads(12_u64))
                .saturating_add(T::DbWeight::get().writes(6_u64))
        }
        /// Storage: `Staking::MinCommission` (r:1 w:0)
        /// Proof: `Staking::MinCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:1)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        fn force_apply_min_commission() -> Weight {
            Weight::from_parts(13_517_000, 3510)
                .saturating_add(T::DbWeight::get().reads(2_u64))
                .saturating_add(T::DbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::MinCommission` (r:0 w:1)
        /// Proof: `Staking::MinCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn set_min_commission() -> Weight {
            Weight::from_parts(3_442_000, 0)
                .saturating_add(T::DbWeight::get().writes(1_u64))
        }
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:1 w:1)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:1)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        fn restore_ledger() -> Weight {
            Weight::from_parts(45_611_000, 4764)
                .saturating_add(T::DbWeight::get().reads(5_u64))
                .saturating_add(T::DbWeight::get().writes(4_u64))
        }
    }
    impl WeightInfo for () {
        /// Storage: `Staking::Bonded` (r:1 w:1)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:0 w:1)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        fn bond() -> Weight {
            Weight::from_parts(48_459_000, 4764)
                .saturating_add(RocksDbWeight::get().reads(4_u64))
                .saturating_add(RocksDbWeight::get().writes(4_u64))
        }
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:3 w:3)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:2 w:2)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        fn bond_extra() -> Weight {
            Weight::from_parts(93_619_000, 8877)
                .saturating_add(RocksDbWeight::get().reads(9_u64))
                .saturating_add(RocksDbWeight::get().writes(7_u64))
        }
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:0)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinNominatorBond` (r:1 w:0)
        /// Proof: `Staking::MinNominatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:3 w:3)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:2 w:2)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        fn unbond() -> Weight {
            Weight::from_parts(101_440_000, 8877)
                .saturating_add(RocksDbWeight::get().reads(12_u64))
                .saturating_add(RocksDbWeight::get().writes(7_u64))
        }
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::ReversePoolIdLookup` (r:1 w:0)
        /// Proof: `NominationPools::ReversePoolIdLookup` (`max_values`: None, `max_size`: Some(44), added: 2519, mode: `MaxEncodedLen`)
        /// The range of component `s` is `[0, 100]`.
        fn withdraw_unbonded_update(s: u32) -> Weight {
            Weight::from_parts(52_396_327, 4764)
                .saturating_add(Weight::from_parts(51_406, 0).saturating_mul(s.into()))
                .saturating_add(RocksDbWeight::get().reads(6_u64))
                .saturating_add(RocksDbWeight::get().writes(2_u64))
        }
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:1)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::SlashingSpans` (r:1 w:1)
        /// Proof: `Staking::SlashingSpans` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:1)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForNominators` (r:1 w:1)
        /// Proof: `Staking::CounterForNominators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:2 w:2)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:0 w:1)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        /// Storage: `Staking::SpanSlash` (r:0 w:100)
        /// Proof: `Staking::SpanSlash` (`max_values`: None, `max_size`: Some(76), added: 2551, mode: `MaxEncodedLen`)
        /// The range of component `s` is `[0, 100]`.
        fn withdraw_unbonded_kill(s: u32) -> Weight {
            Weight::from_parts(101_398_156, 6248)
                .saturating_add(
                    Weight::from_parts(1_377_850, 0).saturating_mul(s.into()),
                )
                .saturating_add(RocksDbWeight::get().reads(13_u64))
                .saturating_add(RocksDbWeight::get().writes(11_u64))
                .saturating_add(
                    RocksDbWeight::get().writes((1_u64).saturating_mul(s.into())),
                )
                .saturating_add(Weight::from_parts(0, 4).saturating_mul(s.into()))
        }
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinValidatorBond` (r:1 w:0)
        /// Proof: `Staking::MinValidatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinCommission` (r:1 w:0)
        /// Proof: `Staking::MinCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:1)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxValidatorsCount` (r:1 w:0)
        /// Proof: `Staking::MaxValidatorsCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:0)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:1 w:1)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForValidators` (r:1 w:1)
        /// Proof: `Staking::CounterForValidators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn validate() -> Weight {
            Weight::from_parts(58_372_000, 4556)
                .saturating_add(RocksDbWeight::get().reads(11_u64))
                .saturating_add(RocksDbWeight::get().writes(5_u64))
        }
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:128 w:128)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// The range of component `k` is `[1, 128]`.
        fn kick(k: u32) -> Weight {
            Weight::from_parts(38_811_308, 4556)
                .saturating_add(
                    Weight::from_parts(6_527_398, 0).saturating_mul(k.into()),
                )
                .saturating_add(RocksDbWeight::get().reads(2_u64))
                .saturating_add(
                    RocksDbWeight::get().reads((1_u64).saturating_mul(k.into())),
                )
                .saturating_add(
                    RocksDbWeight::get().writes((1_u64).saturating_mul(k.into())),
                )
                .saturating_add(Weight::from_parts(0, 3033).saturating_mul(k.into()))
        }
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinNominatorBond` (r:1 w:0)
        /// Proof: `Staking::MinNominatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:1)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxNominatorsCount` (r:1 w:0)
        /// Proof: `Staking::MaxNominatorsCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:17 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:2 w:2)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForNominators` (r:1 w:1)
        /// Proof: `Staking::CounterForNominators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// The range of component `n` is `[1, 16]`.
        fn nominate(n: u32) -> Weight {
            Weight::from_parts(66_831_185, 6248)
                .saturating_add(
                    Weight::from_parts(4_031_635, 0).saturating_mul(n.into()),
                )
                .saturating_add(RocksDbWeight::get().reads(12_u64))
                .saturating_add(
                    RocksDbWeight::get().reads((1_u64).saturating_mul(n.into())),
                )
                .saturating_add(RocksDbWeight::get().writes(6_u64))
                .saturating_add(Weight::from_parts(0, 2520).saturating_mul(n.into()))
        }
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:1)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForNominators` (r:1 w:1)
        /// Proof: `Staking::CounterForNominators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:2 w:2)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn chill() -> Weight {
            Weight::from_parts(62_471_000, 6248)
                .saturating_add(RocksDbWeight::get().reads(9_u64))
                .saturating_add(RocksDbWeight::get().writes(6_u64))
        }
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:0 w:1)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        fn set_payee() -> Weight {
            Weight::from_parts(20_690_000, 4556)
                .saturating_add(RocksDbWeight::get().reads(2_u64))
                .saturating_add(RocksDbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:1 w:1)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        fn update_payee() -> Weight {
            Weight::from_parts(24_409_000, 4556)
                .saturating_add(RocksDbWeight::get().reads(3_u64))
                .saturating_add(RocksDbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::Bonded` (r:1 w:1)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:2 w:2)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        fn set_controller() -> Weight {
            Weight::from_parts(24_502_000, 8122)
                .saturating_add(RocksDbWeight::get().reads(3_u64))
                .saturating_add(RocksDbWeight::get().writes(3_u64))
        }
        /// Storage: `Staking::ValidatorCount` (r:0 w:1)
        /// Proof: `Staking::ValidatorCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn set_validator_count() -> Weight {
            Weight::from_parts(2_802_000, 0)
                .saturating_add(RocksDbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::ForceEra` (r:0 w:1)
        /// Proof: `Staking::ForceEra` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
        fn force_no_eras() -> Weight {
            Weight::from_parts(7_413_000, 0)
                .saturating_add(RocksDbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::ForceEra` (r:0 w:1)
        /// Proof: `Staking::ForceEra` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
        fn force_new_era() -> Weight {
            Weight::from_parts(7_353_000, 0)
                .saturating_add(RocksDbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::ForceEra` (r:0 w:1)
        /// Proof: `Staking::ForceEra` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
        fn force_new_era_always() -> Weight {
            Weight::from_parts(7_463_000, 0)
                .saturating_add(RocksDbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::Invulnerables` (r:0 w:1)
        /// Proof: `Staking::Invulnerables` (`max_values`: Some(1), `max_size`: None, mode: `Measured`)
        /// The range of component `v` is `[0, 1000]`.
        fn set_invulnerables(v: u32) -> Weight {
            Weight::from_parts(3_328_130, 0)
                .saturating_add(Weight::from_parts(10_058, 0).saturating_mul(v.into()))
                .saturating_add(RocksDbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::Ledger` (r:11800 w:11800)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:5900 w:5900)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:5900 w:0)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        /// The range of component `i` is `[0, 5900]`.
        fn deprecate_controller_batch(i: u32) -> Weight {
            Weight::from_parts(5_437_000, 990)
                .saturating_add(
                    Weight::from_parts(30_172_457, 0).saturating_mul(i.into()),
                )
                .saturating_add(
                    RocksDbWeight::get().reads((4_u64).saturating_mul(i.into())),
                )
                .saturating_add(
                    RocksDbWeight::get().writes((3_u64).saturating_mul(i.into())),
                )
                .saturating_add(Weight::from_parts(0, 7132).saturating_mul(i.into()))
        }
        /// Storage: `Staking::SlashingSpans` (r:1 w:1)
        /// Proof: `Staking::SlashingSpans` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Staking::Bonded` (r:1 w:1)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:1 w:1)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:1)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForNominators` (r:1 w:1)
        /// Proof: `Staking::CounterForNominators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:2 w:2)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:0 w:1)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        /// Storage: `Staking::SpanSlash` (r:0 w:100)
        /// Proof: `Staking::SpanSlash` (`max_values`: None, `max_size`: Some(76), added: 2551, mode: `MaxEncodedLen`)
        /// The range of component `s` is `[0, 100]`.
        fn force_unstake(s: u32) -> Weight {
            Weight::from_parts(96_386_462, 6248)
                .saturating_add(
                    Weight::from_parts(1_370_585, 0).saturating_mul(s.into()),
                )
                .saturating_add(RocksDbWeight::get().reads(13_u64))
                .saturating_add(RocksDbWeight::get().writes(12_u64))
                .saturating_add(
                    RocksDbWeight::get().writes((1_u64).saturating_mul(s.into())),
                )
                .saturating_add(Weight::from_parts(0, 4).saturating_mul(s.into()))
        }
        /// Storage: `Staking::UnappliedSlashes` (r:1 w:1)
        /// Proof: `Staking::UnappliedSlashes` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// The range of component `s` is `[1, 1000]`.
        fn cancel_deferred_slash(s: u32) -> Weight {
            Weight::from_parts(1_167_895_222, 70137)
                .saturating_add(
                    Weight::from_parts(6_487_305, 0).saturating_mul(s.into()),
                )
                .saturating_add(RocksDbWeight::get().reads(1_u64))
                .saturating_add(RocksDbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::Bonded` (r:257 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:257 w:257)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ErasStakersClipped` (r:1 w:0)
        /// Proof: `Staking::ErasStakersClipped` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Staking::ErasStakersOverview` (r:1 w:0)
        /// Proof: `Staking::ErasStakersOverview` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ClaimedRewards` (r:1 w:1)
        /// Proof: `Staking::ClaimedRewards` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ErasValidatorReward` (r:1 w:0)
        /// Proof: `Staking::ErasValidatorReward` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:257 w:257)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:257 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:257 w:257)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ErasStakersPaged` (r:1 w:0)
        /// Proof: `Staking::ErasStakersPaged` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Staking::ErasRewardPoints` (r:1 w:0)
        /// Proof: `Staking::ErasRewardPoints` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Staking::ErasValidatorPrefs` (r:1 w:0)
        /// Proof: `Staking::ErasValidatorPrefs` (`max_values`: None, `max_size`: Some(57), added: 2532, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:257 w:0)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        /// The range of component `n` is `[0, 256]`.
        fn payout_stakers_alive_staked(n: u32) -> Weight {
            Weight::from_parts(192_836_012, 30944)
                .saturating_add(
                    Weight::from_parts(47_646_642, 0).saturating_mul(n.into()),
                )
                .saturating_add(RocksDbWeight::get().reads(14_u64))
                .saturating_add(
                    RocksDbWeight::get().reads((6_u64).saturating_mul(n.into())),
                )
                .saturating_add(RocksDbWeight::get().writes(4_u64))
                .saturating_add(
                    RocksDbWeight::get().writes((3_u64).saturating_mul(n.into())),
                )
                .saturating_add(Weight::from_parts(0, 3774).saturating_mul(n.into()))
        }
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:3 w:3)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:2 w:2)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// The range of component `l` is `[1, 32]`.
        fn rebond(l: u32) -> Weight {
            Weight::from_parts(91_391_254, 8877)
                .saturating_add(Weight::from_parts(103_443, 0).saturating_mul(l.into()))
                .saturating_add(RocksDbWeight::get().reads(9_u64))
                .saturating_add(RocksDbWeight::get().writes(7_u64))
        }
        /// Storage: `Staking::Bonded` (r:1 w:1)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::SlashingSpans` (r:1 w:1)
        /// Proof: `Staking::SlashingSpans` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:1)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForNominators` (r:1 w:1)
        /// Proof: `Staking::CounterForNominators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:2 w:2)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:0 w:1)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        /// Storage: `Staking::SpanSlash` (r:0 w:100)
        /// Proof: `Staking::SpanSlash` (`max_values`: None, `max_size`: Some(76), added: 2551, mode: `MaxEncodedLen`)
        /// The range of component `s` is `[1, 100]`.
        fn reap_stash(s: u32) -> Weight {
            Weight::from_parts(102_537_670, 6248)
                .saturating_add(
                    Weight::from_parts(1_353_142, 0).saturating_mul(s.into()),
                )
                .saturating_add(RocksDbWeight::get().reads(12_u64))
                .saturating_add(RocksDbWeight::get().writes(11_u64))
                .saturating_add(
                    RocksDbWeight::get().writes((1_u64).saturating_mul(s.into())),
                )
                .saturating_add(Weight::from_parts(0, 4).saturating_mul(s.into()))
        }
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:0)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:200 w:0)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:110 w:0)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:110 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:110 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:110 w:0)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:11 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForValidators` (r:1 w:0)
        /// Proof: `Staking::CounterForValidators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ValidatorCount` (r:1 w:0)
        /// Proof: `Staking::ValidatorCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinimumValidatorCount` (r:1 w:0)
        /// Proof: `Staking::MinimumValidatorCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:1)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ErasValidatorPrefs` (r:0 w:10)
        /// Proof: `Staking::ErasValidatorPrefs` (`max_values`: None, `max_size`: Some(57), added: 2532, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ErasStakersPaged` (r:0 w:10)
        /// Proof: `Staking::ErasStakersPaged` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Staking::ErasStakersOverview` (r:0 w:10)
        /// Proof: `Staking::ErasStakersOverview` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ErasTotalStake` (r:0 w:1)
        /// Proof: `Staking::ErasTotalStake` (`max_values`: None, `max_size`: Some(28), added: 2503, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ErasStartSessionIndex` (r:0 w:1)
        /// Proof: `Staking::ErasStartSessionIndex` (`max_values`: None, `max_size`: Some(16), added: 2491, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinimumActiveStake` (r:0 w:1)
        /// Proof: `Staking::MinimumActiveStake` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// The range of component `v` is `[1, 10]`.
        /// The range of component `n` is `[0, 100]`.
        fn new_era(v: u32, n: u32) -> Weight {
            Weight::from_parts(613_663_000, 512390)
                .saturating_add(
                    Weight::from_parts(72_108_001, 0).saturating_mul(v.into()),
                )
                .saturating_add(
                    Weight::from_parts(20_314_085, 0).saturating_mul(n.into()),
                )
                .saturating_add(RocksDbWeight::get().reads(206_u64))
                .saturating_add(
                    RocksDbWeight::get().reads((5_u64).saturating_mul(v.into())),
                )
                .saturating_add(
                    RocksDbWeight::get().reads((4_u64).saturating_mul(n.into())),
                )
                .saturating_add(RocksDbWeight::get().writes(3_u64))
                .saturating_add(
                    RocksDbWeight::get().writes((3_u64).saturating_mul(v.into())),
                )
                .saturating_add(Weight::from_parts(0, 3566).saturating_mul(n.into()))
                .saturating_add(Weight::from_parts(0, 3566).saturating_mul(v.into()))
        }
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:0)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:200 w:0)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:2000 w:0)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:2000 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:2000 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:2000 w:0)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1000 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinimumActiveStake` (r:0 w:1)
        /// Proof: `Staking::MinimumActiveStake` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// The range of component `v` is `[500, 1000]`.
        /// The range of component `n` is `[500, 1000]`.
        fn get_npos_voters(v: u32, n: u32) -> Weight {
            Weight::from_parts(37_488_937_000, 512390)
                .saturating_add(
                    Weight::from_parts(8_086_367, 0).saturating_mul(v.into()),
                )
                .saturating_add(
                    Weight::from_parts(3_108_193, 0).saturating_mul(n.into()),
                )
                .saturating_add(RocksDbWeight::get().reads(201_u64))
                .saturating_add(
                    RocksDbWeight::get().reads((5_u64).saturating_mul(v.into())),
                )
                .saturating_add(
                    RocksDbWeight::get().reads((4_u64).saturating_mul(n.into())),
                )
                .saturating_add(RocksDbWeight::get().writes(1_u64))
                .saturating_add(Weight::from_parts(0, 3566).saturating_mul(n.into()))
                .saturating_add(Weight::from_parts(0, 3566).saturating_mul(v.into()))
        }
        /// Storage: `Staking::CounterForValidators` (r:1 w:0)
        /// Proof: `Staking::CounterForValidators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1001 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// The range of component `v` is `[500, 1000]`.
        fn get_npos_targets(v: u32) -> Weight {
            Weight::from_parts(382_882_595, 3510)
                .saturating_add(
                    Weight::from_parts(4_695_820, 0).saturating_mul(v.into()),
                )
                .saturating_add(RocksDbWeight::get().reads(2_u64))
                .saturating_add(
                    RocksDbWeight::get().reads((1_u64).saturating_mul(v.into())),
                )
                .saturating_add(Weight::from_parts(0, 2520).saturating_mul(v.into()))
        }
        /// Storage: `Staking::MinCommission` (r:0 w:1)
        /// Proof: `Staking::MinCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinValidatorBond` (r:0 w:1)
        /// Proof: `Staking::MinValidatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxValidatorsCount` (r:0 w:1)
        /// Proof: `Staking::MaxValidatorsCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxStakedRewards` (r:0 w:1)
        /// Proof: `Staking::MaxStakedRewards` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ChillThreshold` (r:0 w:1)
        /// Proof: `Staking::ChillThreshold` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxNominatorsCount` (r:0 w:1)
        /// Proof: `Staking::MaxNominatorsCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinNominatorBond` (r:0 w:1)
        /// Proof: `Staking::MinNominatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        fn set_staking_configs_all_set() -> Weight {
            Weight::from_parts(6_529_000, 0)
                .saturating_add(RocksDbWeight::get().writes(7_u64))
        }
        /// Storage: `Staking::MinCommission` (r:0 w:1)
        /// Proof: `Staking::MinCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinValidatorBond` (r:0 w:1)
        /// Proof: `Staking::MinValidatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxValidatorsCount` (r:0 w:1)
        /// Proof: `Staking::MaxValidatorsCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxStakedRewards` (r:0 w:1)
        /// Proof: `Staking::MaxStakedRewards` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ChillThreshold` (r:0 w:1)
        /// Proof: `Staking::ChillThreshold` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxNominatorsCount` (r:0 w:1)
        /// Proof: `Staking::MaxNominatorsCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinNominatorBond` (r:0 w:1)
        /// Proof: `Staking::MinNominatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        fn set_staking_configs_all_remove() -> Weight {
            Weight::from_parts(5_451_000, 0)
                .saturating_add(RocksDbWeight::get().writes(7_u64))
        }
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:1)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::ChillThreshold` (r:1 w:0)
        /// Proof: `Staking::ChillThreshold` (`max_values`: Some(1), `max_size`: Some(1), added: 496, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxNominatorsCount` (r:1 w:0)
        /// Proof: `Staking::MaxNominatorsCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForNominators` (r:1 w:1)
        /// Proof: `Staking::CounterForNominators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinNominatorBond` (r:1 w:0)
        /// Proof: `Staking::MinNominatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:2 w:2)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn chill_other() -> Weight {
            Weight::from_parts(75_184_000, 6248)
                .saturating_add(RocksDbWeight::get().reads(12_u64))
                .saturating_add(RocksDbWeight::get().writes(6_u64))
        }
        /// Storage: `Staking::MinCommission` (r:1 w:0)
        /// Proof: `Staking::MinCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:1)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        fn force_apply_min_commission() -> Weight {
            Weight::from_parts(13_517_000, 3510)
                .saturating_add(RocksDbWeight::get().reads(2_u64))
                .saturating_add(RocksDbWeight::get().writes(1_u64))
        }
        /// Storage: `Staking::MinCommission` (r:0 w:1)
        /// Proof: `Staking::MinCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn set_min_commission() -> Weight {
            Weight::from_parts(3_442_000, 0)
                .saturating_add(RocksDbWeight::get().writes(1_u64))
        }
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:1 w:1)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:1)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        fn restore_ledger() -> Weight {
            Weight::from_parts(45_611_000, 4764)
                .saturating_add(RocksDbWeight::get().reads(5_u64))
                .saturating_add(RocksDbWeight::get().writes(4_u64))
        }
    }
}
mod pallet {
    //! Staking FRAME Pallet.
    use alloc::vec::Vec;
    use codec::Codec;
    use frame_election_provider_support::{
        ElectionProvider, ElectionProviderBase, SortedListProvider, VoteWeight,
    };
    use frame_support::{
        pallet_prelude::*,
        traits::{
            Defensive, DefensiveSaturating, EnsureOrigin, EstimateNextNewSession, Get,
            InspectLockableCurrency, LockableCurrency, OnUnbalanced, UnixTime,
        },
        weights::Weight, BoundedVec,
    };
    use frame_system::{ensure_root, ensure_signed, pallet_prelude::*};
    use sp_runtime::{
        traits::{SaturatedConversion, StaticLookup, Zero},
        ArithmeticError, Perbill, Percent,
    };
    use sp_staking::{
        EraIndex, Page, SessionIndex, StakingAccount::{self, Controller, Stash},
        StakingInterface,
    };
    mod impls {
        //! Implementations for the Staking FRAME Pallet.
        use frame_election_provider_support::{
            bounds::{CountBound, SizeBound},
            data_provider, BoundedSupportsOf, DataProviderBounds, ElectionDataProvider,
            ElectionProvider, ScoreProvider, SortedListProvider, VoteWeight, VoterOf,
        };
        use frame_support::{
            defensive, dispatch::WithPostDispatchInfo, pallet_prelude::*,
            traits::{
                Defensive, DefensiveSaturating, EstimateNextNewSession, Get, Imbalance,
                Len, OnUnbalanced, TryCollect, UnixTime,
            },
            weights::Weight,
        };
        use frame_system::{pallet_prelude::BlockNumberFor, RawOrigin};
        use pallet_session::historical;
        use sp_runtime::{
            traits::{
                Bounded, CheckedAdd, CheckedSub, Convert, One, SaturatedConversion,
                Saturating, StaticLookup, Zero,
            },
            ArithmeticError, Perbill, Percent,
        };
        use sp_staking::{
            currency_to_vote::CurrencyToVote,
            offence::{OffenceDetails, OnOffenceHandler},
            EraIndex, OnStakingUpdate, Page, SessionIndex, Stake,
            StakingAccount::{self, Controller, Stash},
            StakingInterface,
        };
        use crate::{
            asset, election_size_tracker::StaticTracker, log, slashing,
            weights::WeightInfo, ActiveEraInfo, BalanceOf, EraInfo, EraPayout, Exposure,
            ExposureOf, Forcing, IndividualExposure, LedgerIntegrityState,
            MaxNominationsOf, MaxWinnersOf, Nominations, NominationsQuota,
            PositiveImbalanceOf, RewardDestination, SessionInterface, StakingLedger,
            ValidatorPrefs,
        };
        use alloc::{boxed::Box, vec, vec::Vec};
        use super::pallet::*;
        /// The maximum number of iterations that we do whilst iterating over `T::VoterList` in
        /// `get_npos_voters`.
        ///
        /// In most cases, if we want n items, we iterate exactly n times. In rare cases, if a voter is
        /// invalid (for any reason) the iteration continues. With this constant, we iterate at most 2 * n
        /// times and then give up.
        const NPOS_MAX_ITERATIONS_COEFFICIENT: u32 = 2;
        impl<T: Config> Pallet<T> {
            /// Fetches the ledger associated with a controller or stash account, if any.
            pub fn ledger(
                account: StakingAccount<T::AccountId>,
            ) -> Result<StakingLedger<T>, Error<T>> {
                StakingLedger::<T>::get(account)
            }
            pub fn payee(
                account: StakingAccount<T::AccountId>,
            ) -> Option<RewardDestination<T::AccountId>> {
                StakingLedger::<T>::reward_destination(account)
            }
            /// Fetches the controller bonded to a stash account, if any.
            pub fn bonded(stash: &T::AccountId) -> Option<T::AccountId> {
                StakingLedger::<T>::paired_account(Stash(stash.clone()))
            }
            /// Inspects and returns the corruption state of a ledger and direct bond, if any.
            ///
            /// Note: all operations in this method access directly the `Bonded` and `Ledger` storage maps
            /// instead of using the [`StakingLedger`] API since the bond and/or ledger may be corrupted.
            /// It is also meant to check state for direct bonds and may not work as expected for virtual
            /// bonds.
            pub(crate) fn inspect_bond_state(
                stash: &T::AccountId,
            ) -> Result<LedgerIntegrityState, Error<T>> {
                let lock = asset::staked::<T>(&stash);
                let controller = <Bonded<T>>::get(stash)
                    .ok_or_else(|| {
                        if lock == Zero::zero() {
                            Error::<T>::NotStash
                        } else {
                            Error::<T>::BadState
                        }
                    })?;
                match Ledger::<T>::get(controller) {
                    Some(ledger) => {
                        if ledger.stash != *stash {
                            Ok(LedgerIntegrityState::Corrupted)
                        } else {
                            if lock != ledger.total {
                                Ok(LedgerIntegrityState::LockCorrupted)
                            } else {
                                Ok(LedgerIntegrityState::Ok)
                            }
                        }
                    }
                    None => Ok(LedgerIntegrityState::CorruptedKilled),
                }
            }
            /// The total balance that can be slashed from a stash account as of right now.
            pub fn slashable_balance_of(stash: &T::AccountId) -> BalanceOf<T> {
                Self::ledger(Stash(stash.clone())).map(|l| l.active).unwrap_or_default()
            }
            /// Internal impl of [`Self::slashable_balance_of`] that returns [`VoteWeight`].
            pub fn slashable_balance_of_vote_weight(
                stash: &T::AccountId,
                issuance: BalanceOf<T>,
            ) -> VoteWeight {
                T::CurrencyToVote::to_vote(Self::slashable_balance_of(stash), issuance)
            }
            /// Returns a closure around `slashable_balance_of_vote_weight` that can be passed around.
            ///
            /// This prevents call sites from repeatedly requesting `total_issuance` from backend. But it is
            /// important to be only used while the total issuance is not changing.
            pub fn weight_of_fn() -> Box<dyn Fn(&T::AccountId) -> VoteWeight> {
                let issuance = asset::total_issuance::<T>();
                Box::new(move |who: &T::AccountId| -> VoteWeight {
                    Self::slashable_balance_of_vote_weight(who, issuance)
                })
            }
            /// Same as `weight_of_fn`, but made for one time use.
            pub fn weight_of(who: &T::AccountId) -> VoteWeight {
                let issuance = asset::total_issuance::<T>();
                Self::slashable_balance_of_vote_weight(who, issuance)
            }
            pub(super) fn do_bond_extra(
                stash: &T::AccountId,
                additional: BalanceOf<T>,
            ) -> DispatchResult {
                let mut ledger = Self::ledger(StakingAccount::Stash(stash.clone()))?;
                let extra = if Self::is_virtual_staker(stash) {
                    additional
                } else {
                    additional
                        .min(
                            asset::stakeable_balance::<T>(stash)
                                .checked_sub(&ledger.total)
                                .ok_or(ArithmeticError::Overflow)?,
                        )
                };
                ledger.total = ledger
                    .total
                    .checked_add(&extra)
                    .ok_or(ArithmeticError::Overflow)?;
                ledger.active = ledger
                    .active
                    .checked_add(&extra)
                    .ok_or(ArithmeticError::Overflow)?;
                {
                    if !(ledger.active >= asset::existential_deposit::<T>()) {
                        {
                            return Err(Error::<T>::InsufficientBond.into());
                        };
                    }
                };
                ledger.update()?;
                if T::VoterList::contains(stash) {
                    let _ = T::VoterList::on_update(&stash, Self::weight_of(stash))
                        .defensive();
                }
                Self::deposit_event(Event::<T>::Bonded {
                    stash: stash.clone(),
                    amount: extra,
                });
                Ok(())
            }
            pub(super) fn do_withdraw_unbonded(
                controller: &T::AccountId,
                num_slashing_spans: u32,
            ) -> Result<Weight, DispatchError> {
                let mut ledger = Self::ledger(Controller(controller.clone()))?;
                let (stash, old_total) = (ledger.stash.clone(), ledger.total);
                if let Some(current_era) = Self::current_era() {
                    ledger = ledger.consolidate_unlocked(current_era);
                }
                let new_total = ledger.total;
                let ed = asset::existential_deposit::<T>();
                let used_weight = if ledger.unlocking.is_empty()
                    && (ledger.active < ed || ledger.active.is_zero())
                {
                    Self::kill_stash(&ledger.stash, num_slashing_spans)?;
                    T::WeightInfo::withdraw_unbonded_kill(num_slashing_spans)
                } else {
                    ledger.update()?;
                    T::WeightInfo::withdraw_unbonded_update(num_slashing_spans)
                };
                if new_total < old_total {
                    let value = old_total.defensive_saturating_sub(new_total);
                    Self::deposit_event(Event::<T>::Withdrawn {
                        stash,
                        amount: value,
                    });
                    T::EventListeners::on_withdraw(controller, value);
                }
                Ok(used_weight)
            }
            pub(super) fn do_payout_stakers(
                validator_stash: T::AccountId,
                era: EraIndex,
            ) -> DispatchResultWithPostInfo {
                let controller = Self::bonded(&validator_stash)
                    .ok_or_else(|| {
                        Error::<T>::NotStash
                            .with_weight(T::WeightInfo::payout_stakers_alive_staked(0))
                    })?;
                let ledger = Self::ledger(StakingAccount::Controller(controller))?;
                let page = EraInfo::<
                    T,
                >::get_next_claimable_page(era, &validator_stash, &ledger)
                    .ok_or_else(|| {
                        Error::<T>::AlreadyClaimed
                            .with_weight(T::WeightInfo::payout_stakers_alive_staked(0))
                    })?;
                Self::do_payout_stakers_by_page(validator_stash, era, page)
            }
            pub(super) fn do_payout_stakers_by_page(
                validator_stash: T::AccountId,
                era: EraIndex,
                page: Page,
            ) -> DispatchResultWithPostInfo {
                let current_era = CurrentEra::<T>::get()
                    .ok_or_else(|| {
                        Error::<T>::InvalidEraToReward
                            .with_weight(T::WeightInfo::payout_stakers_alive_staked(0))
                    })?;
                let history_depth = T::HistoryDepth::get();
                {
                    if !(era <= current_era
                        && era >= current_era.saturating_sub(history_depth))
                    {
                        {
                            return Err(
                                Error::<T>::InvalidEraToReward
                                    .with_weight(T::WeightInfo::payout_stakers_alive_staked(0))
                                    .into(),
                            );
                        };
                    }
                };
                {
                    if !(page < EraInfo::<T>::get_page_count(era, &validator_stash)) {
                        {
                            return Err(
                                Error::<T>::InvalidPage
                                    .with_weight(T::WeightInfo::payout_stakers_alive_staked(0))
                                    .into(),
                            );
                        };
                    }
                };
                let era_payout = <ErasValidatorReward<T>>::get(&era)
                    .ok_or_else(|| {
                        Error::<T>::InvalidEraToReward
                            .with_weight(T::WeightInfo::payout_stakers_alive_staked(0))
                    })?;
                let account = StakingAccount::Stash(validator_stash.clone());
                let mut ledger = Self::ledger(account.clone())
                    .or_else(|_| {
                        if StakingLedger::<T>::is_bonded(account) {
                            Err(Error::<T>::NotController.into())
                        } else {
                            Err(
                                Error::<T>::NotStash
                                    .with_weight(T::WeightInfo::payout_stakers_alive_staked(0)),
                            )
                        }
                    })?;
                ledger
                    .legacy_claimed_rewards
                    .retain(|&x| x >= current_era.saturating_sub(history_depth));
                ledger.clone().update()?;
                let stash = ledger.stash.clone();
                if EraInfo::<
                    T,
                >::is_rewards_claimed_with_legacy_fallback(era, &ledger, &stash, page) {
                    return Err(
                        Error::<T>::AlreadyClaimed
                            .with_weight(T::WeightInfo::payout_stakers_alive_staked(0)),
                    )
                } else {
                    EraInfo::<T>::set_rewards_as_claimed(era, &stash, page);
                }
                let exposure = EraInfo::<T>::get_paged_exposure(era, &stash, page)
                    .ok_or_else(|| {
                        Error::<T>::InvalidEraToReward
                            .with_weight(T::WeightInfo::payout_stakers_alive_staked(0))
                    })?;
                let era_reward_points = <ErasRewardPoints<T>>::get(&era);
                let total_reward_points = era_reward_points.total;
                let validator_reward_points = era_reward_points
                    .individual
                    .get(&stash)
                    .copied()
                    .unwrap_or_else(Zero::zero);
                if validator_reward_points.is_zero() {
                    return Ok(
                        Some(T::WeightInfo::payout_stakers_alive_staked(0)).into(),
                    );
                }
                let validator_total_reward_part = Perbill::from_rational(
                    validator_reward_points,
                    total_reward_points,
                );
                let validator_total_payout = validator_total_reward_part * era_payout;
                let validator_commission = EraInfo::<
                    T,
                >::get_validator_commission(era, &ledger.stash);
                let validator_total_commission_payout = validator_commission
                    * validator_total_payout;
                let validator_leftover_payout = validator_total_payout
                    .defensive_saturating_sub(validator_total_commission_payout);
                let validator_exposure_part = Perbill::from_rational(
                    exposure.own(),
                    exposure.total(),
                );
                let validator_staking_payout = validator_exposure_part
                    * validator_leftover_payout;
                let page_stake_part = Perbill::from_rational(
                    exposure.page_total(),
                    exposure.total(),
                );
                let validator_commission_payout = page_stake_part
                    * validator_total_commission_payout;
                Self::deposit_event(Event::<T>::PayoutStarted {
                    era_index: era,
                    validator_stash: stash.clone(),
                });
                let mut total_imbalance = PositiveImbalanceOf::<T>::zero();
                if let Some((imbalance, dest)) = Self::make_payout(
                    &stash,
                    validator_staking_payout + validator_commission_payout,
                ) {
                    Self::deposit_event(Event::<T>::Rewarded {
                        stash,
                        dest,
                        amount: imbalance.peek(),
                    });
                    total_imbalance.subsume(imbalance);
                }
                let mut nominator_payout_count: u32 = 0;
                for nominator in exposure.others().iter() {
                    let nominator_exposure_part = Perbill::from_rational(
                        nominator.value,
                        exposure.total(),
                    );
                    let nominator_reward: BalanceOf<T> = nominator_exposure_part
                        * validator_leftover_payout;
                    if let Some((imbalance, dest)) = Self::make_payout(
                        &nominator.who,
                        nominator_reward,
                    ) {
                        nominator_payout_count += 1;
                        let e = Event::<T>::Rewarded {
                            stash: nominator.who.clone(),
                            dest,
                            amount: imbalance.peek(),
                        };
                        Self::deposit_event(e);
                        total_imbalance.subsume(imbalance);
                    }
                }
                T::Reward::on_unbalanced(total_imbalance);
                if true {
                    if !(nominator_payout_count <= T::MaxExposurePageSize::get()) {
                        ::core::panicking::panic(
                            "assertion failed: nominator_payout_count <= T::MaxExposurePageSize::get()",
                        )
                    }
                }
                Ok(
                    Some(
                            T::WeightInfo::payout_stakers_alive_staked(
                                nominator_payout_count,
                            ),
                        )
                        .into(),
                )
            }
            /// Chill a stash account.
            pub(crate) fn chill_stash(stash: &T::AccountId) {
                let chilled_as_validator = Self::do_remove_validator(stash);
                let chilled_as_nominator = Self::do_remove_nominator(stash);
                if chilled_as_validator || chilled_as_nominator {
                    Self::deposit_event(Event::<T>::Chilled {
                        stash: stash.clone(),
                    });
                }
            }
            /// Actually make a payment to a staker. This uses the currency's reward function
            /// to pay the right payee for the given staker account.
            fn make_payout(
                stash: &T::AccountId,
                amount: BalanceOf<T>,
            ) -> Option<(PositiveImbalanceOf<T>, RewardDestination<T::AccountId>)> {
                if amount.is_zero() {
                    return None;
                }
                let dest = Self::payee(StakingAccount::Stash(stash.clone()))?;
                let maybe_imbalance = match dest {
                    RewardDestination::Stash => asset::mint_existing::<T>(stash, amount),
                    RewardDestination::Staked => {
                        Self::ledger(Stash(stash.clone()))
                            .and_then(|mut ledger| {
                                ledger.active += amount;
                                ledger.total += amount;
                                let r = asset::mint_existing::<T>(stash, amount);
                                let _ = ledger
                                    .update()
                                    .defensive_proof(
                                        "ledger fetched from storage, so it exists; qed.",
                                    );
                                Ok(r)
                            })
                            .unwrap_or_default()
                    }
                    RewardDestination::Account(ref dest_account) => {
                        Some(asset::mint_creating::<T>(&dest_account, amount))
                    }
                    RewardDestination::None => None,
                    #[allow(deprecated)]
                    RewardDestination::Controller => {
                        Self::bonded(stash)
                            .map(|controller| {
                                {
                                    let lvl = ::log::Level::Error;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            format_args!(
                                                "{0}: {1:?}",
                                                ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                                                "Paying out controller as reward destination which is deprecated and should be migrated.",
                                            ),
                                            lvl,
                                            &(
                                                "runtime::defensive",
                                                "pallet_staking::pallet::impls",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                };
                                if true {
                                    if !false {
                                        {
                                            ::core::panicking::panic_fmt(
                                                format_args!(
                                                    "{0}: {1:?}",
                                                    ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                                    "Paying out controller as reward destination which is deprecated and should be migrated.",
                                                ),
                                            );
                                        }
                                    }
                                }
                                asset::mint_creating::<T>(&controller, amount)
                            })
                    }
                };
                maybe_imbalance.map(|imbalance| (imbalance, dest))
            }
            /// Plan a new session potentially trigger a new era.
            fn new_session(
                session_index: SessionIndex,
                is_genesis: bool,
            ) -> Option<BoundedVec<T::AccountId, MaxWinnersOf<T>>> {
                if let Some(current_era) = Self::current_era() {
                    let current_era_start_session_index = Self::eras_start_session_index(
                            current_era,
                        )
                        .unwrap_or_else(|| {
                            frame_support::print(
                                "Error: start_session_index must be set for current_era",
                            );
                            0
                        });
                    let era_length = session_index
                        .saturating_sub(current_era_start_session_index);
                    match ForceEra::<T>::get() {
                        Forcing::ForceNew => {}
                        Forcing::ForceAlways => {}
                        Forcing::NotForcing if era_length
                            >= T::SessionsPerEra::get() => {}
                        _ => return None,
                    }
                    let maybe_new_era_validators = Self::try_trigger_new_era(
                        session_index,
                        is_genesis,
                    );
                    if maybe_new_era_validators.is_some()
                        && match ForceEra::<T>::get() {
                            Forcing::ForceNew => true,
                            _ => false,
                        }
                    {
                        Self::set_force_era(Forcing::NotForcing);
                    }
                    maybe_new_era_validators
                } else {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "[{0:?}] 💸 Starting the first era.",
                                    <frame_system::Pallet<T>>::block_number(),
                                ),
                                lvl,
                                &(
                                    crate::LOG_TARGET,
                                    "pallet_staking::pallet::impls",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    Self::try_trigger_new_era(session_index, is_genesis)
                }
            }
            /// Start a session potentially starting an era.
            fn start_session(start_session: SessionIndex) {
                let next_active_era = Self::active_era()
                    .map(|e| e.index + 1)
                    .unwrap_or(0);
                if let Some(next_active_era_start_session_index) = Self::eras_start_session_index(
                    next_active_era,
                ) {
                    if next_active_era_start_session_index == start_session {
                        Self::start_era(start_session);
                    } else if next_active_era_start_session_index < start_session {
                        frame_support::print(
                            "Warning: A session appears to have been skipped.",
                        );
                        Self::start_era(start_session);
                    }
                }
                for index in <DisabledValidators<T>>::get() {
                    T::SessionInterface::disable_validator(index);
                }
            }
            /// End a session potentially ending an era.
            fn end_session(session_index: SessionIndex) {
                if let Some(active_era) = Self::active_era() {
                    if let Some(next_active_era_start_session_index) = Self::eras_start_session_index(
                        active_era.index + 1,
                    ) {
                        if next_active_era_start_session_index == session_index + 1 {
                            Self::end_era(active_era, session_index);
                        }
                    }
                }
            }
            /// Start a new era. It does:
            /// * Increment `active_era.index`,
            /// * reset `active_era.start`,
            /// * update `BondedEras` and apply slashes.
            fn start_era(start_session: SessionIndex) {
                let active_era = ActiveEra::<
                    T,
                >::mutate(|active_era| {
                    let new_index = active_era
                        .as_ref()
                        .map(|info| info.index + 1)
                        .unwrap_or(0);
                    *active_era = Some(ActiveEraInfo {
                        index: new_index,
                        start: None,
                    });
                    new_index
                });
                let bonding_duration = T::BondingDuration::get();
                BondedEras::<
                    T,
                >::mutate(|bonded| {
                    bonded.push((active_era, start_session));
                    if active_era > bonding_duration {
                        let first_kept = active_era
                            .defensive_saturating_sub(bonding_duration);
                        let n_to_prune = bonded
                            .iter()
                            .take_while(|&&(era_idx, _)| era_idx < first_kept)
                            .count();
                        for (pruned_era, _) in bonded.drain(..n_to_prune) {
                            slashing::clear_era_metadata::<T>(pruned_era);
                        }
                        if let Some(&(_, first_session)) = bonded.first() {
                            T::SessionInterface::prune_historical_up_to(first_session);
                        }
                    }
                });
                Self::apply_unapplied_slashes(active_era);
            }
            /// Compute payout for era.
            fn end_era(active_era: ActiveEraInfo, _session_index: SessionIndex) {
                if let Some(active_era_start) = active_era.start {
                    let now_as_millis_u64 = T::UnixTime::now()
                        .as_millis()
                        .saturated_into::<u64>();
                    let era_duration = (now_as_millis_u64
                        .defensive_saturating_sub(active_era_start))
                        .saturated_into::<u64>();
                    let staked = Self::eras_total_stake(&active_era.index);
                    let issuance = asset::total_issuance::<T>();
                    let (validator_payout, remainder) = T::EraPayout::era_payout(
                        staked,
                        issuance,
                        era_duration,
                    );
                    let total_payout = validator_payout.saturating_add(remainder);
                    let max_staked_rewards = MaxStakedRewards::<T>::get()
                        .unwrap_or(Percent::from_percent(100));
                    let validator_payout = validator_payout
                        .min(max_staked_rewards * total_payout);
                    let remainder = total_payout.saturating_sub(validator_payout);
                    Self::deposit_event(Event::<T>::EraPaid {
                        era_index: active_era.index,
                        validator_payout,
                        remainder,
                    });
                    <ErasValidatorReward<
                        T,
                    >>::insert(&active_era.index, validator_payout);
                    T::RewardRemainder::on_unbalanced(asset::issue::<T>(remainder));
                    <DisabledValidators<T>>::kill();
                }
            }
            /// Plan a new era.
            ///
            /// * Bump the current era storage (which holds the latest planned era).
            /// * Store start session index for the new planned era.
            /// * Clean old era information.
            /// * Store staking information for the new planned era
            ///
            /// Returns the new validator set.
            pub fn trigger_new_era(
                start_session_index: SessionIndex,
                exposures: BoundedVec<
                    (T::AccountId, Exposure<T::AccountId, BalanceOf<T>>),
                    MaxWinnersOf<T>,
                >,
            ) -> BoundedVec<T::AccountId, MaxWinnersOf<T>> {
                let new_planned_era = CurrentEra::<
                    T,
                >::mutate(|s| {
                    *s = Some(s.map(|s| s + 1).unwrap_or(0));
                    s.unwrap()
                });
                ErasStartSessionIndex::<
                    T,
                >::insert(&new_planned_era, &start_session_index);
                if let Some(old_era) = new_planned_era
                    .checked_sub(T::HistoryDepth::get() + 1)
                {
                    Self::clear_era_information(old_era);
                }
                Self::store_stakers_info(exposures, new_planned_era)
            }
            /// Potentially plan a new era.
            ///
            /// Get election result from `T::ElectionProvider`.
            /// In case election result has more than [`MinimumValidatorCount`] validator trigger a new era.
            ///
            /// In case a new era is planned, the new validator set is returned.
            pub(crate) fn try_trigger_new_era(
                start_session_index: SessionIndex,
                is_genesis: bool,
            ) -> Option<BoundedVec<T::AccountId, MaxWinnersOf<T>>> {
                let election_result: BoundedVec<_, MaxWinnersOf<T>> = if is_genesis {
                    let result = <T::GenesisElectionProvider>::elect()
                        .map_err(|e| {
                            {
                                let lvl = ::log::Level::Warn;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        format_args!(
                                            "[{0:?}] 💸 genesis election provider failed due to {1:?}",
                                            <frame_system::Pallet<T>>::block_number(),
                                            e,
                                        ),
                                        lvl,
                                        &(
                                            crate::LOG_TARGET,
                                            "pallet_staking::pallet::impls",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            };
                            Self::deposit_event(Event::StakingElectionFailed);
                        });
                    result.ok()?.into_inner().try_into().defensive_unwrap_or_default()
                } else {
                    let result = <T::ElectionProvider>::elect()
                        .map_err(|e| {
                            {
                                let lvl = ::log::Level::Warn;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        format_args!(
                                            "[{0:?}] 💸 election provider failed due to {1:?}",
                                            <frame_system::Pallet<T>>::block_number(),
                                            e,
                                        ),
                                        lvl,
                                        &(
                                            crate::LOG_TARGET,
                                            "pallet_staking::pallet::impls",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            };
                            Self::deposit_event(Event::StakingElectionFailed);
                        });
                    result.ok()?
                };
                let exposures = Self::collect_exposures(election_result);
                if (exposures.len() as u32) < Self::minimum_validator_count().max(1) {
                    match CurrentEra::<T>::get() {
                        Some(current_era) if current_era > 0 => {
                            let lvl = ::log::Level::Warn;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "[{0:?}] 💸 chain does not have enough staking candidates to operate for era {1:?} ({2} elected, minimum is {3})",
                                        <frame_system::Pallet<T>>::block_number(),
                                        CurrentEra::<T>::get().unwrap_or(0),
                                        exposures.len(),
                                        Self::minimum_validator_count(),
                                    ),
                                    lvl,
                                    &(
                                        crate::LOG_TARGET,
                                        "pallet_staking::pallet::impls",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                        None => {
                            CurrentEra::<T>::put(0);
                            ErasStartSessionIndex::<T>::insert(&0, &start_session_index);
                        }
                        _ => {}
                    }
                    Self::deposit_event(Event::StakingElectionFailed);
                    return None;
                }
                Self::deposit_event(Event::StakersElected);
                Some(Self::trigger_new_era(start_session_index, exposures))
            }
            /// Process the output of the election.
            ///
            /// Store staking information for the new planned era
            pub fn store_stakers_info(
                exposures: BoundedVec<
                    (T::AccountId, Exposure<T::AccountId, BalanceOf<T>>),
                    MaxWinnersOf<T>,
                >,
                new_planned_era: EraIndex,
            ) -> BoundedVec<T::AccountId, MaxWinnersOf<T>> {
                let mut total_stake: BalanceOf<T> = Zero::zero();
                let mut elected_stashes = Vec::with_capacity(exposures.len());
                exposures
                    .into_iter()
                    .for_each(|(stash, exposure)| {
                        elected_stashes.push(stash.clone());
                        total_stake = total_stake.saturating_add(exposure.total);
                        EraInfo::<T>::set_exposure(new_planned_era, &stash, exposure);
                    });
                let elected_stashes: BoundedVec<_, MaxWinnersOf<T>> = elected_stashes
                    .try_into()
                    .expect(
                        "elected_stashes.len() always equal to exposures.len(); qed",
                    );
                EraInfo::<T>::set_total_stake(new_planned_era, total_stake);
                for stash in &elected_stashes {
                    let pref = Self::validators(stash);
                    <ErasValidatorPrefs<T>>::insert(&new_planned_era, stash, pref);
                }
                if new_planned_era > 0 {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "[{0:?}] 💸 new validator set of size {1:?} has been processed for era {2:?}",
                                    <frame_system::Pallet<T>>::block_number(),
                                    elected_stashes.len(),
                                    new_planned_era,
                                ),
                                lvl,
                                &(
                                    crate::LOG_TARGET,
                                    "pallet_staking::pallet::impls",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                }
                elected_stashes
            }
            /// Consume a set of [`BoundedSupports`] from [`sp_npos_elections`] and collect them into a
            /// [`Exposure`].
            fn collect_exposures(
                supports: BoundedSupportsOf<T::ElectionProvider>,
            ) -> BoundedVec<
                (T::AccountId, Exposure<T::AccountId, BalanceOf<T>>),
                MaxWinnersOf<T>,
            > {
                let total_issuance = asset::total_issuance::<T>();
                let to_currency = |e: frame_election_provider_support::ExtendedBalance| {
                    T::CurrencyToVote::to_currency(e, total_issuance)
                };
                supports
                    .into_iter()
                    .map(|(validator, support)| {
                        let mut others = Vec::with_capacity(support.voters.len());
                        let mut own: BalanceOf<T> = Zero::zero();
                        let mut total: BalanceOf<T> = Zero::zero();
                        support
                            .voters
                            .into_iter()
                            .map(|(nominator, weight)| (nominator, to_currency(weight)))
                            .for_each(|(nominator, stake)| {
                                if nominator == validator {
                                    own = own.saturating_add(stake);
                                } else {
                                    others
                                        .push(IndividualExposure {
                                            who: nominator,
                                            value: stake,
                                        });
                                }
                                total = total.saturating_add(stake);
                            });
                        let exposure = Exposure { own, others, total };
                        (validator, exposure)
                    })
                    .try_collect()
                    .expect(
                        "we only map through support vector which cannot change the size; qed",
                    )
            }
            /// Remove all associated data of a stash account from the staking system.
            ///
            /// Assumes storage is upgraded before calling.
            ///
            /// This is called:
            /// - after a `withdraw_unbonded()` call that frees all of a stash's bonded balance.
            /// - through `reap_stash()` if the balance has fallen to zero (through slashing).
            pub(crate) fn kill_stash(
                stash: &T::AccountId,
                num_slashing_spans: u32,
            ) -> DispatchResult {
                slashing::clear_stash_metadata::<T>(&stash, num_slashing_spans)?;
                StakingLedger::<T>::kill(&stash)?;
                Self::do_remove_validator(&stash);
                Self::do_remove_nominator(&stash);
                frame_system::Pallet::<T>::dec_consumers(&stash);
                Ok(())
            }
            /// Clear all era information for given era.
            pub(crate) fn clear_era_information(era_index: EraIndex) {
                let mut cursor = <ErasStakers<
                    T,
                >>::clear_prefix(era_index, u32::MAX, None);
                if true {
                    if !cursor.maybe_cursor.is_none() {
                        ::core::panicking::panic(
                            "assertion failed: cursor.maybe_cursor.is_none()",
                        )
                    }
                }
                cursor = <ErasStakersClipped<
                    T,
                >>::clear_prefix(era_index, u32::MAX, None);
                if true {
                    if !cursor.maybe_cursor.is_none() {
                        ::core::panicking::panic(
                            "assertion failed: cursor.maybe_cursor.is_none()",
                        )
                    }
                }
                cursor = <ErasValidatorPrefs<
                    T,
                >>::clear_prefix(era_index, u32::MAX, None);
                if true {
                    if !cursor.maybe_cursor.is_none() {
                        ::core::panicking::panic(
                            "assertion failed: cursor.maybe_cursor.is_none()",
                        )
                    }
                }
                cursor = <ClaimedRewards<T>>::clear_prefix(era_index, u32::MAX, None);
                if true {
                    if !cursor.maybe_cursor.is_none() {
                        ::core::panicking::panic(
                            "assertion failed: cursor.maybe_cursor.is_none()",
                        )
                    }
                }
                cursor = <ErasStakersPaged<
                    T,
                >>::clear_prefix((era_index,), u32::MAX, None);
                if true {
                    if !cursor.maybe_cursor.is_none() {
                        ::core::panicking::panic(
                            "assertion failed: cursor.maybe_cursor.is_none()",
                        )
                    }
                }
                cursor = <ErasStakersOverview<
                    T,
                >>::clear_prefix(era_index, u32::MAX, None);
                if true {
                    if !cursor.maybe_cursor.is_none() {
                        ::core::panicking::panic(
                            "assertion failed: cursor.maybe_cursor.is_none()",
                        )
                    }
                }
                <ErasValidatorReward<T>>::remove(era_index);
                <ErasRewardPoints<T>>::remove(era_index);
                <ErasTotalStake<T>>::remove(era_index);
                ErasStartSessionIndex::<T>::remove(era_index);
            }
            /// Apply previously-unapplied slashes on the beginning of a new era, after a delay.
            fn apply_unapplied_slashes(active_era: EraIndex) {
                let era_slashes = UnappliedSlashes::<T>::take(&active_era);
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "[{0:?}] 💸 found {1} slashes scheduled to be executed in era {2:?}",
                                <frame_system::Pallet<T>>::block_number(),
                                era_slashes.len(),
                                active_era,
                            ),
                            lvl,
                            &(
                                crate::LOG_TARGET,
                                "pallet_staking::pallet::impls",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                };
                for slash in era_slashes {
                    let slash_era = active_era
                        .saturating_sub(T::SlashDeferDuration::get());
                    slashing::apply_slash::<T>(slash, slash_era);
                }
            }
            /// Add reward points to validators using their stash account ID.
            ///
            /// Validators are keyed by stash account ID and must be in the current elected set.
            ///
            /// For each element in the iterator the given number of points in u32 is added to the
            /// validator, thus duplicates are handled.
            ///
            /// At the end of the era each the total payout will be distributed among validator
            /// relatively to their points.
            ///
            /// COMPLEXITY: Complexity is `number_of_validator_to_reward x current_elected_len`.
            pub fn reward_by_ids(
                validators_points: impl IntoIterator<Item = (T::AccountId, u32)>,
            ) {
                if let Some(active_era) = Self::active_era() {
                    <ErasRewardPoints<
                        T,
                    >>::mutate(
                        active_era.index,
                        |era_rewards| {
                            for (validator, points) in validators_points.into_iter() {
                                *era_rewards.individual.entry(validator).or_default()
                                    += points;
                                era_rewards.total += points;
                            }
                        },
                    );
                }
            }
            /// Helper to set a new `ForceEra` mode.
            pub(crate) fn set_force_era(mode: Forcing) {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "[{0:?}] 💸 Setting force era mode {1:?}.",
                                <frame_system::Pallet<T>>::block_number(),
                                mode,
                            ),
                            lvl,
                            &(
                                crate::LOG_TARGET,
                                "pallet_staking::pallet::impls",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                };
                ForceEra::<T>::put(mode);
                Self::deposit_event(Event::<T>::ForceEra { mode });
            }
            /// Get all of the voters that are eligible for the npos election.
            ///
            /// `maybe_max_len` can imposes a cap on the number of voters returned;
            ///
            /// Sets `MinimumActiveStake` to the minimum active nominator stake in the returned set of
            /// nominators.
            ///
            /// This function is self-weighing as [`DispatchClass::Mandatory`].
            pub fn get_npos_voters(bounds: DataProviderBounds) -> Vec<VoterOf<Self>> {
                let mut voters_size_tracker: StaticTracker<Self> = StaticTracker::default();
                let final_predicted_len = {
                    let all_voter_count = T::VoterList::count();
                    bounds
                        .count
                        .unwrap_or(all_voter_count.into())
                        .min(all_voter_count.into())
                        .0
                };
                let mut all_voters = Vec::<
                    _,
                >::with_capacity(final_predicted_len as usize);
                let weight_of = Self::weight_of_fn();
                let mut voters_seen = 0u32;
                let mut validators_taken = 0u32;
                let mut nominators_taken = 0u32;
                let mut min_active_stake = u64::MAX;
                let mut sorted_voters = T::VoterList::iter();
                while all_voters.len() < final_predicted_len as usize
                    && voters_seen
                        < (NPOS_MAX_ITERATIONS_COEFFICIENT * final_predicted_len as u32)
                {
                    let voter = match sorted_voters.next() {
                        Some(voter) => {
                            voters_seen.saturating_inc();
                            voter
                        }
                        None => break,
                    };
                    let voter_weight = weight_of(&voter);
                    if voter_weight.is_zero() {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "[{0:?}] 💸 voter\'s active balance is 0. skip this voter.",
                                        <frame_system::Pallet<T>>::block_number(),
                                    ),
                                    lvl,
                                    &(
                                        crate::LOG_TARGET,
                                        "pallet_staking::pallet::impls",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        continue;
                    }
                    if let Some(Nominations { targets, .. }) = <Nominators<
                        T,
                    >>::get(&voter) {
                        if !targets.is_empty() {
                            let voter = (voter, voter_weight, targets);
                            if voters_size_tracker
                                .try_register_voter(&voter, &bounds)
                                .is_err()
                            {
                                Self::deposit_event(Event::<T>::SnapshotVotersSizeExceeded {
                                    size: voters_size_tracker.size as u32,
                                });
                                break;
                            }
                            all_voters.push(voter);
                            nominators_taken.saturating_inc();
                        } else {}
                        min_active_stake = if voter_weight < min_active_stake {
                            voter_weight
                        } else {
                            min_active_stake
                        };
                    } else if Validators::<T>::contains_key(&voter) {
                        let self_vote = (
                            voter.clone(),
                            voter_weight,
                            <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([voter.clone()]),
                                )
                                .try_into()
                                .expect(
                                    "`MaxVotesPerVoter` must be greater than or equal to 1",
                                ),
                        );
                        if voters_size_tracker
                            .try_register_voter(&self_vote, &bounds)
                            .is_err()
                        {
                            Self::deposit_event(Event::<T>::SnapshotVotersSizeExceeded {
                                size: voters_size_tracker.size as u32,
                            });
                            break;
                        }
                        all_voters.push(self_vote);
                        validators_taken.saturating_inc();
                    } else {
                        {
                            let lvl = ::log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "{0}: {1:?}: {2:?}",
                                        ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                                        "DEFENSIVE: invalid item in `VoterList`: {:?}, this nominator probably has too many nominations now",
                                        voter,
                                    ),
                                    lvl,
                                    &(
                                        "runtime::defensive",
                                        "pallet_staking::pallet::impls",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        if true {
                            if !false {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "{0}: {1:?}: {2:?}",
                                            ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                            "DEFENSIVE: invalid item in `VoterList`: {:?}, this nominator probably has too many nominations now",
                                            voter,
                                        ),
                                    );
                                }
                            }
                        }
                    }
                }
                if true {
                    if !(all_voters.capacity() == final_predicted_len as usize) {
                        ::core::panicking::panic(
                            "assertion failed: all_voters.capacity() == final_predicted_len as usize",
                        )
                    }
                }
                Self::register_weight(
                    T::WeightInfo::get_npos_voters(validators_taken, nominators_taken),
                );
                let min_active_stake: T::CurrencyBalance = if all_voters.is_empty() {
                    Zero::zero()
                } else {
                    min_active_stake.into()
                };
                MinimumActiveStake::<T>::put(min_active_stake);
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "[{0:?}] 💸 generated {1} npos voters, {2} from validators and {3} nominators",
                                <frame_system::Pallet<T>>::block_number(),
                                all_voters.len(),
                                validators_taken,
                                nominators_taken,
                            ),
                            lvl,
                            &(
                                crate::LOG_TARGET,
                                "pallet_staking::pallet::impls",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                };
                all_voters
            }
            /// Get the targets for an upcoming npos election.
            ///
            /// This function is self-weighing as [`DispatchClass::Mandatory`].
            pub fn get_npos_targets(bounds: DataProviderBounds) -> Vec<T::AccountId> {
                let mut targets_size_tracker: StaticTracker<Self> = StaticTracker::default();
                let final_predicted_len = {
                    let all_target_count = T::TargetList::count();
                    bounds
                        .count
                        .unwrap_or(all_target_count.into())
                        .min(all_target_count.into())
                        .0
                };
                let mut all_targets = Vec::<
                    T::AccountId,
                >::with_capacity(final_predicted_len as usize);
                let mut targets_seen = 0;
                let mut targets_iter = T::TargetList::iter();
                while all_targets.len() < final_predicted_len as usize
                    && targets_seen
                        < (NPOS_MAX_ITERATIONS_COEFFICIENT * final_predicted_len as u32)
                {
                    let target = match targets_iter.next() {
                        Some(target) => {
                            targets_seen.saturating_inc();
                            target
                        }
                        None => break,
                    };
                    if targets_size_tracker
                        .try_register_target(target.clone(), &bounds)
                        .is_err()
                    {
                        Self::deposit_event(Event::<T>::SnapshotTargetsSizeExceeded {
                            size: targets_size_tracker.size as u32,
                        });
                        break;
                    }
                    if Validators::<T>::contains_key(&target) {
                        all_targets.push(target);
                    }
                }
                Self::register_weight(
                    T::WeightInfo::get_npos_targets(all_targets.len() as u32),
                );
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "[{0:?}] 💸 generated {1} npos targets",
                                <frame_system::Pallet<T>>::block_number(),
                                all_targets.len(),
                            ),
                            lvl,
                            &(
                                crate::LOG_TARGET,
                                "pallet_staking::pallet::impls",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                };
                all_targets
            }
            /// This function will add a nominator to the `Nominators` storage map,
            /// and `VoterList`.
            ///
            /// If the nominator already exists, their nominations will be updated.
            ///
            /// NOTE: you must ALWAYS use this function to add nominator or update their targets. Any access
            /// to `Nominators` or `VoterList` outside of this function is almost certainly
            /// wrong.
            pub fn do_add_nominator(who: &T::AccountId, nominations: Nominations<T>) {
                if !Nominators::<T>::contains_key(who) {
                    let _ = T::VoterList::on_insert(who.clone(), Self::weight_of(who))
                        .defensive_unwrap_or_default();
                }
                Nominators::<T>::insert(who, nominations);
                if true {
                    match (
                        &(Nominators::<T>::count() + Validators::<T>::count()),
                        &T::VoterList::count(),
                    ) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    };
                }
            }
            /// This function will remove a nominator from the `Nominators` storage map,
            /// and `VoterList`.
            ///
            /// Returns true if `who` was removed from `Nominators`, otherwise false.
            ///
            /// NOTE: you must ALWAYS use this function to remove a nominator from the system. Any access to
            /// `Nominators` or `VoterList` outside of this function is almost certainly
            /// wrong.
            pub fn do_remove_nominator(who: &T::AccountId) -> bool {
                let outcome = if Nominators::<T>::contains_key(who) {
                    Nominators::<T>::remove(who);
                    let _ = T::VoterList::on_remove(who).defensive();
                    true
                } else {
                    false
                };
                if true {
                    match (
                        &(Nominators::<T>::count() + Validators::<T>::count()),
                        &T::VoterList::count(),
                    ) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    };
                }
                outcome
            }
            /// This function will add a validator to the `Validators` storage map.
            ///
            /// If the validator already exists, their preferences will be updated.
            ///
            /// NOTE: you must ALWAYS use this function to add a validator to the system. Any access to
            /// `Validators` or `VoterList` outside of this function is almost certainly
            /// wrong.
            pub fn do_add_validator(who: &T::AccountId, prefs: ValidatorPrefs) {
                if !Validators::<T>::contains_key(who) {
                    let _ = T::VoterList::on_insert(who.clone(), Self::weight_of(who))
                        .defensive_unwrap_or_default();
                }
                Validators::<T>::insert(who, prefs);
                if true {
                    match (
                        &(Nominators::<T>::count() + Validators::<T>::count()),
                        &T::VoterList::count(),
                    ) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    };
                }
            }
            /// This function will remove a validator from the `Validators` storage map.
            ///
            /// Returns true if `who` was removed from `Validators`, otherwise false.
            ///
            /// NOTE: you must ALWAYS use this function to remove a validator from the system. Any access to
            /// `Validators` or `VoterList` outside of this function is almost certainly
            /// wrong.
            pub fn do_remove_validator(who: &T::AccountId) -> bool {
                let outcome = if Validators::<T>::contains_key(who) {
                    Validators::<T>::remove(who);
                    let _ = T::VoterList::on_remove(who).defensive();
                    true
                } else {
                    false
                };
                if true {
                    match (
                        &(Nominators::<T>::count() + Validators::<T>::count()),
                        &T::VoterList::count(),
                    ) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    };
                }
                outcome
            }
            /// Register some amount of weight directly with the system pallet.
            ///
            /// This is always mandatory weight.
            fn register_weight(weight: Weight) {
                <frame_system::Pallet<
                    T,
                >>::register_extra_weight_unchecked(weight, DispatchClass::Mandatory);
            }
            /// Returns full exposure of a validator for a given era.
            ///
            /// History note: This used to be a getter for old storage item `ErasStakers` deprecated in v14.
            /// Since this function is used in the codebase at various places, we kept it as a custom getter
            /// that takes care of getting the full exposure of the validator in a backward compatible way.
            pub fn eras_stakers(
                era: EraIndex,
                account: &T::AccountId,
            ) -> Exposure<T::AccountId, BalanceOf<T>> {
                EraInfo::<T>::get_full_exposure(era, account)
            }
        }
        impl<T: Config> Pallet<T> {
            /// Returns the current nominations quota for nominators.
            ///
            /// Used by the runtime API.
            pub fn api_nominations_quota(balance: BalanceOf<T>) -> u32 {
                T::NominationsQuota::get_quota(balance)
            }
            pub fn api_eras_stakers(
                era: EraIndex,
                account: T::AccountId,
            ) -> Exposure<T::AccountId, BalanceOf<T>> {
                Self::eras_stakers(era, &account)
            }
            pub fn api_eras_stakers_page_count(
                era: EraIndex,
                account: T::AccountId,
            ) -> Page {
                EraInfo::<T>::get_page_count(era, &account)
            }
            pub fn api_pending_rewards(era: EraIndex, account: T::AccountId) -> bool {
                EraInfo::<T>::pending_rewards(era, &account)
            }
        }
        impl<T: Config> ElectionDataProvider for Pallet<T> {
            type AccountId = T::AccountId;
            type BlockNumber = BlockNumberFor<T>;
            type MaxVotesPerVoter = MaxNominationsOf<T>;
            fn desired_targets() -> data_provider::Result<u32> {
                Self::register_weight(T::DbWeight::get().reads(1));
                Ok(Self::validator_count())
            }
            fn electing_voters(
                bounds: DataProviderBounds,
            ) -> data_provider::Result<Vec<VoterOf<Self>>> {
                let voters = Self::get_npos_voters(bounds);
                if true {
                    if !!bounds
                        .exhausted(
                            SizeBound(voters.encoded_size() as u32).into(),
                            CountBound(voters.len() as u32).into(),
                        )
                    {
                        ::core::panicking::panic(
                            "assertion failed: !bounds.exhausted(SizeBound(voters.encoded_size() as u32).into(),\n        CountBound(voters.len() as u32).into())",
                        )
                    }
                }
                Ok(voters)
            }
            fn electable_targets(
                bounds: DataProviderBounds,
            ) -> data_provider::Result<Vec<T::AccountId>> {
                let targets = Self::get_npos_targets(bounds);
                if bounds
                    .exhausted(None, CountBound(T::TargetList::count() as u32).into())
                {
                    return Err("Target snapshot too big");
                }
                if true {
                    if !!bounds
                        .exhausted(
                            SizeBound(targets.encoded_size() as u32).into(),
                            CountBound(targets.len() as u32).into(),
                        )
                    {
                        ::core::panicking::panic(
                            "assertion failed: !bounds.exhausted(SizeBound(targets.encoded_size() as u32).into(),\n        CountBound(targets.len() as u32).into())",
                        )
                    }
                }
                Ok(targets)
            }
            fn next_election_prediction(now: BlockNumberFor<T>) -> BlockNumberFor<T> {
                let current_era = Self::current_era().unwrap_or(0);
                let current_session = Self::current_planned_session();
                let current_era_start_session_index = Self::eras_start_session_index(
                        current_era,
                    )
                    .unwrap_or(0);
                let era_progress = current_session
                    .saturating_sub(current_era_start_session_index)
                    .min(T::SessionsPerEra::get());
                let until_this_session_end = T::NextNewSession::estimate_next_new_session(
                        now,
                    )
                    .0
                    .unwrap_or_default()
                    .saturating_sub(now);
                let session_length = T::NextNewSession::average_session_length();
                let sessions_left: BlockNumberFor<T> = match ForceEra::<T>::get() {
                    Forcing::ForceNone => Bounded::max_value(),
                    Forcing::ForceNew | Forcing::ForceAlways => Zero::zero(),
                    Forcing::NotForcing if era_progress >= T::SessionsPerEra::get() => {
                        Zero::zero()
                    }
                    Forcing::NotForcing => {
                        T::SessionsPerEra::get()
                            .saturating_sub(era_progress)
                            .saturating_sub(1)
                            .into()
                    }
                };
                now.saturating_add(
                    until_this_session_end
                        .saturating_add(sessions_left.saturating_mul(session_length)),
                )
            }
        }
        /// In this implementation `new_session(session)` must be called before `end_session(session-1)`
        /// i.e. the new session must be planned before the ending of the previous session.
        ///
        /// Once the first new_session is planned, all session must start and then end in order, though
        /// some session can lag in between the newest session planned and the latest session started.
        impl<T: Config> pallet_session::SessionManager<T::AccountId> for Pallet<T> {
            fn new_session(new_index: SessionIndex) -> Option<Vec<T::AccountId>> {
                {
                    let lvl = ::log::Level::Trace;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "[{0:?}] 💸 planning new session {1}",
                                <frame_system::Pallet<T>>::block_number(),
                                new_index,
                            ),
                            lvl,
                            &(
                                crate::LOG_TARGET,
                                "pallet_staking::pallet::impls",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                };
                CurrentPlannedSession::<T>::put(new_index);
                Self::new_session(new_index, false).map(|v| v.into_inner())
            }
            fn new_session_genesis(
                new_index: SessionIndex,
            ) -> Option<Vec<T::AccountId>> {
                {
                    let lvl = ::log::Level::Trace;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "[{0:?}] 💸 planning new session {1} at genesis",
                                <frame_system::Pallet<T>>::block_number(),
                                new_index,
                            ),
                            lvl,
                            &(
                                crate::LOG_TARGET,
                                "pallet_staking::pallet::impls",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                };
                CurrentPlannedSession::<T>::put(new_index);
                Self::new_session(new_index, true).map(|v| v.into_inner())
            }
            fn start_session(start_index: SessionIndex) {
                {
                    let lvl = ::log::Level::Trace;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "[{0:?}] 💸 starting session {1}",
                                <frame_system::Pallet<T>>::block_number(),
                                start_index,
                            ),
                            lvl,
                            &(
                                crate::LOG_TARGET,
                                "pallet_staking::pallet::impls",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                };
                Self::start_session(start_index)
            }
            fn end_session(end_index: SessionIndex) {
                {
                    let lvl = ::log::Level::Trace;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "[{0:?}] 💸 ending session {1}",
                                <frame_system::Pallet<T>>::block_number(),
                                end_index,
                            ),
                            lvl,
                            &(
                                crate::LOG_TARGET,
                                "pallet_staking::pallet::impls",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                };
                Self::end_session(end_index)
            }
        }
        impl<
            T: Config,
        > historical::SessionManager<T::AccountId, Exposure<T::AccountId, BalanceOf<T>>>
        for Pallet<T> {
            fn new_session(
                new_index: SessionIndex,
            ) -> Option<Vec<(T::AccountId, Exposure<T::AccountId, BalanceOf<T>>)>> {
                <Self as pallet_session::SessionManager<_>>::new_session(new_index)
                    .map(|validators| {
                        let current_era = Self::current_era().unwrap_or(0);
                        validators
                            .into_iter()
                            .map(|v| {
                                let exposure = Self::eras_stakers(current_era, &v);
                                (v, exposure)
                            })
                            .collect()
                    })
            }
            fn new_session_genesis(
                new_index: SessionIndex,
            ) -> Option<Vec<(T::AccountId, Exposure<T::AccountId, BalanceOf<T>>)>> {
                <Self as pallet_session::SessionManager<
                    _,
                >>::new_session_genesis(new_index)
                    .map(|validators| {
                        let current_era = Self::current_era().unwrap_or(0);
                        validators
                            .into_iter()
                            .map(|v| {
                                let exposure = Self::eras_stakers(current_era, &v);
                                (v, exposure)
                            })
                            .collect()
                    })
            }
            fn start_session(start_index: SessionIndex) {
                <Self as pallet_session::SessionManager<_>>::start_session(start_index)
            }
            fn end_session(end_index: SessionIndex) {
                <Self as pallet_session::SessionManager<_>>::end_session(end_index)
            }
        }
        /// Add reward points to block authors:
        /// * 20 points to the block producer for producing a (non-uncle) block,
        impl<T> pallet_authorship::EventHandler<T::AccountId, BlockNumberFor<T>>
        for Pallet<T>
        where
            T: Config + pallet_authorship::Config + pallet_session::Config,
        {
            fn note_author(author: T::AccountId) {
                Self::reward_by_ids(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([(author, 20)]),
                    ),
                )
            }
        }
        /// This is intended to be used with `FilterHistoricalOffences`.
        impl<
            T: Config,
        > OnOffenceHandler<
            T::AccountId,
            pallet_session::historical::IdentificationTuple<T>,
            Weight,
        > for Pallet<T>
        where
            T: pallet_session::Config<
                ValidatorId = <T as frame_system::Config>::AccountId,
            >,
            T: pallet_session::historical::Config<
                FullIdentification = Exposure<
                    <T as frame_system::Config>::AccountId,
                    BalanceOf<T>,
                >,
                FullIdentificationOf = ExposureOf<T>,
            >,
            T::SessionHandler: pallet_session::SessionHandler<
                <T as frame_system::Config>::AccountId,
            >,
            T::SessionManager: pallet_session::SessionManager<
                <T as frame_system::Config>::AccountId,
            >,
            T::ValidatorIdOf: Convert<
                <T as frame_system::Config>::AccountId,
                Option<<T as frame_system::Config>::AccountId>,
            >,
        {
            fn on_offence(
                offenders: &[OffenceDetails<
                    T::AccountId,
                    pallet_session::historical::IdentificationTuple<T>,
                >],
                slash_fraction: &[Perbill],
                slash_session: SessionIndex,
            ) -> Weight {
                let reward_proportion = SlashRewardFraction::<T>::get();
                let mut consumed_weight = Weight::from_parts(0, 0);
                let mut add_db_reads_writes = |reads, writes| {
                    consumed_weight += T::DbWeight::get().reads_writes(reads, writes);
                };
                let active_era = {
                    let active_era = Self::active_era();
                    add_db_reads_writes(1, 0);
                    if active_era.is_none() {
                        return consumed_weight;
                    }
                    active_era.expect("value checked not to be `None`; qed").index
                };
                let active_era_start_session_index = Self::eras_start_session_index(
                        active_era,
                    )
                    .unwrap_or_else(|| {
                        frame_support::print(
                            "Error: start_session_index must be set for current_era",
                        );
                        0
                    });
                add_db_reads_writes(1, 0);
                let window_start = active_era.saturating_sub(T::BondingDuration::get());
                let slash_era = if slash_session >= active_era_start_session_index {
                    active_era
                } else {
                    let eras = BondedEras::<T>::get();
                    add_db_reads_writes(1, 0);
                    match eras.iter().rev().find(|&(_, sesh)| sesh <= &slash_session) {
                        Some((slash_era, _)) => *slash_era,
                        None => return consumed_weight,
                    }
                };
                add_db_reads_writes(1, 1);
                let slash_defer_duration = T::SlashDeferDuration::get();
                let invulnerables = Self::invulnerables();
                add_db_reads_writes(1, 0);
                for (details, slash_fraction) in offenders.iter().zip(slash_fraction) {
                    let (stash, exposure) = &details.offender;
                    if invulnerables.contains(stash) {
                        continue;
                    }
                    let unapplied = slashing::compute_slash::<
                        T,
                    >(slashing::SlashParams {
                        stash,
                        slash: *slash_fraction,
                        exposure,
                        slash_era,
                        window_start,
                        now: active_era,
                        reward_proportion,
                    });
                    Self::deposit_event(Event::<T>::SlashReported {
                        validator: stash.clone(),
                        fraction: *slash_fraction,
                        slash_era,
                    });
                    if let Some(mut unapplied) = unapplied {
                        let nominators_len = unapplied.others.len() as u64;
                        let reporters_len = details.reporters.len() as u64;
                        {
                            let upper_bound = 1 + 2;
                            let rw = upper_bound + nominators_len * upper_bound;
                            add_db_reads_writes(rw, rw);
                        }
                        unapplied.reporters = details.reporters.clone();
                        if slash_defer_duration == 0 {
                            slashing::apply_slash::<T>(unapplied, slash_era);
                            {
                                let slash_cost = (6, 5);
                                let reward_cost = (2, 2);
                                add_db_reads_writes(
                                    (1 + nominators_len) * slash_cost.0
                                        + reward_cost.0 * reporters_len,
                                    (1 + nominators_len) * slash_cost.1
                                        + reward_cost.1 * reporters_len,
                                );
                            }
                        } else {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        format_args!(
                                            "[{0:?}] 💸 deferring slash of {1:?}% happened in {2:?} (reported in {3:?}) to {4:?}",
                                            <frame_system::Pallet<T>>::block_number(),
                                            slash_fraction,
                                            slash_era,
                                            active_era,
                                            slash_era + slash_defer_duration + 1,
                                        ),
                                        lvl,
                                        &(
                                            crate::LOG_TARGET,
                                            "pallet_staking::pallet::impls",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            };
                            UnappliedSlashes::<
                                T,
                            >::mutate(
                                slash_era
                                    .saturating_add(slash_defer_duration)
                                    .saturating_add(One::one()),
                                move |for_later| for_later.push(unapplied),
                            );
                            add_db_reads_writes(1, 1);
                        }
                    } else {
                        add_db_reads_writes(4, 5)
                    }
                }
                consumed_weight
            }
        }
        impl<T: Config> ScoreProvider<T::AccountId> for Pallet<T> {
            type Score = VoteWeight;
            fn score(who: &T::AccountId) -> Self::Score {
                Self::weight_of(who)
            }
        }
        /// A simple sorted list implementation that does not require any additional pallets. Note, this
        /// does not provide validators in sorted order. If you desire nominators in a sorted order take
        /// a look at [`pallet-bags-list`].
        pub struct UseValidatorsMap<T>(core::marker::PhantomData<T>);
        impl<T: Config> SortedListProvider<T::AccountId> for UseValidatorsMap<T> {
            type Score = BalanceOf<T>;
            type Error = ();
            /// Returns iterator over voter list, which can have `take` called on it.
            fn iter() -> Box<dyn Iterator<Item = T::AccountId>> {
                Box::new(Validators::<T>::iter().map(|(v, _)| v))
            }
            fn iter_from(
                start: &T::AccountId,
            ) -> Result<Box<dyn Iterator<Item = T::AccountId>>, Self::Error> {
                if Validators::<T>::contains_key(start) {
                    let start_key = Validators::<T>::hashed_key_for(start);
                    Ok(Box::new(Validators::<T>::iter_from(start_key).map(|(n, _)| n)))
                } else {
                    Err(())
                }
            }
            fn count() -> u32 {
                Validators::<T>::count()
            }
            fn contains(id: &T::AccountId) -> bool {
                Validators::<T>::contains_key(id)
            }
            fn on_insert(
                _: T::AccountId,
                _weight: Self::Score,
            ) -> Result<(), Self::Error> {
                Ok(())
            }
            fn get_score(id: &T::AccountId) -> Result<Self::Score, Self::Error> {
                Ok(Pallet::<T>::weight_of(id).into())
            }
            fn on_update(
                _: &T::AccountId,
                _weight: Self::Score,
            ) -> Result<(), Self::Error> {
                Ok(())
            }
            fn on_remove(_: &T::AccountId) -> Result<(), Self::Error> {
                Ok(())
            }
            fn unsafe_regenerate(
                _: impl IntoIterator<Item = T::AccountId>,
                _: Box<dyn Fn(&T::AccountId) -> Self::Score>,
            ) -> u32 {
                0
            }
            fn unsafe_clear() {
                #[allow(deprecated)] Validators::<T>::remove_all();
            }
        }
        /// A simple voter list implementation that does not require any additional pallets. Note, this
        /// does not provided nominators in sorted ordered. If you desire nominators in a sorted order take
        /// a look at [`pallet-bags-list].
        pub struct UseNominatorsAndValidatorsMap<T>(core::marker::PhantomData<T>);
        impl<T: Config> SortedListProvider<T::AccountId>
        for UseNominatorsAndValidatorsMap<T> {
            type Error = ();
            type Score = VoteWeight;
            fn iter() -> Box<dyn Iterator<Item = T::AccountId>> {
                Box::new(
                    Validators::<T>::iter()
                        .map(|(v, _)| v)
                        .chain(Nominators::<T>::iter().map(|(n, _)| n)),
                )
            }
            fn iter_from(
                start: &T::AccountId,
            ) -> Result<Box<dyn Iterator<Item = T::AccountId>>, Self::Error> {
                if Validators::<T>::contains_key(start) {
                    let start_key = Validators::<T>::hashed_key_for(start);
                    Ok(
                        Box::new(
                            Validators::<T>::iter_from(start_key)
                                .map(|(n, _)| n)
                                .chain(Nominators::<T>::iter().map(|(x, _)| x)),
                        ),
                    )
                } else if Nominators::<T>::contains_key(start) {
                    let start_key = Nominators::<T>::hashed_key_for(start);
                    Ok(Box::new(Nominators::<T>::iter_from(start_key).map(|(n, _)| n)))
                } else {
                    Err(())
                }
            }
            fn count() -> u32 {
                Nominators::<T>::count().saturating_add(Validators::<T>::count())
            }
            fn contains(id: &T::AccountId) -> bool {
                Nominators::<T>::contains_key(id) || Validators::<T>::contains_key(id)
            }
            fn on_insert(
                _: T::AccountId,
                _weight: Self::Score,
            ) -> Result<(), Self::Error> {
                Ok(())
            }
            fn get_score(id: &T::AccountId) -> Result<Self::Score, Self::Error> {
                Ok(Pallet::<T>::weight_of(id))
            }
            fn on_update(
                _: &T::AccountId,
                _weight: Self::Score,
            ) -> Result<(), Self::Error> {
                Ok(())
            }
            fn on_remove(_: &T::AccountId) -> Result<(), Self::Error> {
                Ok(())
            }
            fn unsafe_regenerate(
                _: impl IntoIterator<Item = T::AccountId>,
                _: Box<dyn Fn(&T::AccountId) -> Self::Score>,
            ) -> u32 {
                0
            }
            fn unsafe_clear() {
                #[allow(deprecated)] Nominators::<T>::remove_all();
                #[allow(deprecated)] Validators::<T>::remove_all();
            }
        }
        impl<T: Config> StakingInterface for Pallet<T> {
            type AccountId = T::AccountId;
            type Balance = BalanceOf<T>;
            type CurrencyToVote = T::CurrencyToVote;
            fn minimum_nominator_bond() -> Self::Balance {
                MinNominatorBond::<T>::get()
            }
            fn minimum_validator_bond() -> Self::Balance {
                MinValidatorBond::<T>::get()
            }
            fn stash_by_ctrl(
                controller: &Self::AccountId,
            ) -> Result<Self::AccountId, DispatchError> {
                Self::ledger(Controller(controller.clone()))
                    .map(|l| l.stash)
                    .map_err(|e| e.into())
            }
            fn bonding_duration() -> EraIndex {
                T::BondingDuration::get()
            }
            fn current_era() -> EraIndex {
                Self::current_era().unwrap_or(Zero::zero())
            }
            fn stake(
                who: &Self::AccountId,
            ) -> Result<Stake<BalanceOf<T>>, DispatchError> {
                Self::ledger(Stash(who.clone()))
                    .map(|l| Stake {
                        total: l.total,
                        active: l.active,
                    })
                    .map_err(|e| e.into())
            }
            fn bond_extra(
                who: &Self::AccountId,
                extra: Self::Balance,
            ) -> DispatchResult {
                Self::bond_extra(RawOrigin::Signed(who.clone()).into(), extra)
            }
            fn unbond(who: &Self::AccountId, value: Self::Balance) -> DispatchResult {
                let ctrl = Self::bonded(who).ok_or(Error::<T>::NotStash)?;
                Self::unbond(RawOrigin::Signed(ctrl).into(), value)
                    .map_err(|with_post| with_post.error)
                    .map(|_| ())
            }
            fn set_payee(
                stash: &Self::AccountId,
                reward_acc: &Self::AccountId,
            ) -> DispatchResult {
                {
                    if !(!Self::is_virtual_staker(stash) || stash != reward_acc) {
                        {
                            return Err(Error::<T>::RewardDestinationRestricted.into());
                        };
                    }
                };
                let ledger = Self::ledger(Stash(stash.clone()))?;
                let _ = ledger
                    .set_payee(RewardDestination::Account(reward_acc.clone()))
                    .defensive_proof(
                        "ledger was retrieved from storage, thus its bonded; qed.",
                    )?;
                Ok(())
            }
            fn chill(who: &Self::AccountId) -> DispatchResult {
                let ctrl = Self::bonded(who).ok_or(Error::<T>::NotStash)?;
                Self::chill(RawOrigin::Signed(ctrl).into())
            }
            fn withdraw_unbonded(
                who: Self::AccountId,
                num_slashing_spans: u32,
            ) -> Result<bool, DispatchError> {
                let ctrl = Self::bonded(&who).ok_or(Error::<T>::NotStash)?;
                Self::withdraw_unbonded(
                        RawOrigin::Signed(ctrl.clone()).into(),
                        num_slashing_spans,
                    )
                    .map(|_| {
                        !StakingLedger::<T>::is_bonded(StakingAccount::Controller(ctrl))
                    })
                    .map_err(|with_post| with_post.error)
            }
            fn bond(
                who: &Self::AccountId,
                value: Self::Balance,
                payee: &Self::AccountId,
            ) -> DispatchResult {
                Self::bond(
                    RawOrigin::Signed(who.clone()).into(),
                    value,
                    RewardDestination::Account(payee.clone()),
                )
            }
            fn nominate(
                who: &Self::AccountId,
                targets: Vec<Self::AccountId>,
            ) -> DispatchResult {
                let ctrl = Self::bonded(who).ok_or(Error::<T>::NotStash)?;
                let targets = targets
                    .into_iter()
                    .map(T::Lookup::unlookup)
                    .collect::<Vec<_>>();
                Self::nominate(RawOrigin::Signed(ctrl).into(), targets)
            }
            fn desired_validator_count() -> u32 {
                ValidatorCount::<T>::get()
            }
            fn election_ongoing() -> bool {
                T::ElectionProvider::ongoing()
            }
            fn force_unstake(who: Self::AccountId) -> sp_runtime::DispatchResult {
                let num_slashing_spans = Self::slashing_spans(&who)
                    .map_or(0, |s| s.iter().count() as u32);
                Self::force_unstake(
                    RawOrigin::Root.into(),
                    who.clone(),
                    num_slashing_spans,
                )
            }
            fn is_exposed_in_era(who: &Self::AccountId, era: &EraIndex) -> bool {
                ErasStakers::<T>::iter_prefix(era)
                    .any(|(validator, exposures)| {
                        validator == *who
                            || exposures.others.iter().any(|i| i.who == *who)
                    })
                    || ErasStakersPaged::<T>::iter_prefix((era,))
                        .any(|((validator, _), exposure_page)| {
                            validator == *who
                                || exposure_page.others.iter().any(|i| i.who == *who)
                        })
            }
            fn status(
                who: &Self::AccountId,
            ) -> Result<sp_staking::StakerStatus<Self::AccountId>, DispatchError> {
                if !StakingLedger::<T>::is_bonded(StakingAccount::Stash(who.clone())) {
                    return Err(Error::<T>::NotStash.into());
                }
                let is_validator = Validators::<T>::contains_key(&who);
                let is_nominator = Nominators::<T>::get(&who);
                use sp_staking::StakerStatus;
                match (is_validator, is_nominator.is_some()) {
                    (false, false) => Ok(StakerStatus::Idle),
                    (true, false) => Ok(StakerStatus::Validator),
                    (false, true) => {
                        Ok(
                            StakerStatus::Nominator(
                                is_nominator
                                    .expect("is checked above; qed")
                                    .targets
                                    .into_inner(),
                            ),
                        )
                    }
                    (true, true) => {
                        {
                            let lvl = ::log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "{0}: {1:?}",
                                        ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                                        "cannot be both validators and nominator",
                                    ),
                                    lvl,
                                    &(
                                        "runtime::defensive",
                                        "pallet_staking::pallet::impls",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        };
                        if true {
                            if !false {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "{0}: {1:?}",
                                            ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                            "cannot be both validators and nominator",
                                        ),
                                    );
                                }
                            }
                        }
                        Err(Error::<T>::BadState.into())
                    }
                }
            }
            /// Whether `who` is a virtual staker whose funds are managed by another pallet.
            fn is_virtual_staker(who: &T::AccountId) -> bool {
                VirtualStakers::<T>::contains_key(who)
            }
            fn slash_reward_fraction() -> Perbill {
                SlashRewardFraction::<T>::get()
            }
        }
        impl<T: Config> sp_staking::StakingUnchecked for Pallet<T> {
            fn migrate_to_virtual_staker(who: &Self::AccountId) {
                asset::kill_stake::<T>(who);
                VirtualStakers::<T>::insert(who, ());
            }
            /// Virtually bonds `keyless_who` to `payee` with `value`.
            ///
            /// The payee must not be the same as the `keyless_who`.
            fn virtual_bond(
                keyless_who: &Self::AccountId,
                value: Self::Balance,
                payee: &Self::AccountId,
            ) -> DispatchResult {
                if StakingLedger::<
                    T,
                >::is_bonded(StakingAccount::Stash(keyless_who.clone())) {
                    return Err(Error::<T>::AlreadyBonded.into());
                }
                {
                    if !(keyless_who != payee) {
                        {
                            return Err(Error::<T>::RewardDestinationRestricted.into());
                        };
                    }
                };
                frame_system::Pallet::<T>::inc_consumers(&keyless_who)
                    .map_err(|_| Error::<T>::BadState)?;
                VirtualStakers::<T>::insert(keyless_who, ());
                Self::deposit_event(Event::<T>::Bonded {
                    stash: keyless_who.clone(),
                    amount: value,
                });
                let ledger = StakingLedger::<T>::new(keyless_who.clone(), value);
                ledger.bond(RewardDestination::Account(payee.clone()))?;
                Ok(())
            }
        }
    }
    pub use impls::*;
    use crate::{
        asset, slashing, weights::WeightInfo, AccountIdLookupOf, ActiveEraInfo,
        BalanceOf, DisablingStrategy, EraPayout, EraRewardPoints, Exposure, ExposurePage,
        Forcing, LedgerIntegrityState, MaxNominationsOf, NegativeImbalanceOf,
        Nominations, NominationsQuota, PositiveImbalanceOf, RewardDestination,
        SessionInterface, StakingLedger, UnappliedSlash, UnlockChunk, ValidatorPrefs,
    };
    pub(crate) const SPECULATIVE_NUM_SPANS: u32 = 32;
    /**The `pallet` module in each FRAME pallet hosts the most important items needed
to construct this pallet.

The main components of this pallet are:
- [`Pallet`], which implements all of the dispatchable extrinsics of the pallet, among
other public functions.
	- The subset of the functions that are dispatchable can be identified either in the
	[`dispatchables`] module or in the [`Call`] enum.
- [`storage_types`], which contains the list of all types that are representing a
storage item. Otherwise, all storage items are listed among [*Type Definitions*](#types).
- [`Config`], which contains the configuration trait of this pallet.
- [`Event`] and [`Error`], which are listed among the [*Enums*](#enums).
		*/
    pub mod pallet {
        use frame_election_provider_support::ElectionDataProvider;
        use crate::{BenchmarkingConfig, PagedExposureMetadata};
        use super::*;
        /// The in-code storage version.
        const STORAGE_VERSION: StorageVersion = StorageVersion::new(15);
        /**
				The `Pallet` struct, the main type that implements traits and standalone
				functions within the pallet.
			*/
        pub struct Pallet<T>(core::marker::PhantomData<(T)>);
        const _: () = {
            #[automatically_derived]
            impl<T> ::core::clone::Clone for Pallet<T> {
                fn clone(&self) -> Self {
                    Self(::core::clone::Clone::clone(&self.0))
                }
            }
        };
        const _: () = {
            impl<T> ::core::cmp::Eq for Pallet<T> {}
        };
        const _: () = {
            #[automatically_derived]
            impl<T> ::core::cmp::PartialEq for Pallet<T> {
                fn eq(&self, other: &Self) -> bool {
                    true && self.0 == other.0
                }
            }
        };
        const _: () = {
            #[automatically_derived]
            impl<T> ::core::fmt::Debug for Pallet<T> {
                fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    fmt.debug_tuple("Pallet").field(&self.0).finish()
                }
            }
        };
        /// Possible operations on the configuration values of this pallet.
        pub enum ConfigOp<T: Default + Codec> {
            /// Don't change.
            Noop,
            /// Set the given value.
            Set(T),
            /// Remove from storage.
            Remove,
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            impl<T: Default + Codec> ::scale_info::TypeInfo for ConfigOp<T>
            where
                T: ::scale_info::TypeInfo + 'static,
                T: Default + Codec + ::scale_info::TypeInfo + 'static,
            {
                type Identity = Self;
                fn type_info() -> ::scale_info::Type {
                    ::scale_info::Type::builder()
                        .path(
                            ::scale_info::Path::new_with_replace(
                                "ConfigOp",
                                "pallet_staking::pallet::pallet",
                                &[],
                            ),
                        )
                        .type_params(
                            <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    ::scale_info::TypeParameter::new(
                                        "T",
                                        ::core::option::Option::Some(::scale_info::meta_type::<T>()),
                                    ),
                                ]),
                            ),
                        )
                        .docs(
                            &[
                                "Possible operations on the configuration values of this pallet.",
                            ],
                        )
                        .variant(
                            ::scale_info::build::Variants::new()
                                .variant(
                                    "Noop",
                                    |v| {
                                        v
                                            .index(0usize as ::core::primitive::u8)
                                            .docs(&["Don't change."])
                                    },
                                )
                                .variant(
                                    "Set",
                                    |v| {
                                        v
                                            .index(1usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::unnamed()
                                                    .field(|f| f.ty::<T>().type_name("T")),
                                            )
                                            .docs(&["Set the given value."])
                                    },
                                )
                                .variant(
                                    "Remove",
                                    |v| {
                                        v
                                            .index(2usize as ::core::primitive::u8)
                                            .docs(&["Remove from storage."])
                                    },
                                ),
                        )
                }
            }
        };
        #[automatically_derived]
        impl<T: ::core::fmt::Debug + Default + Codec> ::core::fmt::Debug
        for ConfigOp<T> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    ConfigOp::Noop => ::core::fmt::Formatter::write_str(f, "Noop"),
                    ConfigOp::Set(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Set",
                            &__self_0,
                        )
                    }
                    ConfigOp::Remove => ::core::fmt::Formatter::write_str(f, "Remove"),
                }
            }
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone + Default + Codec> ::core::clone::Clone
        for ConfigOp<T> {
            #[inline]
            fn clone(&self) -> ConfigOp<T> {
                match self {
                    ConfigOp::Noop => ConfigOp::Noop,
                    ConfigOp::Set(__self_0) => {
                        ConfigOp::Set(::core::clone::Clone::clone(__self_0))
                    }
                    ConfigOp::Remove => ConfigOp::Remove,
                }
            }
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<T: Default + Codec> ::codec::Encode for ConfigOp<T>
            where
                T: ::codec::Encode,
                T: ::codec::Encode,
            {
                fn size_hint(&self) -> usize {
                    1_usize
                        + match *self {
                            ConfigOp::Noop => 0_usize,
                            ConfigOp::Set(ref aa) => {
                                0_usize.saturating_add(::codec::Encode::size_hint(aa))
                            }
                            ConfigOp::Remove => 0_usize,
                            _ => 0_usize,
                        }
                }
                fn encode_to<
                    __CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized,
                >(&self, __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    match *self {
                        ConfigOp::Noop => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                        }
                        ConfigOp::Set(ref aa) => {
                            __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                        }
                        ConfigOp::Remove => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(2usize as ::core::primitive::u8);
                        }
                        _ => {}
                    }
                }
            }
            #[automatically_derived]
            impl<T: Default + Codec> ::codec::EncodeLike for ConfigOp<T>
            where
                T: ::codec::Encode,
                T: ::codec::Encode,
            {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<T: Default + Codec> ::codec::Decode for ConfigOp<T>
            where
                T: ::codec::Decode,
                T: ::codec::Decode,
            {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    match __codec_input_edqy
                        .read_byte()
                        .map_err(|e| {
                            e
                                .chain(
                                    "Could not decode `ConfigOp`, failed to read variant byte",
                                )
                        })?
                    {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 0usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(ConfigOp::<T>::Noop)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 1usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    ConfigOp::<
                                        T,
                                    >::Set({
                                        let __codec_res_edqy = <T as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `ConfigOp::Set.0`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    }),
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 2usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(ConfigOp::<T>::Remove)
                            })();
                        }
                        _ => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Err(
                                    <_ as ::core::convert::Into<
                                        _,
                                    >>::into(
                                        "Could not decode `ConfigOp`, variant doesn't exist",
                                    ),
                                )
                            })();
                        }
                    }
                }
            }
        };
        #[automatically_derived]
        impl<T: Default + Codec> ::core::marker::StructuralPartialEq for ConfigOp<T> {}
        #[automatically_derived]
        impl<T: ::core::cmp::PartialEq + Default + Codec> ::core::cmp::PartialEq
        for ConfigOp<T> {
            #[inline]
            fn eq(&self, other: &ConfigOp<T>) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (ConfigOp::Set(__self_0), ConfigOp::Set(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        _ => true,
                    }
            }
        }
        /**
Configuration trait of this pallet.

The main purpose of this trait is to act as an interface between this pallet and the runtime in
which it is embedded in. A type, function, or constant in this trait is essentially left to be
configured by the runtime that includes this pallet.

Consequently, a runtime that wants to include this pallet must implement this trait.*/
        pub trait Config: frame_system::Config {
            /// The staking balance.
            type Currency: LockableCurrency<
                    Self::AccountId,
                    Moment = BlockNumberFor<Self>,
                    Balance = Self::CurrencyBalance,
                >
                + InspectLockableCurrency<Self::AccountId>;
            /// Just the `Currency::Balance` type; we have this item to allow us to constrain it to
            /// `From<u64>`.
            type CurrencyBalance: sp_runtime::traits::AtLeast32BitUnsigned
                + codec::FullCodec
                + Copy
                + MaybeSerializeDeserialize
                + core::fmt::Debug
                + Default
                + From<u64>
                + TypeInfo
                + MaxEncodedLen;
            /// Time used for computing era duration.
            ///
            /// It is guaranteed to start being called from the first `on_finalize`. Thus value at
            /// genesis is not used.
            type UnixTime: UnixTime;
            /// Convert a balance into a number used for election calculation. This must fit into a
            /// `u64` but is allowed to be sensibly lossy. The `u64` is used to communicate with the
            /// [`frame_election_provider_support`] crate which accepts u64 numbers and does operations
            /// in 128.
            /// Consequently, the backward convert is used convert the u128s from sp-elections back to a
            /// [`BalanceOf`].
            type CurrencyToVote: sp_staking::currency_to_vote::CurrencyToVote<
                    BalanceOf<Self>,
                >;
            /// Something that provides the election functionality.
            type ElectionProvider: ElectionProvider<
                    AccountId = Self::AccountId,
                    BlockNumber = BlockNumberFor<Self>,
                    DataProvider = Pallet<Self>,
                >;
            /// Something that provides the election functionality at genesis.
            type GenesisElectionProvider: ElectionProvider<
                    AccountId = Self::AccountId,
                    BlockNumber = BlockNumberFor<Self>,
                    DataProvider = Pallet<Self>,
                >;
            /// Something that defines the maximum number of nominations per nominator.
            type NominationsQuota: NominationsQuota<BalanceOf<Self>>;
            /// Number of eras to keep in history.
            ///
            /// Following information is kept for eras in `[current_era -
            /// HistoryDepth, current_era]`: `ErasStakers`, `ErasStakersClipped`,
            /// `ErasValidatorPrefs`, `ErasValidatorReward`, `ErasRewardPoints`,
            /// `ErasTotalStake`, `ErasStartSessionIndex`, `ClaimedRewards`, `ErasStakersPaged`,
            /// `ErasStakersOverview`.
            ///
            /// Must be more than the number of eras delayed by session.
            /// I.e. active era must always be in history. I.e. `active_era >
            /// current_era - history_depth` must be guaranteed.
            ///
            /// If migrating an existing pallet from storage value to config value,
            /// this should be set to same value or greater as in storage.
            ///
            /// Note: `HistoryDepth` is used as the upper bound for the `BoundedVec`
            /// item `StakingLedger.legacy_claimed_rewards`. Setting this value lower than
            /// the existing value can lead to inconsistencies in the
            /// `StakingLedger` and will need to be handled properly in a migration.
            /// The test `reducing_history_depth_abrupt` shows this effect.
            type HistoryDepth: Get<u32>;
            /// Tokens have been minted and are unused for validator-reward.
            /// See [Era payout](./index.html#era-payout).
            type RewardRemainder: OnUnbalanced<NegativeImbalanceOf<Self>>;
            /// The overarching event type.
            type RuntimeEvent: From<Event<Self>>
                + IsType<<Self as frame_system::Config>::RuntimeEvent>;
            /// Handler for the unbalanced reduction when slashing a staker.
            type Slash: OnUnbalanced<NegativeImbalanceOf<Self>>;
            /// Handler for the unbalanced increment when rewarding a staker.
            /// NOTE: in most cases, the implementation of `OnUnbalanced` should modify the total
            /// issuance.
            type Reward: OnUnbalanced<PositiveImbalanceOf<Self>>;
            /// Number of sessions per era.
            type SessionsPerEra: Get<SessionIndex>;
            /// Number of eras that staked funds must remain bonded for.
            type BondingDuration: Get<EraIndex>;
            /// Number of eras that slashes are deferred by, after computation.
            ///
            /// This should be less than the bonding duration. Set to 0 if slashes
            /// should be applied immediately, without opportunity for intervention.
            type SlashDeferDuration: Get<EraIndex>;
            /// The origin which can manage less critical staking parameters that does not require root.
            ///
            /// Supported actions: (1) cancel deferred slash, (2) set minimum commission.
            type AdminOrigin: EnsureOrigin<Self::RuntimeOrigin>;
            /// Interface for interacting with a session pallet.
            type SessionInterface: SessionInterface<Self::AccountId>;
            /// The payout for validators and the system for the current era.
            /// See [Era payout](./index.html#era-payout).
            type EraPayout: EraPayout<BalanceOf<Self>>;
            /// Something that can estimate the next session change, accurately or as a best effort
            /// guess.
            type NextNewSession: EstimateNextNewSession<BlockNumberFor<Self>>;
            /// The maximum size of each `T::ExposurePage`.
            ///
            /// An `ExposurePage` is weakly bounded to a maximum of `MaxExposurePageSize`
            /// nominators.
            ///
            /// For older non-paged exposure, a reward payout was restricted to the top
            /// `MaxExposurePageSize` nominators. This is to limit the i/o cost for the
            /// nominator payout.
            ///
            /// Note: `MaxExposurePageSize` is used to bound `ClaimedRewards` and is unsafe to reduce
            /// without handling it in a migration.
            type MaxExposurePageSize: Get<u32>;
            /// Something that provides a best-effort sorted list of voters aka electing nominators,
            /// used for NPoS election.
            ///
            /// The changes to nominators are reported to this. Moreover, each validator's self-vote is
            /// also reported as one independent vote.
            ///
            /// To keep the load off the chain as much as possible, changes made to the staked amount
            /// via rewards and slashes are not reported and thus need to be manually fixed by the
            /// staker. In case of `bags-list`, this always means using `rebag` and `putInFrontOf`.
            ///
            /// Invariant: what comes out of this list will always be a nominator.
            type VoterList: SortedListProvider<Self::AccountId, Score = VoteWeight>;
            /// WIP: This is a noop as of now, the actual business logic that's described below is going
            /// to be introduced in a follow-up PR.
            ///
            /// Something that provides a best-effort sorted list of targets aka electable validators,
            /// used for NPoS election.
            ///
            /// The changes to the approval stake of each validator are reported to this. This means any
            /// change to:
            /// 1. The stake of any validator or nominator.
            /// 2. The targets of any nominator
            /// 3. The role of any staker (e.g. validator -> chilled, nominator -> validator, etc)
            ///
            /// Unlike `VoterList`, the values in this list are always kept up to date with reward and
            /// slash as well, and thus represent the accurate approval stake of all account being
            /// nominated by nominators.
            ///
            /// Note that while at the time of nomination, all targets are checked to be real
            /// validators, they can chill at any point, and their approval stakes will still be
            /// recorded. This implies that what comes out of iterating this list MIGHT NOT BE AN ACTIVE
            /// VALIDATOR.
            type TargetList: SortedListProvider<
                    Self::AccountId,
                    Score = BalanceOf<Self>,
                >;
            /// The maximum number of `unlocking` chunks a [`StakingLedger`] can
            /// have. Effectively determines how many unique eras a staker may be
            /// unbonding in.
            ///
            /// Note: `MaxUnlockingChunks` is used as the upper bound for the
            /// `BoundedVec` item `StakingLedger.unlocking`. Setting this value
            /// lower than the existing value can lead to inconsistencies in the
            /// `StakingLedger` and will need to be handled properly in a runtime
            /// migration. The test `reducing_max_unlocking_chunks_abrupt` shows
            /// this effect.
            type MaxUnlockingChunks: Get<u32>;
            /// The maximum amount of controller accounts that can be deprecated in one call.
            type MaxControllersInDeprecationBatch: Get<u32>;
            /// Something that listens to staking updates and performs actions based on the data it
            /// receives.
            ///
            /// WARNING: this only reports slashing and withdraw events for the time being.
            type EventListeners: sp_staking::OnStakingUpdate<
                    Self::AccountId,
                    BalanceOf<Self>,
                >;
            /// `DisablingStragegy` controls how validators are disabled
            type DisablingStrategy: DisablingStrategy<Self>;
            /// Some parameters of the benchmarking.
            #[cfg(feature = "std")]
            type BenchmarkingConfig: BenchmarkingConfig;
            /// Weight information for extrinsics in this pallet.
            type WeightInfo: WeightInfo;
        }
        /// Default implementations of [`DefaultConfig`], which can be used to implement [`Config`].
        pub mod config_preludes {
            use super::*;
            use frame_support::{derive_impl, parameter_types, traits::ConstU32};
            pub struct TestDefaultConfig;
            impl frame_system::DefaultConfig for TestDefaultConfig {
                type Nonce = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::Nonce;
                type Hash = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::Hash;
                type Hashing = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::Hashing;
                type AccountId = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::AccountId;
                type Lookup = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::Lookup;
                type MaxConsumers = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::MaxConsumers;
                type AccountData = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::AccountData;
                type OnNewAccount = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::OnNewAccount;
                type OnKilledAccount = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::OnKilledAccount;
                type SystemWeightInfo = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::SystemWeightInfo;
                type ExtensionsWeightInfo = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::ExtensionsWeightInfo;
                type SS58Prefix = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::SS58Prefix;
                type Version = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::Version;
                type BlockWeights = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::BlockWeights;
                type BlockLength = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::BlockLength;
                type DbWeight = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::DbWeight;
                type RuntimeEvent = ();
                type RuntimeOrigin = ();
                type RuntimeCall = ();
                type PalletInfo = ();
                type RuntimeTask = ();
                type BaseCallFilter = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::BaseCallFilter;
                type BlockHashCount = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::BlockHashCount;
                type OnSetCode = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::OnSetCode;
                type SingleBlockMigrations = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::SingleBlockMigrations;
                type MultiBlockMigrator = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::MultiBlockMigrator;
                type PreInherents = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::PreInherents;
                type PostInherents = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::PostInherents;
                type PostTransactions = <frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig>::PostTransactions;
            }
            pub struct SessionsPerEra;
            impl SessionsPerEra {
                /// Returns the value of this parameter type.
                pub const fn get() -> SessionIndex {
                    3
                }
            }
            impl<_I: From<SessionIndex>> ::frame_support::traits::Get<_I>
            for SessionsPerEra {
                fn get() -> _I {
                    _I::from(Self::get())
                }
            }
            impl ::frame_support::traits::TypedGet for SessionsPerEra {
                type Type = SessionIndex;
                fn get() -> SessionIndex {
                    Self::get()
                }
            }
            pub struct BondingDuration;
            impl BondingDuration {
                /// Returns the value of this parameter type.
                pub const fn get() -> EraIndex {
                    3
                }
            }
            impl<_I: From<EraIndex>> ::frame_support::traits::Get<_I>
            for BondingDuration {
                fn get() -> _I {
                    _I::from(Self::get())
                }
            }
            impl ::frame_support::traits::TypedGet for BondingDuration {
                type Type = EraIndex;
                fn get() -> EraIndex {
                    Self::get()
                }
            }
            pub use __export_tokens_tt_1677759494_test_default_config_0 as TestDefaultConfig;
            #[allow(unused)]
            impl DefaultConfig for TestDefaultConfig {
                type RuntimeEvent = ();
                type CurrencyBalance = u128;
                type CurrencyToVote = ();
                type NominationsQuota = crate::FixedNominationsQuota<16>;
                type HistoryDepth = ConstU32<84>;
                type RewardRemainder = ();
                type Slash = ();
                type Reward = ();
                type SessionsPerEra = SessionsPerEra;
                type BondingDuration = BondingDuration;
                type SlashDeferDuration = ();
                type SessionInterface = ();
                type NextNewSession = ();
                type MaxExposurePageSize = ConstU32<64>;
                type MaxUnlockingChunks = ConstU32<32>;
                type MaxControllersInDeprecationBatch = ConstU32<100>;
                type EventListeners = ();
                type DisablingStrategy = crate::UpToLimitDisablingStrategy;
                #[cfg(feature = "std")]
                type BenchmarkingConfig = crate::TestBenchmarkingConfig;
                type WeightInfo = ();
            }
        }
        /// The ideal number of active validators.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `u32`.
        pub type ValidatorCount<T> = StorageValue<
            _GeneratedPrefixForStorageValidatorCount<T>,
            u32,
            ValueQuery,
        >;
        /// Minimum number of staking participants before emergency conditions are imposed.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `u32`.
        pub type MinimumValidatorCount<T> = StorageValue<
            _GeneratedPrefixForStorageMinimumValidatorCount<T>,
            u32,
            ValueQuery,
        >;
        /// Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
        /// easy to initialize and the performance hit is minimal (we expect no more than four
        /// invulnerables) and restricted to testnets.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `Vec < T :: AccountId >`.
        pub type Invulnerables<T: Config> = StorageValue<
            _GeneratedPrefixForStorageInvulnerables<T>,
            Vec<T::AccountId>,
            ValueQuery,
        >;
        /// Map from all locked "stash" accounts to the controller account.
        ///
        /// TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageMap`] with key type `T :: AccountId` and value type `T :: AccountId`.
        pub type Bonded<T: Config> = StorageMap<
            _GeneratedPrefixForStorageBonded<T>,
            Twox64Concat,
            T::AccountId,
            T::AccountId,
        >;
        /// The minimum active bond to become and maintain the role of a nominator.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `BalanceOf < T >`.
        pub type MinNominatorBond<T: Config> = StorageValue<
            _GeneratedPrefixForStorageMinNominatorBond<T>,
            BalanceOf<T>,
            ValueQuery,
        >;
        /// The minimum active bond to become and maintain the role of a validator.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `BalanceOf < T >`.
        pub type MinValidatorBond<T: Config> = StorageValue<
            _GeneratedPrefixForStorageMinValidatorBond<T>,
            BalanceOf<T>,
            ValueQuery,
        >;
        /// The minimum active nominator stake of the last successful election.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `BalanceOf < T >`.
        pub type MinimumActiveStake<T> = StorageValue<
            _GeneratedPrefixForStorageMinimumActiveStake<T>,
            BalanceOf<T>,
            ValueQuery,
        >;
        /// The minimum amount of commission that validators can set.
        ///
        /// If set to `0`, no limit exists.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `Perbill`.
        pub type MinCommission<T: Config> = StorageValue<
            _GeneratedPrefixForStorageMinCommission<T>,
            Perbill,
            ValueQuery,
        >;
        /// Map from all (unlocked) "controller" accounts to the info regarding the staking.
        ///
        /// Note: All the reads and mutations to this storage *MUST* be done through the methods exposed
        /// by [`StakingLedger`] to ensure data and lock consistency.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageMap`] with key type `T :: AccountId` and value type `StakingLedger < T >`.
        pub type Ledger<T: Config> = StorageMap<
            _GeneratedPrefixForStorageLedger<T>,
            Blake2_128Concat,
            T::AccountId,
            StakingLedger<T>,
        >;
        /// Where the reward payment should be made. Keyed by stash.
        ///
        /// TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageMap`] with key type `T :: AccountId` and value type `RewardDestination < T :: AccountId >`.
        pub type Payee<T: Config> = StorageMap<
            _GeneratedPrefixForStoragePayee<T>,
            Twox64Concat,
            T::AccountId,
            RewardDestination<T::AccountId>,
            OptionQuery,
        >;
        /// The map from (wannabe) validator stash key to the preferences of that validator.
        ///
        /// TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`CountedStorageMap`] with key type T :: AccountId and value type ValidatorPrefs.
        pub type Validators<T: Config> = CountedStorageMap<
            _GeneratedPrefixForStorageValidators<T>,
            Twox64Concat,
            T::AccountId,
            ValidatorPrefs,
            ValueQuery,
        >;
        /// The maximum validator count before we stop allowing new validators to join.
        ///
        /// When this value is not set, no limits are enforced.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `u32`.
        pub type MaxValidatorsCount<T> = StorageValue<
            _GeneratedPrefixForStorageMaxValidatorsCount<T>,
            u32,
            OptionQuery,
        >;
        /// The map from nominator stash key to their nomination preferences, namely the validators that
        /// they wish to support.
        ///
        /// Note that the keys of this storage map might become non-decodable in case the
        /// account's [`NominationsQuota::MaxNominations`] configuration is decreased.
        /// In this rare case, these nominators
        /// are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
        /// indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
        /// nominators will effectively not-exist, until they re-submit their preferences such that it
        /// is within the bounds of the newly set `Config::MaxNominations`.
        ///
        /// This implies that `::iter_keys().count()` and `::iter().count()` might return different
        /// values for this map. Moreover, the main `::count()` is aligned with the former, namely the
        /// number of keys that exist.
        ///
        /// Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
        /// [`Call::chill_other`] dispatchable by anyone.
        ///
        /// TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`CountedStorageMap`] with key type T :: AccountId and value type Nominations < T >.
        pub type Nominators<T: Config> = CountedStorageMap<
            _GeneratedPrefixForStorageNominators<T>,
            Twox64Concat,
            T::AccountId,
            Nominations<T>,
        >;
        /// Stakers whose funds are managed by other pallets.
        ///
        /// This pallet does not apply any locks on them, therefore they are only virtually bonded. They
        /// are expected to be keyless accounts and hence should not be allowed to mutate their ledger
        /// directly via this pallet. Instead, these accounts are managed by other pallets and accessed
        /// via low level apis. We keep track of them to do minimal integrity checks.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`CountedStorageMap`] with key type T :: AccountId and value type ().
        pub type VirtualStakers<T: Config> = CountedStorageMap<
            _GeneratedPrefixForStorageVirtualStakers<T>,
            Twox64Concat,
            T::AccountId,
            (),
        >;
        /// The maximum nominator count before we stop allowing new validators to join.
        ///
        /// When this value is not set, no limits are enforced.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `u32`.
        pub type MaxNominatorsCount<T> = StorageValue<
            _GeneratedPrefixForStorageMaxNominatorsCount<T>,
            u32,
            OptionQuery,
        >;
        /// The current era index.
        ///
        /// This is the latest planned era, depending on how the Session pallet queues the validator
        /// set, it might be active or not.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `EraIndex`.
        pub type CurrentEra<T> = StorageValue<
            _GeneratedPrefixForStorageCurrentEra<T>,
            EraIndex,
        >;
        /// The active era information, it holds index and start.
        ///
        /// The active era is the era being currently rewarded. Validator set of this era must be
        /// equal to [`SessionInterface::validators`].
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `ActiveEraInfo`.
        pub type ActiveEra<T> = StorageValue<
            _GeneratedPrefixForStorageActiveEra<T>,
            ActiveEraInfo,
        >;
        /// The session index at which the era start for the last [`Config::HistoryDepth`] eras.
        ///
        /// Note: This tracks the starting session (i.e. session index when era start being active)
        /// for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageMap`] with key type `EraIndex` and value type `SessionIndex`.
        pub type ErasStartSessionIndex<T> = StorageMap<
            _GeneratedPrefixForStorageErasStartSessionIndex<T>,
            Twox64Concat,
            EraIndex,
            SessionIndex,
        >;
        /// Exposure of validator at era.
        ///
        /// This is keyed first by the era index to allow bulk deletion and then the stash account.
        ///
        /// Is it removed after [`Config::HistoryDepth`] eras.
        /// If stakers hasn't been set or has been removed then empty exposure is returned.
        ///
        /// Note: Deprecated since v14. Use `EraInfo` instead to work with exposures.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageDoubleMap`] with key1 type EraIndex, key2 type T :: AccountId and value type Exposure < T :: AccountId, BalanceOf < T > >.
        pub type ErasStakers<T: Config> = StorageDoubleMap<
            _GeneratedPrefixForStorageErasStakers<T>,
            Twox64Concat,
            EraIndex,
            Twox64Concat,
            T::AccountId,
            Exposure<T::AccountId, BalanceOf<T>>,
            ValueQuery,
        >;
        /// Summary of validator exposure at a given era.
        ///
        /// This contains the total stake in support of the validator and their own stake. In addition,
        /// it can also be used to get the number of nominators backing this validator and the number of
        /// exposure pages they are divided into. The page count is useful to determine the number of
        /// pages of rewards that needs to be claimed.
        ///
        /// This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// Should only be accessed through `EraInfo`.
        ///
        /// Is it removed after [`Config::HistoryDepth`] eras.
        /// If stakers hasn't been set or has been removed then empty overview is returned.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageDoubleMap`] with key1 type EraIndex, key2 type T :: AccountId and value type PagedExposureMetadata < BalanceOf < T > >.
        pub type ErasStakersOverview<T: Config> = StorageDoubleMap<
            _GeneratedPrefixForStorageErasStakersOverview<T>,
            Twox64Concat,
            EraIndex,
            Twox64Concat,
            T::AccountId,
            PagedExposureMetadata<BalanceOf<T>>,
            OptionQuery,
        >;
        /// Clipped Exposure of validator at era.
        ///
        /// Note: This is deprecated, should be used as read-only and will be removed in the future.
        /// New `Exposure`s are stored in a paged manner in `ErasStakersPaged` instead.
        ///
        /// This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
        /// `T::MaxExposurePageSize` biggest stakers.
        /// (Note: the field `total` and `own` of the exposure remains unchanged).
        /// This is used to limit the i/o cost for the nominator payout.
        ///
        /// This is keyed fist by the era index to allow bulk deletion and then the stash account.
        ///
        /// It is removed after [`Config::HistoryDepth`] eras.
        /// If stakers hasn't been set or has been removed then empty exposure is returned.
        ///
        /// Note: Deprecated since v14. Use `EraInfo` instead to work with exposures.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageDoubleMap`] with key1 type EraIndex, key2 type T :: AccountId and value type Exposure < T :: AccountId, BalanceOf < T > >.
        pub type ErasStakersClipped<T: Config> = StorageDoubleMap<
            _GeneratedPrefixForStorageErasStakersClipped<T>,
            Twox64Concat,
            EraIndex,
            Twox64Concat,
            T::AccountId,
            Exposure<T::AccountId, BalanceOf<T>>,
            ValueQuery,
        >;
        /// Paginated exposure of a validator at given era.
        ///
        /// This is keyed first by the era index to allow bulk deletion, then stash account and finally
        /// the page. Should only be accessed through `EraInfo`.
        ///
        /// This is cleared after [`Config::HistoryDepth`] eras.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageNMap`] with keys type (EraIndex, T :: AccountId, Page) and value type ExposurePage < T :: AccountId, BalanceOf < T > >.
        pub type ErasStakersPaged<T: Config> = StorageNMap<
            _GeneratedPrefixForStorageErasStakersPaged<T>,
            (
                NMapKey<Twox64Concat, EraIndex>,
                NMapKey<Twox64Concat, T::AccountId>,
                NMapKey<Twox64Concat, Page>,
            ),
            ExposurePage<T::AccountId, BalanceOf<T>>,
            OptionQuery,
        >;
        /// History of claimed paged rewards by era and validator.
        ///
        /// This is keyed by era and validator stash which maps to the set of page indexes which have
        /// been claimed.
        ///
        /// It is removed after [`Config::HistoryDepth`] eras.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageDoubleMap`] with key1 type EraIndex, key2 type T :: AccountId and value type Vec < Page >.
        pub type ClaimedRewards<T: Config> = StorageDoubleMap<
            _GeneratedPrefixForStorageClaimedRewards<T>,
            Twox64Concat,
            EraIndex,
            Twox64Concat,
            T::AccountId,
            Vec<Page>,
            ValueQuery,
        >;
        /// Similar to `ErasStakers`, this holds the preferences of validators.
        ///
        /// This is keyed first by the era index to allow bulk deletion and then the stash account.
        ///
        /// Is it removed after [`Config::HistoryDepth`] eras.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageDoubleMap`] with key1 type EraIndex, key2 type T :: AccountId and value type ValidatorPrefs.
        pub type ErasValidatorPrefs<T: Config> = StorageDoubleMap<
            _GeneratedPrefixForStorageErasValidatorPrefs<T>,
            Twox64Concat,
            EraIndex,
            Twox64Concat,
            T::AccountId,
            ValidatorPrefs,
            ValueQuery,
        >;
        /// The total validator era payout for the last [`Config::HistoryDepth`] eras.
        ///
        /// Eras that haven't finished yet or has been removed doesn't have reward.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageMap`] with key type `EraIndex` and value type `BalanceOf < T >`.
        pub type ErasValidatorReward<T: Config> = StorageMap<
            _GeneratedPrefixForStorageErasValidatorReward<T>,
            Twox64Concat,
            EraIndex,
            BalanceOf<T>,
        >;
        /// Rewards for the last [`Config::HistoryDepth`] eras.
        /// If reward hasn't been set or has been removed then 0 reward is returned.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageMap`] with key type `EraIndex` and value type `EraRewardPoints < T :: AccountId >`.
        pub type ErasRewardPoints<T: Config> = StorageMap<
            _GeneratedPrefixForStorageErasRewardPoints<T>,
            Twox64Concat,
            EraIndex,
            EraRewardPoints<T::AccountId>,
            ValueQuery,
        >;
        /// The total amount staked for the last [`Config::HistoryDepth`] eras.
        /// If total hasn't been set or has been removed then 0 stake is returned.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageMap`] with key type `EraIndex` and value type `BalanceOf < T >`.
        pub type ErasTotalStake<T: Config> = StorageMap<
            _GeneratedPrefixForStorageErasTotalStake<T>,
            Twox64Concat,
            EraIndex,
            BalanceOf<T>,
            ValueQuery,
        >;
        /// Mode of era forcing.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `Forcing`.
        pub type ForceEra<T> = StorageValue<
            _GeneratedPrefixForStorageForceEra<T>,
            Forcing,
            ValueQuery,
        >;
        /// Maximum staked rewards, i.e. the percentage of the era inflation that
        /// is used for stake rewards.
        /// See [Era payout](./index.html#era-payout).
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `Percent`.
        pub type MaxStakedRewards<T> = StorageValue<
            _GeneratedPrefixForStorageMaxStakedRewards<T>,
            Percent,
            OptionQuery,
        >;
        /// The percentage of the slash that is distributed to reporters.
        ///
        /// The rest of the slashed value is handled by the `Slash`.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `Perbill`.
        pub type SlashRewardFraction<T> = StorageValue<
            _GeneratedPrefixForStorageSlashRewardFraction<T>,
            Perbill,
            ValueQuery,
        >;
        /// The amount of currency given to reporters of a slash event which was
        /// canceled by extraordinary circumstances (e.g. governance).
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `BalanceOf < T >`.
        pub type CanceledSlashPayout<T: Config> = StorageValue<
            _GeneratedPrefixForStorageCanceledSlashPayout<T>,
            BalanceOf<T>,
            ValueQuery,
        >;
        /// All unapplied slashes that are queued for later.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageMap`] with key type `EraIndex` and value type `Vec < UnappliedSlash < T :: AccountId, BalanceOf < T > > >`.
        pub type UnappliedSlashes<T: Config> = StorageMap<
            _GeneratedPrefixForStorageUnappliedSlashes<T>,
            Twox64Concat,
            EraIndex,
            Vec<UnappliedSlash<T::AccountId, BalanceOf<T>>>,
            ValueQuery,
        >;
        /// A mapping from still-bonded eras to the first session index of that era.
        ///
        /// Must contains information for eras for the range:
        /// `[active_era - bounding_duration; active_era]`
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `Vec < (EraIndex, SessionIndex) >`.
        pub(crate) type BondedEras<T: Config> = StorageValue<
            _GeneratedPrefixForStorageBondedEras<T>,
            Vec<(EraIndex, SessionIndex)>,
            ValueQuery,
        >;
        /// All slashing events on validators, mapped by era to the highest slash proportion
        /// and slash value of the era.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageDoubleMap`] with key1 type EraIndex, key2 type T :: AccountId and value type (Perbill, BalanceOf < T >).
        pub(crate) type ValidatorSlashInEra<T: Config> = StorageDoubleMap<
            _GeneratedPrefixForStorageValidatorSlashInEra<T>,
            Twox64Concat,
            EraIndex,
            Twox64Concat,
            T::AccountId,
            (Perbill, BalanceOf<T>),
        >;
        /// All slashing events on nominators, mapped by era to the highest slash value of the era.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageDoubleMap`] with key1 type EraIndex, key2 type T :: AccountId and value type BalanceOf < T >.
        pub(crate) type NominatorSlashInEra<T: Config> = StorageDoubleMap<
            _GeneratedPrefixForStorageNominatorSlashInEra<T>,
            Twox64Concat,
            EraIndex,
            Twox64Concat,
            T::AccountId,
            BalanceOf<T>,
        >;
        /// Slashing spans for stash accounts.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageMap`] with key type `T :: AccountId` and value type `slashing :: SlashingSpans`.
        pub type SlashingSpans<T: Config> = StorageMap<
            _GeneratedPrefixForStorageSlashingSpans<T>,
            Twox64Concat,
            T::AccountId,
            slashing::SlashingSpans,
        >;
        /// Records information about the maximum slash of a stash within a slashing span,
        /// as well as how much reward has been paid out.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageMap`] with key type `(T :: AccountId, slashing :: SpanIndex)` and value type `slashing :: SpanRecord < BalanceOf < T > >`.
        pub(crate) type SpanSlash<T: Config> = StorageMap<
            _GeneratedPrefixForStorageSpanSlash<T>,
            Twox64Concat,
            (T::AccountId, slashing::SpanIndex),
            slashing::SpanRecord<BalanceOf<T>>,
            ValueQuery,
        >;
        /// The last planned session scheduled by the session pallet.
        ///
        /// This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `SessionIndex`.
        pub type CurrentPlannedSession<T> = StorageValue<
            _GeneratedPrefixForStorageCurrentPlannedSession<T>,
            SessionIndex,
            ValueQuery,
        >;
        /// Indices of validators that have offended in the active era. The offenders are disabled for a
        /// whole era. For this reason they are kept here - only staking pallet knows about eras. The
        /// implementor of [`DisablingStrategy`] defines if a validator should be disabled which
        /// implicitly means that the implementor also controls the max number of disabled validators.
        ///
        /// The vec is always kept sorted so that we can find whether a given validator has previously
        /// offended using binary search.
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `Vec < u32 >`.
        pub type DisabledValidators<T: Config> = StorageValue<
            _GeneratedPrefixForStorageDisabledValidators<T>,
            Vec<u32>,
            ValueQuery,
        >;
        /// The threshold for when users can start calling `chill_other` for other validators /
        /// nominators. The threshold is compared to the actual number of validators / nominators
        /// (`CountFor*`) in the system compared to the configured max (`Max*Count`).
        #[allow(type_alias_bounds)]
        ///
        ///Storage type is [`StorageValue`] with value type `Percent`.
        pub(crate) type ChillThreshold<T: Config> = StorageValue<
            _GeneratedPrefixForStorageChillThreshold<T>,
            Percent,
            OptionQuery,
        >;
        /**
					Can be used to configure the
					[genesis state](https://docs.substrate.io/build/genesis-configuration/)
					of this pallet.
					*/
        #[serde(rename_all = "camelCase")]
        #[serde(deny_unknown_fields)]
        #[serde(bound(serialize = ""))]
        #[serde(bound(deserialize = ""))]
        #[serde(crate = "frame_support::__private::serde")]
        pub struct GenesisConfig<T: Config> {
            pub validator_count: u32,
            pub minimum_validator_count: u32,
            pub invulnerables: Vec<T::AccountId>,
            pub force_era: Forcing,
            pub slash_reward_fraction: Perbill,
            pub canceled_payout: BalanceOf<T>,
            pub stakers: Vec<
                (
                    T::AccountId,
                    T::AccountId,
                    BalanceOf<T>,
                    crate::StakerStatus<T::AccountId>,
                ),
            >,
            pub min_nominator_bond: BalanceOf<T>,
            pub min_validator_bond: BalanceOf<T>,
            pub max_validator_count: Option<u32>,
            pub max_nominator_count: Option<u32>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            use frame_support::__private::serde as _serde;
            #[automatically_derived]
            impl<T: Config> frame_support::__private::serde::Serialize
            for GenesisConfig<T> {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> frame_support::__private::serde::__private::Result<
                    __S::Ok,
                    __S::Error,
                >
                where
                    __S: frame_support::__private::serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "GenesisConfig",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "validatorCount",
                        &self.validator_count,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "minimumValidatorCount",
                        &self.minimum_validator_count,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "invulnerables",
                        &self.invulnerables,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "forceEra",
                        &self.force_era,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "slashRewardFraction",
                        &self.slash_reward_fraction,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "canceledPayout",
                        &self.canceled_payout,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "stakers",
                        &self.stakers,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "minNominatorBond",
                        &self.min_nominator_bond,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "minValidatorBond",
                        &self.min_validator_bond,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "maxValidatorCount",
                        &self.max_validator_count,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "maxNominatorCount",
                        &self.max_nominator_count,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            use frame_support::__private::serde as _serde;
            #[automatically_derived]
            impl<'de, T: Config> frame_support::__private::serde::Deserialize<'de>
            for GenesisConfig<T> {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> frame_support::__private::serde::__private::Result<Self, __D::Error>
                where
                    __D: frame_support::__private::serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"field index 0 <= i < 11",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "validatorCount" => _serde::__private::Ok(__Field::__field0),
                                "minimumValidatorCount" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                "invulnerables" => _serde::__private::Ok(__Field::__field2),
                                "forceEra" => _serde::__private::Ok(__Field::__field3),
                                "slashRewardFraction" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                "canceledPayout" => _serde::__private::Ok(__Field::__field5),
                                "stakers" => _serde::__private::Ok(__Field::__field6),
                                "minNominatorBond" => {
                                    _serde::__private::Ok(__Field::__field7)
                                }
                                "minValidatorBond" => {
                                    _serde::__private::Ok(__Field::__field8)
                                }
                                "maxValidatorCount" => {
                                    _serde::__private::Ok(__Field::__field9)
                                }
                                "maxNominatorCount" => {
                                    _serde::__private::Ok(__Field::__field10)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"validatorCount" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"minimumValidatorCount" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"invulnerables" => _serde::__private::Ok(__Field::__field2),
                                b"forceEra" => _serde::__private::Ok(__Field::__field3),
                                b"slashRewardFraction" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                b"canceledPayout" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                b"stakers" => _serde::__private::Ok(__Field::__field6),
                                b"minNominatorBond" => {
                                    _serde::__private::Ok(__Field::__field7)
                                }
                                b"minValidatorBond" => {
                                    _serde::__private::Ok(__Field::__field8)
                                }
                                b"maxValidatorCount" => {
                                    _serde::__private::Ok(__Field::__field9)
                                }
                                b"maxNominatorCount" => {
                                    _serde::__private::Ok(__Field::__field10)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de, T: Config> {
                        marker: _serde::__private::PhantomData<GenesisConfig<T>>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de, T: Config> _serde::de::Visitor<'de> for __Visitor<'de, T> {
                        type Value = GenesisConfig<T>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GenesisConfig",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                u32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct GenesisConfig with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                u32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct GenesisConfig with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Vec<T::AccountId>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct GenesisConfig with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                Forcing,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct GenesisConfig with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                Perbill,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct GenesisConfig with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                BalanceOf<T>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct GenesisConfig with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                Vec<
                                    (
                                        T::AccountId,
                                        T::AccountId,
                                        BalanceOf<T>,
                                        crate::StakerStatus<T::AccountId>,
                                    ),
                                >,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct GenesisConfig with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match _serde::de::SeqAccess::next_element::<
                                BalanceOf<T>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct GenesisConfig with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field8 = match _serde::de::SeqAccess::next_element::<
                                BalanceOf<T>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct GenesisConfig with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field9 = match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            9usize,
                                            &"struct GenesisConfig with 11 elements",
                                        ),
                                    );
                                }
                            };
                            let __field10 = match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            10usize,
                                            &"struct GenesisConfig with 11 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(GenesisConfig {
                                validator_count: __field0,
                                minimum_validator_count: __field1,
                                invulnerables: __field2,
                                force_era: __field3,
                                slash_reward_fraction: __field4,
                                canceled_payout: __field5,
                                stakers: __field6,
                                min_nominator_bond: __field7,
                                min_validator_bond: __field8,
                                max_validator_count: __field9,
                                max_nominator_count: __field10,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<u32> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Vec<T::AccountId>,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Forcing> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<Perbill> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<BalanceOf<T>> = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<
                                Vec<
                                    (
                                        T::AccountId,
                                        T::AccountId,
                                        BalanceOf<T>,
                                        crate::StakerStatus<T::AccountId>,
                                    ),
                                >,
                            > = _serde::__private::None;
                            let mut __field7: _serde::__private::Option<BalanceOf<T>> = _serde::__private::None;
                            let mut __field8: _serde::__private::Option<BalanceOf<T>> = _serde::__private::None;
                            let mut __field9: _serde::__private::Option<Option<u32>> = _serde::__private::None;
                            let mut __field10: _serde::__private::Option<Option<u32>> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "validatorCount",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "minimumValidatorCount",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "invulnerables",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<T::AccountId>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "forceEra",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Forcing>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "slashRewardFraction",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Perbill>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "canceledPayout",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                BalanceOf<T>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "stakers",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<
                                                    (
                                                        T::AccountId,
                                                        T::AccountId,
                                                        BalanceOf<T>,
                                                        crate::StakerStatus<T::AccountId>,
                                                    ),
                                                >,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "minNominatorBond",
                                                ),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                BalanceOf<T>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field8 => {
                                        if _serde::__private::Option::is_some(&__field8) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "minValidatorBond",
                                                ),
                                            );
                                        }
                                        __field8 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                BalanceOf<T>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field9 => {
                                        if _serde::__private::Option::is_some(&__field9) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "maxValidatorCount",
                                                ),
                                            );
                                        }
                                        __field9 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<u32>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field10 => {
                                        if _serde::__private::Option::is_some(&__field10) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "maxNominatorCount",
                                                ),
                                            );
                                        }
                                        __field10 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<u32>,
                                            >(&mut __map)?,
                                        );
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("validatorCount")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "minimumValidatorCount",
                                    )?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("invulnerables")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("forceEra")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("slashRewardFraction")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("canceledPayout")?
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("stakers")?
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("minNominatorBond")?
                                }
                            };
                            let __field8 = match __field8 {
                                _serde::__private::Some(__field8) => __field8,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("minValidatorBond")?
                                }
                            };
                            let __field9 = match __field9 {
                                _serde::__private::Some(__field9) => __field9,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("maxValidatorCount")?
                                }
                            };
                            let __field10 = match __field10 {
                                _serde::__private::Some(__field10) => __field10,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("maxNominatorCount")?
                                }
                            };
                            _serde::__private::Ok(GenesisConfig {
                                validator_count: __field0,
                                minimum_validator_count: __field1,
                                invulnerables: __field2,
                                force_era: __field3,
                                slash_reward_fraction: __field4,
                                canceled_payout: __field5,
                                stakers: __field6,
                                min_nominator_bond: __field7,
                                min_validator_bond: __field8,
                                max_validator_count: __field9,
                                max_nominator_count: __field10,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "validatorCount",
                        "minimumValidatorCount",
                        "invulnerables",
                        "forceEra",
                        "slashRewardFraction",
                        "canceledPayout",
                        "stakers",
                        "minNominatorBond",
                        "minValidatorBond",
                        "maxValidatorCount",
                        "maxNominatorCount",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GenesisConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GenesisConfig<T>>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        const _: () = {
            #[automatically_derived]
            impl<T: Config> ::core::default::Default for GenesisConfig<T> {
                fn default() -> Self {
                    Self {
                        validator_count: ::core::default::Default::default(),
                        minimum_validator_count: ::core::default::Default::default(),
                        invulnerables: ::core::default::Default::default(),
                        force_era: ::core::default::Default::default(),
                        slash_reward_fraction: ::core::default::Default::default(),
                        canceled_payout: ::core::default::Default::default(),
                        stakers: ::core::default::Default::default(),
                        min_nominator_bond: ::core::default::Default::default(),
                        min_validator_bond: ::core::default::Default::default(),
                        max_validator_count: ::core::default::Default::default(),
                        max_nominator_count: ::core::default::Default::default(),
                    }
                }
            }
        };
        impl<T: Config> BuildGenesisConfig for GenesisConfig<T> {
            fn build(&self) {
                ValidatorCount::<T>::put(self.validator_count);
                MinimumValidatorCount::<T>::put(self.minimum_validator_count);
                Invulnerables::<T>::put(&self.invulnerables);
                ForceEra::<T>::put(self.force_era);
                CanceledSlashPayout::<T>::put(self.canceled_payout);
                SlashRewardFraction::<T>::put(self.slash_reward_fraction);
                MinNominatorBond::<T>::put(self.min_nominator_bond);
                MinValidatorBond::<T>::put(self.min_validator_bond);
                if let Some(x) = self.max_validator_count {
                    MaxValidatorsCount::<T>::put(x);
                }
                if let Some(x) = self.max_nominator_count {
                    MaxNominatorsCount::<T>::put(x);
                }
                for &(ref stash, _, balance, ref status) in &self.stakers {
                    {
                        let lvl = ::log::Level::Trace;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "[{0:?}] 💸 inserting genesis staker: {1:?} => {2:?} => {3:?}",
                                    <frame_system::Pallet<T>>::block_number(),
                                    stash,
                                    balance,
                                    status,
                                ),
                                lvl,
                                &(
                                    crate::LOG_TARGET,
                                    "pallet_staking::pallet::pallet",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    if !(asset::stakeable_balance::<T>(stash) >= balance) {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!("Stash does not have enough balance to bond."),
                            );
                        }
                    }
                    let is = <Pallet<
                        T,
                    >>::bond(
                        T::RuntimeOrigin::from(Some(stash.clone()).into()),
                        balance,
                        RewardDestination::Staked,
                    );
                    match is {
                        Ok(_) => {}
                        _ => {
                            if !false {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!("Expected Ok(_). Got {0:#?}", is),
                                    );
                                }
                            }
                        }
                    };
                    let is = match status {
                        crate::StakerStatus::Validator => {
                            <Pallet<
                                T,
                            >>::validate(
                                T::RuntimeOrigin::from(Some(stash.clone()).into()),
                                Default::default(),
                            )
                        }
                        crate::StakerStatus::Nominator(votes) => {
                            <Pallet<
                                T,
                            >>::nominate(
                                T::RuntimeOrigin::from(Some(stash.clone()).into()),
                                votes
                                    .iter()
                                    .map(|l| T::Lookup::unlookup(l.clone()))
                                    .collect(),
                            )
                        }
                        _ => Ok(()),
                    };
                    match is {
                        Ok(_) => {}
                        _ => {
                            if !false {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!("Expected Ok(_). Got {0:#?}", is),
                                    );
                                }
                            }
                        }
                    };
                    if !(ValidatorCount::<T>::get()
                        <= <T::ElectionProvider as ElectionProviderBase>::MaxWinners::get())
                    {
                        ::core::panicking::panic(
                            "assertion failed: ValidatorCount::<T>::get() <=\n    <T::ElectionProvider as ElectionProviderBase>::MaxWinners::get()",
                        )
                    }
                }
                match (
                    &T::VoterList::count(),
                    &(Nominators::<T>::count() + Validators::<T>::count()),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::Some(
                                    format_args!(
                                        "not all genesis stakers were inserted into sorted list provider, something is wrong.",
                                    ),
                                ),
                            );
                        }
                    }
                };
            }
        }
        ///The `Event` enum of this pallet
        #[scale_info(skip_type_params(T), capture_docs = "always")]
        pub enum Event<T: Config> {
            /// The era payout has been set; the first balance is the validator-payout; the second is
            /// the remainder from the maximum amount of reward.
            EraPaid {
                era_index: EraIndex,
                validator_payout: BalanceOf<T>,
                remainder: BalanceOf<T>,
            },
            /// The nominator has been rewarded by this amount to this destination.
            Rewarded {
                stash: T::AccountId,
                dest: RewardDestination<T::AccountId>,
                amount: BalanceOf<T>,
            },
            /// A staker (validator or nominator) has been slashed by the given amount.
            Slashed { staker: T::AccountId, amount: BalanceOf<T> },
            /// A slash for the given validator, for the given percentage of their stake, at the given
            /// era as been reported.
            SlashReported {
                validator: T::AccountId,
                fraction: Perbill,
                slash_era: EraIndex,
            },
            /// An old slashing report from a prior era was discarded because it could
            /// not be processed.
            OldSlashingReportDiscarded { session_index: SessionIndex },
            /// A new set of stakers was elected.
            StakersElected,
            /// An account has bonded this amount. \[stash, amount\]
            ///
            /// NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,
            /// it will not be emitted for staking rewards when they are added to stake.
            Bonded { stash: T::AccountId, amount: BalanceOf<T> },
            /// An account has unbonded this amount.
            Unbonded { stash: T::AccountId, amount: BalanceOf<T> },
            /// An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`
            /// from the unlocking queue.
            Withdrawn { stash: T::AccountId, amount: BalanceOf<T> },
            /// A nominator has been kicked from a validator.
            Kicked { nominator: T::AccountId, stash: T::AccountId },
            /// The election failed. No new era is planned.
            StakingElectionFailed,
            /// An account has stopped participating as either a validator or nominator.
            Chilled { stash: T::AccountId },
            /// The stakers' rewards are getting paid.
            PayoutStarted { era_index: EraIndex, validator_stash: T::AccountId },
            /// A validator has set their preferences.
            ValidatorPrefsSet { stash: T::AccountId, prefs: ValidatorPrefs },
            /// Voters size limit reached.
            SnapshotVotersSizeExceeded { size: u32 },
            /// Targets size limit reached.
            SnapshotTargetsSizeExceeded { size: u32 },
            /// A new force era mode was set.
            ForceEra { mode: Forcing },
            /// Report of a controller batch deprecation.
            ControllerBatchDeprecated { failures: u32 },
            #[doc(hidden)]
            #[codec(skip)]
            __Ignore(::core::marker::PhantomData<(T)>, frame_support::Never),
        }
        const _: () = {
            #[automatically_derived]
            impl<T: Config> ::core::clone::Clone for Event<T> {
                fn clone(&self) -> Self {
                    match self {
                        Self::EraPaid {
                            ref era_index,
                            ref validator_payout,
                            ref remainder,
                        } => {
                            Self::EraPaid {
                                era_index: ::core::clone::Clone::clone(era_index),
                                validator_payout: ::core::clone::Clone::clone(
                                    validator_payout,
                                ),
                                remainder: ::core::clone::Clone::clone(remainder),
                            }
                        }
                        Self::Rewarded { ref stash, ref dest, ref amount } => {
                            Self::Rewarded {
                                stash: ::core::clone::Clone::clone(stash),
                                dest: ::core::clone::Clone::clone(dest),
                                amount: ::core::clone::Clone::clone(amount),
                            }
                        }
                        Self::Slashed { ref staker, ref amount } => {
                            Self::Slashed {
                                staker: ::core::clone::Clone::clone(staker),
                                amount: ::core::clone::Clone::clone(amount),
                            }
                        }
                        Self::SlashReported {
                            ref validator,
                            ref fraction,
                            ref slash_era,
                        } => {
                            Self::SlashReported {
                                validator: ::core::clone::Clone::clone(validator),
                                fraction: ::core::clone::Clone::clone(fraction),
                                slash_era: ::core::clone::Clone::clone(slash_era),
                            }
                        }
                        Self::OldSlashingReportDiscarded { ref session_index } => {
                            Self::OldSlashingReportDiscarded {
                                session_index: ::core::clone::Clone::clone(session_index),
                            }
                        }
                        Self::StakersElected => Self::StakersElected,
                        Self::Bonded { ref stash, ref amount } => {
                            Self::Bonded {
                                stash: ::core::clone::Clone::clone(stash),
                                amount: ::core::clone::Clone::clone(amount),
                            }
                        }
                        Self::Unbonded { ref stash, ref amount } => {
                            Self::Unbonded {
                                stash: ::core::clone::Clone::clone(stash),
                                amount: ::core::clone::Clone::clone(amount),
                            }
                        }
                        Self::Withdrawn { ref stash, ref amount } => {
                            Self::Withdrawn {
                                stash: ::core::clone::Clone::clone(stash),
                                amount: ::core::clone::Clone::clone(amount),
                            }
                        }
                        Self::Kicked { ref nominator, ref stash } => {
                            Self::Kicked {
                                nominator: ::core::clone::Clone::clone(nominator),
                                stash: ::core::clone::Clone::clone(stash),
                            }
                        }
                        Self::StakingElectionFailed => Self::StakingElectionFailed,
                        Self::Chilled { ref stash } => {
                            Self::Chilled {
                                stash: ::core::clone::Clone::clone(stash),
                            }
                        }
                        Self::PayoutStarted { ref era_index, ref validator_stash } => {
                            Self::PayoutStarted {
                                era_index: ::core::clone::Clone::clone(era_index),
                                validator_stash: ::core::clone::Clone::clone(
                                    validator_stash,
                                ),
                            }
                        }
                        Self::ValidatorPrefsSet { ref stash, ref prefs } => {
                            Self::ValidatorPrefsSet {
                                stash: ::core::clone::Clone::clone(stash),
                                prefs: ::core::clone::Clone::clone(prefs),
                            }
                        }
                        Self::SnapshotVotersSizeExceeded { ref size } => {
                            Self::SnapshotVotersSizeExceeded {
                                size: ::core::clone::Clone::clone(size),
                            }
                        }
                        Self::SnapshotTargetsSizeExceeded { ref size } => {
                            Self::SnapshotTargetsSizeExceeded {
                                size: ::core::clone::Clone::clone(size),
                            }
                        }
                        Self::ForceEra { ref mode } => {
                            Self::ForceEra {
                                mode: ::core::clone::Clone::clone(mode),
                            }
                        }
                        Self::ControllerBatchDeprecated { ref failures } => {
                            Self::ControllerBatchDeprecated {
                                failures: ::core::clone::Clone::clone(failures),
                            }
                        }
                        Self::__Ignore(ref _0, ref _1) => {
                            Self::__Ignore(
                                ::core::clone::Clone::clone(_0),
                                ::core::clone::Clone::clone(_1),
                            )
                        }
                    }
                }
            }
        };
        const _: () = {
            impl<T: Config> ::core::cmp::Eq for Event<T> {}
        };
        const _: () = {
            #[automatically_derived]
            impl<T: Config> ::core::cmp::PartialEq for Event<T> {
                fn eq(&self, other: &Self) -> bool {
                    match (self, other) {
                        (
                            Self::EraPaid { era_index, validator_payout, remainder },
                            Self::EraPaid {
                                era_index: _0,
                                validator_payout: _1,
                                remainder: _2,
                            },
                        ) => {
                            true && era_index == _0 && validator_payout == _1
                                && remainder == _2
                        }
                        (
                            Self::Rewarded { stash, dest, amount },
                            Self::Rewarded { stash: _0, dest: _1, amount: _2 },
                        ) => true && stash == _0 && dest == _1 && amount == _2,
                        (
                            Self::Slashed { staker, amount },
                            Self::Slashed { staker: _0, amount: _1 },
                        ) => true && staker == _0 && amount == _1,
                        (
                            Self::SlashReported { validator, fraction, slash_era },
                            Self::SlashReported {
                                validator: _0,
                                fraction: _1,
                                slash_era: _2,
                            },
                        ) => true && validator == _0 && fraction == _1 && slash_era == _2,
                        (
                            Self::OldSlashingReportDiscarded { session_index },
                            Self::OldSlashingReportDiscarded { session_index: _0 },
                        ) => true && session_index == _0,
                        (Self::StakersElected, Self::StakersElected) => true,
                        (
                            Self::Bonded { stash, amount },
                            Self::Bonded { stash: _0, amount: _1 },
                        ) => true && stash == _0 && amount == _1,
                        (
                            Self::Unbonded { stash, amount },
                            Self::Unbonded { stash: _0, amount: _1 },
                        ) => true && stash == _0 && amount == _1,
                        (
                            Self::Withdrawn { stash, amount },
                            Self::Withdrawn { stash: _0, amount: _1 },
                        ) => true && stash == _0 && amount == _1,
                        (
                            Self::Kicked { nominator, stash },
                            Self::Kicked { nominator: _0, stash: _1 },
                        ) => true && nominator == _0 && stash == _1,
                        (Self::StakingElectionFailed, Self::StakingElectionFailed) => {
                            true
                        }
                        (Self::Chilled { stash }, Self::Chilled { stash: _0 }) => {
                            true && stash == _0
                        }
                        (
                            Self::PayoutStarted { era_index, validator_stash },
                            Self::PayoutStarted { era_index: _0, validator_stash: _1 },
                        ) => true && era_index == _0 && validator_stash == _1,
                        (
                            Self::ValidatorPrefsSet { stash, prefs },
                            Self::ValidatorPrefsSet { stash: _0, prefs: _1 },
                        ) => true && stash == _0 && prefs == _1,
                        (
                            Self::SnapshotVotersSizeExceeded { size },
                            Self::SnapshotVotersSizeExceeded { size: _0 },
                        ) => true && size == _0,
                        (
                            Self::SnapshotTargetsSizeExceeded { size },
                            Self::SnapshotTargetsSizeExceeded { size: _0 },
                        ) => true && size == _0,
                        (Self::ForceEra { mode }, Self::ForceEra { mode: _0 }) => {
                            true && mode == _0
                        }
                        (
                            Self::ControllerBatchDeprecated { failures },
                            Self::ControllerBatchDeprecated { failures: _0 },
                        ) => true && failures == _0,
                        (Self::__Ignore(_0, _1), Self::__Ignore(_0_other, _1_other)) => {
                            true && _0 == _0_other && _1 == _1_other
                        }
                        (Self::EraPaid { .. }, Self::Rewarded { .. }) => false,
                        (Self::EraPaid { .. }, Self::Slashed { .. }) => false,
                        (Self::EraPaid { .. }, Self::SlashReported { .. }) => false,
                        (
                            Self::EraPaid { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (Self::EraPaid { .. }, Self::StakersElected { .. }) => false,
                        (Self::EraPaid { .. }, Self::Bonded { .. }) => false,
                        (Self::EraPaid { .. }, Self::Unbonded { .. }) => false,
                        (Self::EraPaid { .. }, Self::Withdrawn { .. }) => false,
                        (Self::EraPaid { .. }, Self::Kicked { .. }) => false,
                        (Self::EraPaid { .. }, Self::StakingElectionFailed { .. }) => {
                            false
                        }
                        (Self::EraPaid { .. }, Self::Chilled { .. }) => false,
                        (Self::EraPaid { .. }, Self::PayoutStarted { .. }) => false,
                        (Self::EraPaid { .. }, Self::ValidatorPrefsSet { .. }) => false,
                        (
                            Self::EraPaid { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::EraPaid { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (Self::EraPaid { .. }, Self::ForceEra { .. }) => false,
                        (
                            Self::EraPaid { .. },
                            Self::ControllerBatchDeprecated { .. },
                        ) => false,
                        (Self::EraPaid { .. }, Self::__Ignore { .. }) => false,
                        (Self::Rewarded { .. }, Self::EraPaid { .. }) => false,
                        (Self::Rewarded { .. }, Self::Slashed { .. }) => false,
                        (Self::Rewarded { .. }, Self::SlashReported { .. }) => false,
                        (
                            Self::Rewarded { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (Self::Rewarded { .. }, Self::StakersElected { .. }) => false,
                        (Self::Rewarded { .. }, Self::Bonded { .. }) => false,
                        (Self::Rewarded { .. }, Self::Unbonded { .. }) => false,
                        (Self::Rewarded { .. }, Self::Withdrawn { .. }) => false,
                        (Self::Rewarded { .. }, Self::Kicked { .. }) => false,
                        (Self::Rewarded { .. }, Self::StakingElectionFailed { .. }) => {
                            false
                        }
                        (Self::Rewarded { .. }, Self::Chilled { .. }) => false,
                        (Self::Rewarded { .. }, Self::PayoutStarted { .. }) => false,
                        (Self::Rewarded { .. }, Self::ValidatorPrefsSet { .. }) => false,
                        (
                            Self::Rewarded { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::Rewarded { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (Self::Rewarded { .. }, Self::ForceEra { .. }) => false,
                        (
                            Self::Rewarded { .. },
                            Self::ControllerBatchDeprecated { .. },
                        ) => false,
                        (Self::Rewarded { .. }, Self::__Ignore { .. }) => false,
                        (Self::Slashed { .. }, Self::EraPaid { .. }) => false,
                        (Self::Slashed { .. }, Self::Rewarded { .. }) => false,
                        (Self::Slashed { .. }, Self::SlashReported { .. }) => false,
                        (
                            Self::Slashed { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (Self::Slashed { .. }, Self::StakersElected { .. }) => false,
                        (Self::Slashed { .. }, Self::Bonded { .. }) => false,
                        (Self::Slashed { .. }, Self::Unbonded { .. }) => false,
                        (Self::Slashed { .. }, Self::Withdrawn { .. }) => false,
                        (Self::Slashed { .. }, Self::Kicked { .. }) => false,
                        (Self::Slashed { .. }, Self::StakingElectionFailed { .. }) => {
                            false
                        }
                        (Self::Slashed { .. }, Self::Chilled { .. }) => false,
                        (Self::Slashed { .. }, Self::PayoutStarted { .. }) => false,
                        (Self::Slashed { .. }, Self::ValidatorPrefsSet { .. }) => false,
                        (
                            Self::Slashed { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::Slashed { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (Self::Slashed { .. }, Self::ForceEra { .. }) => false,
                        (
                            Self::Slashed { .. },
                            Self::ControllerBatchDeprecated { .. },
                        ) => false,
                        (Self::Slashed { .. }, Self::__Ignore { .. }) => false,
                        (Self::SlashReported { .. }, Self::EraPaid { .. }) => false,
                        (Self::SlashReported { .. }, Self::Rewarded { .. }) => false,
                        (Self::SlashReported { .. }, Self::Slashed { .. }) => false,
                        (
                            Self::SlashReported { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (Self::SlashReported { .. }, Self::StakersElected { .. }) => {
                            false
                        }
                        (Self::SlashReported { .. }, Self::Bonded { .. }) => false,
                        (Self::SlashReported { .. }, Self::Unbonded { .. }) => false,
                        (Self::SlashReported { .. }, Self::Withdrawn { .. }) => false,
                        (Self::SlashReported { .. }, Self::Kicked { .. }) => false,
                        (
                            Self::SlashReported { .. },
                            Self::StakingElectionFailed { .. },
                        ) => false,
                        (Self::SlashReported { .. }, Self::Chilled { .. }) => false,
                        (Self::SlashReported { .. }, Self::PayoutStarted { .. }) => false,
                        (Self::SlashReported { .. }, Self::ValidatorPrefsSet { .. }) => {
                            false
                        }
                        (
                            Self::SlashReported { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::SlashReported { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (Self::SlashReported { .. }, Self::ForceEra { .. }) => false,
                        (
                            Self::SlashReported { .. },
                            Self::ControllerBatchDeprecated { .. },
                        ) => false,
                        (Self::SlashReported { .. }, Self::__Ignore { .. }) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::EraPaid { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::Rewarded { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::Slashed { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::SlashReported { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::StakersElected { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::Bonded { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::Unbonded { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::Withdrawn { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::Kicked { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::StakingElectionFailed { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::Chilled { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::PayoutStarted { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::ValidatorPrefsSet { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::ForceEra { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::ControllerBatchDeprecated { .. },
                        ) => false,
                        (
                            Self::OldSlashingReportDiscarded { .. },
                            Self::__Ignore { .. },
                        ) => false,
                        (Self::StakersElected { .. }, Self::EraPaid { .. }) => false,
                        (Self::StakersElected { .. }, Self::Rewarded { .. }) => false,
                        (Self::StakersElected { .. }, Self::Slashed { .. }) => false,
                        (Self::StakersElected { .. }, Self::SlashReported { .. }) => {
                            false
                        }
                        (
                            Self::StakersElected { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (Self::StakersElected { .. }, Self::Bonded { .. }) => false,
                        (Self::StakersElected { .. }, Self::Unbonded { .. }) => false,
                        (Self::StakersElected { .. }, Self::Withdrawn { .. }) => false,
                        (Self::StakersElected { .. }, Self::Kicked { .. }) => false,
                        (
                            Self::StakersElected { .. },
                            Self::StakingElectionFailed { .. },
                        ) => false,
                        (Self::StakersElected { .. }, Self::Chilled { .. }) => false,
                        (Self::StakersElected { .. }, Self::PayoutStarted { .. }) => {
                            false
                        }
                        (Self::StakersElected { .. }, Self::ValidatorPrefsSet { .. }) => {
                            false
                        }
                        (
                            Self::StakersElected { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::StakersElected { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (Self::StakersElected { .. }, Self::ForceEra { .. }) => false,
                        (
                            Self::StakersElected { .. },
                            Self::ControllerBatchDeprecated { .. },
                        ) => false,
                        (Self::StakersElected { .. }, Self::__Ignore { .. }) => false,
                        (Self::Bonded { .. }, Self::EraPaid { .. }) => false,
                        (Self::Bonded { .. }, Self::Rewarded { .. }) => false,
                        (Self::Bonded { .. }, Self::Slashed { .. }) => false,
                        (Self::Bonded { .. }, Self::SlashReported { .. }) => false,
                        (
                            Self::Bonded { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (Self::Bonded { .. }, Self::StakersElected { .. }) => false,
                        (Self::Bonded { .. }, Self::Unbonded { .. }) => false,
                        (Self::Bonded { .. }, Self::Withdrawn { .. }) => false,
                        (Self::Bonded { .. }, Self::Kicked { .. }) => false,
                        (Self::Bonded { .. }, Self::StakingElectionFailed { .. }) => {
                            false
                        }
                        (Self::Bonded { .. }, Self::Chilled { .. }) => false,
                        (Self::Bonded { .. }, Self::PayoutStarted { .. }) => false,
                        (Self::Bonded { .. }, Self::ValidatorPrefsSet { .. }) => false,
                        (
                            Self::Bonded { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::Bonded { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (Self::Bonded { .. }, Self::ForceEra { .. }) => false,
                        (Self::Bonded { .. }, Self::ControllerBatchDeprecated { .. }) => {
                            false
                        }
                        (Self::Bonded { .. }, Self::__Ignore { .. }) => false,
                        (Self::Unbonded { .. }, Self::EraPaid { .. }) => false,
                        (Self::Unbonded { .. }, Self::Rewarded { .. }) => false,
                        (Self::Unbonded { .. }, Self::Slashed { .. }) => false,
                        (Self::Unbonded { .. }, Self::SlashReported { .. }) => false,
                        (
                            Self::Unbonded { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (Self::Unbonded { .. }, Self::StakersElected { .. }) => false,
                        (Self::Unbonded { .. }, Self::Bonded { .. }) => false,
                        (Self::Unbonded { .. }, Self::Withdrawn { .. }) => false,
                        (Self::Unbonded { .. }, Self::Kicked { .. }) => false,
                        (Self::Unbonded { .. }, Self::StakingElectionFailed { .. }) => {
                            false
                        }
                        (Self::Unbonded { .. }, Self::Chilled { .. }) => false,
                        (Self::Unbonded { .. }, Self::PayoutStarted { .. }) => false,
                        (Self::Unbonded { .. }, Self::ValidatorPrefsSet { .. }) => false,
                        (
                            Self::Unbonded { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::Unbonded { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (Self::Unbonded { .. }, Self::ForceEra { .. }) => false,
                        (
                            Self::Unbonded { .. },
                            Self::ControllerBatchDeprecated { .. },
                        ) => false,
                        (Self::Unbonded { .. }, Self::__Ignore { .. }) => false,
                        (Self::Withdrawn { .. }, Self::EraPaid { .. }) => false,
                        (Self::Withdrawn { .. }, Self::Rewarded { .. }) => false,
                        (Self::Withdrawn { .. }, Self::Slashed { .. }) => false,
                        (Self::Withdrawn { .. }, Self::SlashReported { .. }) => false,
                        (
                            Self::Withdrawn { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (Self::Withdrawn { .. }, Self::StakersElected { .. }) => false,
                        (Self::Withdrawn { .. }, Self::Bonded { .. }) => false,
                        (Self::Withdrawn { .. }, Self::Unbonded { .. }) => false,
                        (Self::Withdrawn { .. }, Self::Kicked { .. }) => false,
                        (Self::Withdrawn { .. }, Self::StakingElectionFailed { .. }) => {
                            false
                        }
                        (Self::Withdrawn { .. }, Self::Chilled { .. }) => false,
                        (Self::Withdrawn { .. }, Self::PayoutStarted { .. }) => false,
                        (Self::Withdrawn { .. }, Self::ValidatorPrefsSet { .. }) => false,
                        (
                            Self::Withdrawn { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::Withdrawn { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (Self::Withdrawn { .. }, Self::ForceEra { .. }) => false,
                        (
                            Self::Withdrawn { .. },
                            Self::ControllerBatchDeprecated { .. },
                        ) => false,
                        (Self::Withdrawn { .. }, Self::__Ignore { .. }) => false,
                        (Self::Kicked { .. }, Self::EraPaid { .. }) => false,
                        (Self::Kicked { .. }, Self::Rewarded { .. }) => false,
                        (Self::Kicked { .. }, Self::Slashed { .. }) => false,
                        (Self::Kicked { .. }, Self::SlashReported { .. }) => false,
                        (
                            Self::Kicked { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (Self::Kicked { .. }, Self::StakersElected { .. }) => false,
                        (Self::Kicked { .. }, Self::Bonded { .. }) => false,
                        (Self::Kicked { .. }, Self::Unbonded { .. }) => false,
                        (Self::Kicked { .. }, Self::Withdrawn { .. }) => false,
                        (Self::Kicked { .. }, Self::StakingElectionFailed { .. }) => {
                            false
                        }
                        (Self::Kicked { .. }, Self::Chilled { .. }) => false,
                        (Self::Kicked { .. }, Self::PayoutStarted { .. }) => false,
                        (Self::Kicked { .. }, Self::ValidatorPrefsSet { .. }) => false,
                        (
                            Self::Kicked { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::Kicked { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (Self::Kicked { .. }, Self::ForceEra { .. }) => false,
                        (Self::Kicked { .. }, Self::ControllerBatchDeprecated { .. }) => {
                            false
                        }
                        (Self::Kicked { .. }, Self::__Ignore { .. }) => false,
                        (Self::StakingElectionFailed { .. }, Self::EraPaid { .. }) => {
                            false
                        }
                        (Self::StakingElectionFailed { .. }, Self::Rewarded { .. }) => {
                            false
                        }
                        (Self::StakingElectionFailed { .. }, Self::Slashed { .. }) => {
                            false
                        }
                        (
                            Self::StakingElectionFailed { .. },
                            Self::SlashReported { .. },
                        ) => false,
                        (
                            Self::StakingElectionFailed { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (
                            Self::StakingElectionFailed { .. },
                            Self::StakersElected { .. },
                        ) => false,
                        (Self::StakingElectionFailed { .. }, Self::Bonded { .. }) => {
                            false
                        }
                        (Self::StakingElectionFailed { .. }, Self::Unbonded { .. }) => {
                            false
                        }
                        (Self::StakingElectionFailed { .. }, Self::Withdrawn { .. }) => {
                            false
                        }
                        (Self::StakingElectionFailed { .. }, Self::Kicked { .. }) => {
                            false
                        }
                        (Self::StakingElectionFailed { .. }, Self::Chilled { .. }) => {
                            false
                        }
                        (
                            Self::StakingElectionFailed { .. },
                            Self::PayoutStarted { .. },
                        ) => false,
                        (
                            Self::StakingElectionFailed { .. },
                            Self::ValidatorPrefsSet { .. },
                        ) => false,
                        (
                            Self::StakingElectionFailed { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::StakingElectionFailed { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (Self::StakingElectionFailed { .. }, Self::ForceEra { .. }) => {
                            false
                        }
                        (
                            Self::StakingElectionFailed { .. },
                            Self::ControllerBatchDeprecated { .. },
                        ) => false,
                        (Self::StakingElectionFailed { .. }, Self::__Ignore { .. }) => {
                            false
                        }
                        (Self::Chilled { .. }, Self::EraPaid { .. }) => false,
                        (Self::Chilled { .. }, Self::Rewarded { .. }) => false,
                        (Self::Chilled { .. }, Self::Slashed { .. }) => false,
                        (Self::Chilled { .. }, Self::SlashReported { .. }) => false,
                        (
                            Self::Chilled { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (Self::Chilled { .. }, Self::StakersElected { .. }) => false,
                        (Self::Chilled { .. }, Self::Bonded { .. }) => false,
                        (Self::Chilled { .. }, Self::Unbonded { .. }) => false,
                        (Self::Chilled { .. }, Self::Withdrawn { .. }) => false,
                        (Self::Chilled { .. }, Self::Kicked { .. }) => false,
                        (Self::Chilled { .. }, Self::StakingElectionFailed { .. }) => {
                            false
                        }
                        (Self::Chilled { .. }, Self::PayoutStarted { .. }) => false,
                        (Self::Chilled { .. }, Self::ValidatorPrefsSet { .. }) => false,
                        (
                            Self::Chilled { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::Chilled { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (Self::Chilled { .. }, Self::ForceEra { .. }) => false,
                        (
                            Self::Chilled { .. },
                            Self::ControllerBatchDeprecated { .. },
                        ) => false,
                        (Self::Chilled { .. }, Self::__Ignore { .. }) => false,
                        (Self::PayoutStarted { .. }, Self::EraPaid { .. }) => false,
                        (Self::PayoutStarted { .. }, Self::Rewarded { .. }) => false,
                        (Self::PayoutStarted { .. }, Self::Slashed { .. }) => false,
                        (Self::PayoutStarted { .. }, Self::SlashReported { .. }) => false,
                        (
                            Self::PayoutStarted { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (Self::PayoutStarted { .. }, Self::StakersElected { .. }) => {
                            false
                        }
                        (Self::PayoutStarted { .. }, Self::Bonded { .. }) => false,
                        (Self::PayoutStarted { .. }, Self::Unbonded { .. }) => false,
                        (Self::PayoutStarted { .. }, Self::Withdrawn { .. }) => false,
                        (Self::PayoutStarted { .. }, Self::Kicked { .. }) => false,
                        (
                            Self::PayoutStarted { .. },
                            Self::StakingElectionFailed { .. },
                        ) => false,
                        (Self::PayoutStarted { .. }, Self::Chilled { .. }) => false,
                        (Self::PayoutStarted { .. }, Self::ValidatorPrefsSet { .. }) => {
                            false
                        }
                        (
                            Self::PayoutStarted { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::PayoutStarted { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (Self::PayoutStarted { .. }, Self::ForceEra { .. }) => false,
                        (
                            Self::PayoutStarted { .. },
                            Self::ControllerBatchDeprecated { .. },
                        ) => false,
                        (Self::PayoutStarted { .. }, Self::__Ignore { .. }) => false,
                        (Self::ValidatorPrefsSet { .. }, Self::EraPaid { .. }) => false,
                        (Self::ValidatorPrefsSet { .. }, Self::Rewarded { .. }) => false,
                        (Self::ValidatorPrefsSet { .. }, Self::Slashed { .. }) => false,
                        (Self::ValidatorPrefsSet { .. }, Self::SlashReported { .. }) => {
                            false
                        }
                        (
                            Self::ValidatorPrefsSet { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (Self::ValidatorPrefsSet { .. }, Self::StakersElected { .. }) => {
                            false
                        }
                        (Self::ValidatorPrefsSet { .. }, Self::Bonded { .. }) => false,
                        (Self::ValidatorPrefsSet { .. }, Self::Unbonded { .. }) => false,
                        (Self::ValidatorPrefsSet { .. }, Self::Withdrawn { .. }) => false,
                        (Self::ValidatorPrefsSet { .. }, Self::Kicked { .. }) => false,
                        (
                            Self::ValidatorPrefsSet { .. },
                            Self::StakingElectionFailed { .. },
                        ) => false,
                        (Self::ValidatorPrefsSet { .. }, Self::Chilled { .. }) => false,
                        (Self::ValidatorPrefsSet { .. }, Self::PayoutStarted { .. }) => {
                            false
                        }
                        (
                            Self::ValidatorPrefsSet { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::ValidatorPrefsSet { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (Self::ValidatorPrefsSet { .. }, Self::ForceEra { .. }) => false,
                        (
                            Self::ValidatorPrefsSet { .. },
                            Self::ControllerBatchDeprecated { .. },
                        ) => false,
                        (Self::ValidatorPrefsSet { .. }, Self::__Ignore { .. }) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::EraPaid { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::Rewarded { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::Slashed { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::SlashReported { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::StakersElected { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::Bonded { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::Unbonded { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::Withdrawn { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::Kicked { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::StakingElectionFailed { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::Chilled { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::PayoutStarted { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::ValidatorPrefsSet { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::ForceEra { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::ControllerBatchDeprecated { .. },
                        ) => false,
                        (
                            Self::SnapshotVotersSizeExceeded { .. },
                            Self::__Ignore { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::EraPaid { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::Rewarded { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::Slashed { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::SlashReported { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::StakersElected { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::Bonded { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::Unbonded { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::Withdrawn { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::Kicked { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::StakingElectionFailed { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::Chilled { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::PayoutStarted { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::ValidatorPrefsSet { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::ForceEra { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::ControllerBatchDeprecated { .. },
                        ) => false,
                        (
                            Self::SnapshotTargetsSizeExceeded { .. },
                            Self::__Ignore { .. },
                        ) => false,
                        (Self::ForceEra { .. }, Self::EraPaid { .. }) => false,
                        (Self::ForceEra { .. }, Self::Rewarded { .. }) => false,
                        (Self::ForceEra { .. }, Self::Slashed { .. }) => false,
                        (Self::ForceEra { .. }, Self::SlashReported { .. }) => false,
                        (
                            Self::ForceEra { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (Self::ForceEra { .. }, Self::StakersElected { .. }) => false,
                        (Self::ForceEra { .. }, Self::Bonded { .. }) => false,
                        (Self::ForceEra { .. }, Self::Unbonded { .. }) => false,
                        (Self::ForceEra { .. }, Self::Withdrawn { .. }) => false,
                        (Self::ForceEra { .. }, Self::Kicked { .. }) => false,
                        (Self::ForceEra { .. }, Self::StakingElectionFailed { .. }) => {
                            false
                        }
                        (Self::ForceEra { .. }, Self::Chilled { .. }) => false,
                        (Self::ForceEra { .. }, Self::PayoutStarted { .. }) => false,
                        (Self::ForceEra { .. }, Self::ValidatorPrefsSet { .. }) => false,
                        (
                            Self::ForceEra { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::ForceEra { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (
                            Self::ForceEra { .. },
                            Self::ControllerBatchDeprecated { .. },
                        ) => false,
                        (Self::ForceEra { .. }, Self::__Ignore { .. }) => false,
                        (
                            Self::ControllerBatchDeprecated { .. },
                            Self::EraPaid { .. },
                        ) => false,
                        (
                            Self::ControllerBatchDeprecated { .. },
                            Self::Rewarded { .. },
                        ) => false,
                        (
                            Self::ControllerBatchDeprecated { .. },
                            Self::Slashed { .. },
                        ) => false,
                        (
                            Self::ControllerBatchDeprecated { .. },
                            Self::SlashReported { .. },
                        ) => false,
                        (
                            Self::ControllerBatchDeprecated { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (
                            Self::ControllerBatchDeprecated { .. },
                            Self::StakersElected { .. },
                        ) => false,
                        (Self::ControllerBatchDeprecated { .. }, Self::Bonded { .. }) => {
                            false
                        }
                        (
                            Self::ControllerBatchDeprecated { .. },
                            Self::Unbonded { .. },
                        ) => false,
                        (
                            Self::ControllerBatchDeprecated { .. },
                            Self::Withdrawn { .. },
                        ) => false,
                        (Self::ControllerBatchDeprecated { .. }, Self::Kicked { .. }) => {
                            false
                        }
                        (
                            Self::ControllerBatchDeprecated { .. },
                            Self::StakingElectionFailed { .. },
                        ) => false,
                        (
                            Self::ControllerBatchDeprecated { .. },
                            Self::Chilled { .. },
                        ) => false,
                        (
                            Self::ControllerBatchDeprecated { .. },
                            Self::PayoutStarted { .. },
                        ) => false,
                        (
                            Self::ControllerBatchDeprecated { .. },
                            Self::ValidatorPrefsSet { .. },
                        ) => false,
                        (
                            Self::ControllerBatchDeprecated { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::ControllerBatchDeprecated { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (
                            Self::ControllerBatchDeprecated { .. },
                            Self::ForceEra { .. },
                        ) => false,
                        (
                            Self::ControllerBatchDeprecated { .. },
                            Self::__Ignore { .. },
                        ) => false,
                        (Self::__Ignore { .. }, Self::EraPaid { .. }) => false,
                        (Self::__Ignore { .. }, Self::Rewarded { .. }) => false,
                        (Self::__Ignore { .. }, Self::Slashed { .. }) => false,
                        (Self::__Ignore { .. }, Self::SlashReported { .. }) => false,
                        (
                            Self::__Ignore { .. },
                            Self::OldSlashingReportDiscarded { .. },
                        ) => false,
                        (Self::__Ignore { .. }, Self::StakersElected { .. }) => false,
                        (Self::__Ignore { .. }, Self::Bonded { .. }) => false,
                        (Self::__Ignore { .. }, Self::Unbonded { .. }) => false,
                        (Self::__Ignore { .. }, Self::Withdrawn { .. }) => false,
                        (Self::__Ignore { .. }, Self::Kicked { .. }) => false,
                        (Self::__Ignore { .. }, Self::StakingElectionFailed { .. }) => {
                            false
                        }
                        (Self::__Ignore { .. }, Self::Chilled { .. }) => false,
                        (Self::__Ignore { .. }, Self::PayoutStarted { .. }) => false,
                        (Self::__Ignore { .. }, Self::ValidatorPrefsSet { .. }) => false,
                        (
                            Self::__Ignore { .. },
                            Self::SnapshotVotersSizeExceeded { .. },
                        ) => false,
                        (
                            Self::__Ignore { .. },
                            Self::SnapshotTargetsSizeExceeded { .. },
                        ) => false,
                        (Self::__Ignore { .. }, Self::ForceEra { .. }) => false,
                        (
                            Self::__Ignore { .. },
                            Self::ControllerBatchDeprecated { .. },
                        ) => false,
                    }
                }
            }
        };
        const _: () = {
            #[automatically_derived]
            impl<T: Config> ::core::fmt::Debug for Event<T> {
                fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        Self::EraPaid {
                            ref era_index,
                            ref validator_payout,
                            ref remainder,
                        } => {
                            fmt.debug_struct("Event::EraPaid")
                                .field("era_index", &era_index)
                                .field("validator_payout", &validator_payout)
                                .field("remainder", &remainder)
                                .finish()
                        }
                        Self::Rewarded { ref stash, ref dest, ref amount } => {
                            fmt.debug_struct("Event::Rewarded")
                                .field("stash", &stash)
                                .field("dest", &dest)
                                .field("amount", &amount)
                                .finish()
                        }
                        Self::Slashed { ref staker, ref amount } => {
                            fmt.debug_struct("Event::Slashed")
                                .field("staker", &staker)
                                .field("amount", &amount)
                                .finish()
                        }
                        Self::SlashReported {
                            ref validator,
                            ref fraction,
                            ref slash_era,
                        } => {
                            fmt.debug_struct("Event::SlashReported")
                                .field("validator", &validator)
                                .field("fraction", &fraction)
                                .field("slash_era", &slash_era)
                                .finish()
                        }
                        Self::OldSlashingReportDiscarded { ref session_index } => {
                            fmt.debug_struct("Event::OldSlashingReportDiscarded")
                                .field("session_index", &session_index)
                                .finish()
                        }
                        Self::StakersElected => fmt.write_str("Event::StakersElected"),
                        Self::Bonded { ref stash, ref amount } => {
                            fmt.debug_struct("Event::Bonded")
                                .field("stash", &stash)
                                .field("amount", &amount)
                                .finish()
                        }
                        Self::Unbonded { ref stash, ref amount } => {
                            fmt.debug_struct("Event::Unbonded")
                                .field("stash", &stash)
                                .field("amount", &amount)
                                .finish()
                        }
                        Self::Withdrawn { ref stash, ref amount } => {
                            fmt.debug_struct("Event::Withdrawn")
                                .field("stash", &stash)
                                .field("amount", &amount)
                                .finish()
                        }
                        Self::Kicked { ref nominator, ref stash } => {
                            fmt.debug_struct("Event::Kicked")
                                .field("nominator", &nominator)
                                .field("stash", &stash)
                                .finish()
                        }
                        Self::StakingElectionFailed => {
                            fmt.write_str("Event::StakingElectionFailed")
                        }
                        Self::Chilled { ref stash } => {
                            fmt.debug_struct("Event::Chilled")
                                .field("stash", &stash)
                                .finish()
                        }
                        Self::PayoutStarted { ref era_index, ref validator_stash } => {
                            fmt.debug_struct("Event::PayoutStarted")
                                .field("era_index", &era_index)
                                .field("validator_stash", &validator_stash)
                                .finish()
                        }
                        Self::ValidatorPrefsSet { ref stash, ref prefs } => {
                            fmt.debug_struct("Event::ValidatorPrefsSet")
                                .field("stash", &stash)
                                .field("prefs", &prefs)
                                .finish()
                        }
                        Self::SnapshotVotersSizeExceeded { ref size } => {
                            fmt.debug_struct("Event::SnapshotVotersSizeExceeded")
                                .field("size", &size)
                                .finish()
                        }
                        Self::SnapshotTargetsSizeExceeded { ref size } => {
                            fmt.debug_struct("Event::SnapshotTargetsSizeExceeded")
                                .field("size", &size)
                                .finish()
                        }
                        Self::ForceEra { ref mode } => {
                            fmt.debug_struct("Event::ForceEra")
                                .field("mode", &mode)
                                .finish()
                        }
                        Self::ControllerBatchDeprecated { ref failures } => {
                            fmt.debug_struct("Event::ControllerBatchDeprecated")
                                .field("failures", &failures)
                                .finish()
                        }
                        Self::__Ignore(ref _0, ref _1) => {
                            fmt.debug_tuple("Event::__Ignore")
                                .field(&_0)
                                .field(&_1)
                                .finish()
                        }
                    }
                }
            }
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<T: Config> ::codec::Encode for Event<T>
            where
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                RewardDestination<T::AccountId>: ::codec::Encode,
                RewardDestination<T::AccountId>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
            {
                fn size_hint(&self) -> usize {
                    1_usize
                        + match *self {
                            Event::EraPaid {
                                ref era_index,
                                ref validator_payout,
                                ref remainder,
                            } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(era_index))
                                    .saturating_add(
                                        ::codec::Encode::size_hint(validator_payout),
                                    )
                                    .saturating_add(::codec::Encode::size_hint(remainder))
                            }
                            Event::Rewarded { ref stash, ref dest, ref amount } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(stash))
                                    .saturating_add(::codec::Encode::size_hint(dest))
                                    .saturating_add(::codec::Encode::size_hint(amount))
                            }
                            Event::Slashed { ref staker, ref amount } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(staker))
                                    .saturating_add(::codec::Encode::size_hint(amount))
                            }
                            Event::SlashReported {
                                ref validator,
                                ref fraction,
                                ref slash_era,
                            } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(validator))
                                    .saturating_add(::codec::Encode::size_hint(fraction))
                                    .saturating_add(::codec::Encode::size_hint(slash_era))
                            }
                            Event::OldSlashingReportDiscarded { ref session_index } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(session_index))
                            }
                            Event::StakersElected => 0_usize,
                            Event::Bonded { ref stash, ref amount } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(stash))
                                    .saturating_add(::codec::Encode::size_hint(amount))
                            }
                            Event::Unbonded { ref stash, ref amount } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(stash))
                                    .saturating_add(::codec::Encode::size_hint(amount))
                            }
                            Event::Withdrawn { ref stash, ref amount } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(stash))
                                    .saturating_add(::codec::Encode::size_hint(amount))
                            }
                            Event::Kicked { ref nominator, ref stash } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(nominator))
                                    .saturating_add(::codec::Encode::size_hint(stash))
                            }
                            Event::StakingElectionFailed => 0_usize,
                            Event::Chilled { ref stash } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(stash))
                            }
                            Event::PayoutStarted {
                                ref era_index,
                                ref validator_stash,
                            } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(era_index))
                                    .saturating_add(::codec::Encode::size_hint(validator_stash))
                            }
                            Event::ValidatorPrefsSet { ref stash, ref prefs } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(stash))
                                    .saturating_add(::codec::Encode::size_hint(prefs))
                            }
                            Event::SnapshotVotersSizeExceeded { ref size } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(size))
                            }
                            Event::SnapshotTargetsSizeExceeded { ref size } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(size))
                            }
                            Event::ForceEra { ref mode } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(mode))
                            }
                            Event::ControllerBatchDeprecated { ref failures } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(failures))
                            }
                            _ => 0_usize,
                        }
                }
                fn encode_to<
                    __CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized,
                >(&self, __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    match *self {
                        Event::EraPaid {
                            ref era_index,
                            ref validator_payout,
                            ref remainder,
                        } => {
                            __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(era_index, __codec_dest_edqy);
                            ::codec::Encode::encode_to(
                                validator_payout,
                                __codec_dest_edqy,
                            );
                            ::codec::Encode::encode_to(remainder, __codec_dest_edqy);
                        }
                        Event::Rewarded { ref stash, ref dest, ref amount } => {
                            __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(stash, __codec_dest_edqy);
                            ::codec::Encode::encode_to(dest, __codec_dest_edqy);
                            ::codec::Encode::encode_to(amount, __codec_dest_edqy);
                        }
                        Event::Slashed { ref staker, ref amount } => {
                            __codec_dest_edqy.push_byte(2usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(staker, __codec_dest_edqy);
                            ::codec::Encode::encode_to(amount, __codec_dest_edqy);
                        }
                        Event::SlashReported {
                            ref validator,
                            ref fraction,
                            ref slash_era,
                        } => {
                            __codec_dest_edqy.push_byte(3usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(validator, __codec_dest_edqy);
                            ::codec::Encode::encode_to(fraction, __codec_dest_edqy);
                            ::codec::Encode::encode_to(slash_era, __codec_dest_edqy);
                        }
                        Event::OldSlashingReportDiscarded { ref session_index } => {
                            __codec_dest_edqy.push_byte(4usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(session_index, __codec_dest_edqy);
                        }
                        Event::StakersElected => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(5usize as ::core::primitive::u8);
                        }
                        Event::Bonded { ref stash, ref amount } => {
                            __codec_dest_edqy.push_byte(6usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(stash, __codec_dest_edqy);
                            ::codec::Encode::encode_to(amount, __codec_dest_edqy);
                        }
                        Event::Unbonded { ref stash, ref amount } => {
                            __codec_dest_edqy.push_byte(7usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(stash, __codec_dest_edqy);
                            ::codec::Encode::encode_to(amount, __codec_dest_edqy);
                        }
                        Event::Withdrawn { ref stash, ref amount } => {
                            __codec_dest_edqy.push_byte(8usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(stash, __codec_dest_edqy);
                            ::codec::Encode::encode_to(amount, __codec_dest_edqy);
                        }
                        Event::Kicked { ref nominator, ref stash } => {
                            __codec_dest_edqy.push_byte(9usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(nominator, __codec_dest_edqy);
                            ::codec::Encode::encode_to(stash, __codec_dest_edqy);
                        }
                        Event::StakingElectionFailed => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(10usize as ::core::primitive::u8);
                        }
                        Event::Chilled { ref stash } => {
                            __codec_dest_edqy
                                .push_byte(11usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(stash, __codec_dest_edqy);
                        }
                        Event::PayoutStarted { ref era_index, ref validator_stash } => {
                            __codec_dest_edqy
                                .push_byte(12usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(era_index, __codec_dest_edqy);
                            ::codec::Encode::encode_to(
                                validator_stash,
                                __codec_dest_edqy,
                            );
                        }
                        Event::ValidatorPrefsSet { ref stash, ref prefs } => {
                            __codec_dest_edqy
                                .push_byte(13usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(stash, __codec_dest_edqy);
                            ::codec::Encode::encode_to(prefs, __codec_dest_edqy);
                        }
                        Event::SnapshotVotersSizeExceeded { ref size } => {
                            __codec_dest_edqy
                                .push_byte(14usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(size, __codec_dest_edqy);
                        }
                        Event::SnapshotTargetsSizeExceeded { ref size } => {
                            __codec_dest_edqy
                                .push_byte(15usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(size, __codec_dest_edqy);
                        }
                        Event::ForceEra { ref mode } => {
                            __codec_dest_edqy
                                .push_byte(16usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(mode, __codec_dest_edqy);
                        }
                        Event::ControllerBatchDeprecated { ref failures } => {
                            __codec_dest_edqy
                                .push_byte(17usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(failures, __codec_dest_edqy);
                        }
                        _ => {}
                    }
                }
            }
            #[automatically_derived]
            impl<T: Config> ::codec::EncodeLike for Event<T>
            where
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                RewardDestination<T::AccountId>: ::codec::Encode,
                RewardDestination<T::AccountId>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode,
            {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<T: Config> ::codec::Decode for Event<T>
            where
                BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                RewardDestination<T::AccountId>: ::codec::Decode,
                RewardDestination<T::AccountId>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode,
            {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    match __codec_input_edqy
                        .read_byte()
                        .map_err(|e| {
                            e
                                .chain(
                                    "Could not decode `Event`, failed to read variant byte",
                                )
                        })?
                    {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 0usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<T>::EraPaid {
                                    era_index: {
                                        let __codec_res_edqy = <EraIndex as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::EraPaid::era_index`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    validator_payout: {
                                        let __codec_res_edqy = <BalanceOf<
                                            T,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Event::EraPaid::validator_payout`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    remainder: {
                                        let __codec_res_edqy = <BalanceOf<
                                            T,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::EraPaid::remainder`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 1usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<T>::Rewarded {
                                    stash: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::Rewarded::stash`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    dest: {
                                        let __codec_res_edqy = <RewardDestination<
                                            T::AccountId,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::Rewarded::dest`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    amount: {
                                        let __codec_res_edqy = <BalanceOf<
                                            T,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::Rewarded::amount`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 2usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<T>::Slashed {
                                    staker: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::Slashed::staker`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    amount: {
                                        let __codec_res_edqy = <BalanceOf<
                                            T,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::Slashed::amount`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 3usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<T>::SlashReported {
                                    validator: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain("Could not decode `Event::SlashReported::validator`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    fraction: {
                                        let __codec_res_edqy = <Perbill as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::SlashReported::fraction`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    slash_era: {
                                        let __codec_res_edqy = <EraIndex as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain("Could not decode `Event::SlashReported::slash_era`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 4usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<
                                    T,
                                >::OldSlashingReportDiscarded {
                                    session_index: {
                                        let __codec_res_edqy = <SessionIndex as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Event::OldSlashingReportDiscarded::session_index`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 5usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<T>::StakersElected)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 6usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<T>::Bonded {
                                    stash: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::Bonded::stash`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    amount: {
                                        let __codec_res_edqy = <BalanceOf<
                                            T,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::Bonded::amount`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 7usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<T>::Unbonded {
                                    stash: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::Unbonded::stash`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    amount: {
                                        let __codec_res_edqy = <BalanceOf<
                                            T,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::Unbonded::amount`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 8usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<T>::Withdrawn {
                                    stash: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::Withdrawn::stash`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    amount: {
                                        let __codec_res_edqy = <BalanceOf<
                                            T,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::Withdrawn::amount`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 9usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<T>::Kicked {
                                    nominator: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::Kicked::nominator`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    stash: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::Kicked::stash`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 10usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    Event::<T>::StakingElectionFailed,
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 11usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<T>::Chilled {
                                    stash: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::Chilled::stash`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 12usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<T>::PayoutStarted {
                                    era_index: {
                                        let __codec_res_edqy = <EraIndex as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain("Could not decode `Event::PayoutStarted::era_index`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    validator_stash: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Event::PayoutStarted::validator_stash`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 13usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<T>::ValidatorPrefsSet {
                                    stash: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain("Could not decode `Event::ValidatorPrefsSet::stash`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    prefs: {
                                        let __codec_res_edqy = <ValidatorPrefs as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain("Could not decode `Event::ValidatorPrefsSet::prefs`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 14usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<
                                    T,
                                >::SnapshotVotersSizeExceeded {
                                    size: {
                                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Event::SnapshotVotersSizeExceeded::size`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 15usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<
                                    T,
                                >::SnapshotTargetsSizeExceeded {
                                    size: {
                                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Event::SnapshotTargetsSizeExceeded::size`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 16usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<T>::ForceEra {
                                    mode: {
                                        let __codec_res_edqy = <Forcing as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Event::ForceEra::mode`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 17usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Event::<
                                    T,
                                >::ControllerBatchDeprecated {
                                    failures: {
                                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Event::ControllerBatchDeprecated::failures`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        _ => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Err(
                                    <_ as ::core::convert::Into<
                                        _,
                                    >>::into("Could not decode `Event`, variant doesn't exist"),
                                )
                            })();
                        }
                    }
                }
            }
        };
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            impl<T: Config> ::scale_info::TypeInfo for Event<T>
            where
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                RewardDestination<T::AccountId>: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                ::core::marker::PhantomData<(T)>: ::scale_info::TypeInfo + 'static,
                T: Config + 'static,
            {
                type Identity = Self;
                fn type_info() -> ::scale_info::Type {
                    ::scale_info::Type::builder()
                        .path(
                            ::scale_info::Path::new_with_replace(
                                "Event",
                                "pallet_staking::pallet::pallet",
                                &[],
                            ),
                        )
                        .type_params(
                            <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    ::scale_info::TypeParameter::new(
                                        "T",
                                        ::core::option::Option::None,
                                    ),
                                ]),
                            ),
                        )
                        .docs_always(&["The `Event` enum of this pallet"])
                        .variant(
                            ::scale_info::build::Variants::new()
                                .variant(
                                    "EraPaid",
                                    |v| {
                                        v
                                            .index(0usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f.ty::<EraIndex>().name("era_index").type_name("EraIndex")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<BalanceOf<T>>()
                                                            .name("validator_payout")
                                                            .type_name("BalanceOf<T>")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<BalanceOf<T>>()
                                                            .name("remainder")
                                                            .type_name("BalanceOf<T>")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "The era payout has been set; the first balance is the validator-payout; the second is",
                                                    "the remainder from the maximum amount of reward.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "Rewarded",
                                    |v| {
                                        v
                                            .index(1usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("stash")
                                                            .type_name("T::AccountId")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<RewardDestination<T::AccountId>>()
                                                            .name("dest")
                                                            .type_name("RewardDestination<T::AccountId>")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<BalanceOf<T>>()
                                                            .name("amount")
                                                            .type_name("BalanceOf<T>")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "The nominator has been rewarded by this amount to this destination.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "Slashed",
                                    |v| {
                                        v
                                            .index(2usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("staker")
                                                            .type_name("T::AccountId")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<BalanceOf<T>>()
                                                            .name("amount")
                                                            .type_name("BalanceOf<T>")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "A staker (validator or nominator) has been slashed by the given amount.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "SlashReported",
                                    |v| {
                                        v
                                            .index(3usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("validator")
                                                            .type_name("T::AccountId")
                                                    })
                                                    .field(|f| {
                                                        f.ty::<Perbill>().name("fraction").type_name("Perbill")
                                                    })
                                                    .field(|f| {
                                                        f.ty::<EraIndex>().name("slash_era").type_name("EraIndex")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "A slash for the given validator, for the given percentage of their stake, at the given",
                                                    "era as been reported.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "OldSlashingReportDiscarded",
                                    |v| {
                                        v
                                            .index(4usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<SessionIndex>()
                                                            .name("session_index")
                                                            .type_name("SessionIndex")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "An old slashing report from a prior era was discarded because it could",
                                                    "not be processed.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "StakersElected",
                                    |v| {
                                        v
                                            .index(5usize as ::core::primitive::u8)
                                            .docs_always(&["A new set of stakers was elected."])
                                    },
                                )
                                .variant(
                                    "Bonded",
                                    |v| {
                                        v
                                            .index(6usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("stash")
                                                            .type_name("T::AccountId")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<BalanceOf<T>>()
                                                            .name("amount")
                                                            .type_name("BalanceOf<T>")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "An account has bonded this amount. \\[stash, amount\\]",
                                                    "",
                                                    "NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,",
                                                    "it will not be emitted for staking rewards when they are added to stake.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "Unbonded",
                                    |v| {
                                        v
                                            .index(7usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("stash")
                                                            .type_name("T::AccountId")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<BalanceOf<T>>()
                                                            .name("amount")
                                                            .type_name("BalanceOf<T>")
                                                    }),
                                            )
                                            .docs_always(&["An account has unbonded this amount."])
                                    },
                                )
                                .variant(
                                    "Withdrawn",
                                    |v| {
                                        v
                                            .index(8usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("stash")
                                                            .type_name("T::AccountId")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<BalanceOf<T>>()
                                                            .name("amount")
                                                            .type_name("BalanceOf<T>")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`",
                                                    "from the unlocking queue.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "Kicked",
                                    |v| {
                                        v
                                            .index(9usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("nominator")
                                                            .type_name("T::AccountId")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("stash")
                                                            .type_name("T::AccountId")
                                                    }),
                                            )
                                            .docs_always(
                                                &["A nominator has been kicked from a validator."],
                                            )
                                    },
                                )
                                .variant(
                                    "StakingElectionFailed",
                                    |v| {
                                        v
                                            .index(10usize as ::core::primitive::u8)
                                            .docs_always(
                                                &["The election failed. No new era is planned."],
                                            )
                                    },
                                )
                                .variant(
                                    "Chilled",
                                    |v| {
                                        v
                                            .index(11usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("stash")
                                                            .type_name("T::AccountId")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "An account has stopped participating as either a validator or nominator.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "PayoutStarted",
                                    |v| {
                                        v
                                            .index(12usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f.ty::<EraIndex>().name("era_index").type_name("EraIndex")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("validator_stash")
                                                            .type_name("T::AccountId")
                                                    }),
                                            )
                                            .docs_always(&["The stakers' rewards are getting paid."])
                                    },
                                )
                                .variant(
                                    "ValidatorPrefsSet",
                                    |v| {
                                        v
                                            .index(13usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("stash")
                                                            .type_name("T::AccountId")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<ValidatorPrefs>()
                                                            .name("prefs")
                                                            .type_name("ValidatorPrefs")
                                                    }),
                                            )
                                            .docs_always(&["A validator has set their preferences."])
                                    },
                                )
                                .variant(
                                    "SnapshotVotersSizeExceeded",
                                    |v| {
                                        v
                                            .index(14usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| f.ty::<u32>().name("size").type_name("u32")),
                                            )
                                            .docs_always(&["Voters size limit reached."])
                                    },
                                )
                                .variant(
                                    "SnapshotTargetsSizeExceeded",
                                    |v| {
                                        v
                                            .index(15usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| f.ty::<u32>().name("size").type_name("u32")),
                                            )
                                            .docs_always(&["Targets size limit reached."])
                                    },
                                )
                                .variant(
                                    "ForceEra",
                                    |v| {
                                        v
                                            .index(16usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f.ty::<Forcing>().name("mode").type_name("Forcing")
                                                    }),
                                            )
                                            .docs_always(&["A new force era mode was set."])
                                    },
                                )
                                .variant(
                                    "ControllerBatchDeprecated",
                                    |v| {
                                        v
                                            .index(17usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| f.ty::<u32>().name("failures").type_name("u32")),
                                            )
                                            .docs_always(&["Report of a controller batch deprecation."])
                                    },
                                ),
                        )
                }
            }
        };
        #[scale_info(skip_type_params(T), capture_docs = "always")]
        ///The `Error` enum of this pallet.
        pub enum Error<T> {
            #[doc(hidden)]
            #[codec(skip)]
            __Ignore(core::marker::PhantomData<(T)>, frame_support::Never),
            /// Not a controller account.
            NotController,
            /// Not a stash account.
            NotStash,
            /// Stash is already bonded.
            AlreadyBonded,
            /// Controller is already paired.
            AlreadyPaired,
            /// Targets cannot be empty.
            EmptyTargets,
            /// Duplicate index.
            DuplicateIndex,
            /// Slash record index out of bounds.
            InvalidSlashIndex,
            /// Cannot have a validator or nominator role, with value less than the minimum defined by
            /// governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
            /// intention, `chill` first to remove one's role as validator/nominator.
            InsufficientBond,
            /// Can not schedule more unlock chunks.
            NoMoreChunks,
            /// Can not rebond without unlocking chunks.
            NoUnlockChunk,
            /// Attempting to target a stash that still has funds.
            FundedTarget,
            /// Invalid era to reward.
            InvalidEraToReward,
            /// Invalid number of nominations.
            InvalidNumberOfNominations,
            /// Items are not sorted and unique.
            NotSortedAndUnique,
            /// Rewards for this era have already been claimed for this validator.
            AlreadyClaimed,
            /// No nominators exist on this page.
            InvalidPage,
            /// Incorrect previous history depth input provided.
            IncorrectHistoryDepth,
            /// Incorrect number of slashing spans provided.
            IncorrectSlashingSpans,
            /// Internal state has become somehow corrupted and the operation cannot continue.
            BadState,
            /// Too many nomination targets supplied.
            TooManyTargets,
            /// A nomination target was supplied that was blocked or otherwise not a validator.
            BadTarget,
            /// The user has enough bond and thus cannot be chilled forcefully by an external person.
            CannotChillOther,
            /// There are too many nominators in the system. Governance needs to adjust the staking
            /// settings to keep things safe for the runtime.
            TooManyNominators,
            /// There are too many validator candidates in the system. Governance needs to adjust the
            /// staking settings to keep things safe for the runtime.
            TooManyValidators,
            /// Commission is too low. Must be at least `MinCommission`.
            CommissionTooLow,
            /// Some bound is not met.
            BoundNotMet,
            /// Used when attempting to use deprecated controller account logic.
            ControllerDeprecated,
            /// Cannot reset a ledger.
            CannotRestoreLedger,
            /// Provided reward destination is not allowed.
            RewardDestinationRestricted,
            /// Not enough funds available to withdraw.
            NotEnoughFunds,
            /// Operation not allowed for virtual stakers.
            VirtualStakerNotAllowed,
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<T> ::codec::Encode for Error<T> {
                fn size_hint(&self) -> usize {
                    1_usize
                        + match *self {
                            Error::NotController => 0_usize,
                            Error::NotStash => 0_usize,
                            Error::AlreadyBonded => 0_usize,
                            Error::AlreadyPaired => 0_usize,
                            Error::EmptyTargets => 0_usize,
                            Error::DuplicateIndex => 0_usize,
                            Error::InvalidSlashIndex => 0_usize,
                            Error::InsufficientBond => 0_usize,
                            Error::NoMoreChunks => 0_usize,
                            Error::NoUnlockChunk => 0_usize,
                            Error::FundedTarget => 0_usize,
                            Error::InvalidEraToReward => 0_usize,
                            Error::InvalidNumberOfNominations => 0_usize,
                            Error::NotSortedAndUnique => 0_usize,
                            Error::AlreadyClaimed => 0_usize,
                            Error::InvalidPage => 0_usize,
                            Error::IncorrectHistoryDepth => 0_usize,
                            Error::IncorrectSlashingSpans => 0_usize,
                            Error::BadState => 0_usize,
                            Error::TooManyTargets => 0_usize,
                            Error::BadTarget => 0_usize,
                            Error::CannotChillOther => 0_usize,
                            Error::TooManyNominators => 0_usize,
                            Error::TooManyValidators => 0_usize,
                            Error::CommissionTooLow => 0_usize,
                            Error::BoundNotMet => 0_usize,
                            Error::ControllerDeprecated => 0_usize,
                            Error::CannotRestoreLedger => 0_usize,
                            Error::RewardDestinationRestricted => 0_usize,
                            Error::NotEnoughFunds => 0_usize,
                            Error::VirtualStakerNotAllowed => 0_usize,
                            _ => 0_usize,
                        }
                }
                fn encode_to<
                    __CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized,
                >(&self, __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    match *self {
                        Error::NotController => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                        }
                        Error::NotStash => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                        }
                        Error::AlreadyBonded => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(2usize as ::core::primitive::u8);
                        }
                        Error::AlreadyPaired => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(3usize as ::core::primitive::u8);
                        }
                        Error::EmptyTargets => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(4usize as ::core::primitive::u8);
                        }
                        Error::DuplicateIndex => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(5usize as ::core::primitive::u8);
                        }
                        Error::InvalidSlashIndex => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(6usize as ::core::primitive::u8);
                        }
                        Error::InsufficientBond => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(7usize as ::core::primitive::u8);
                        }
                        Error::NoMoreChunks => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(8usize as ::core::primitive::u8);
                        }
                        Error::NoUnlockChunk => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(9usize as ::core::primitive::u8);
                        }
                        Error::FundedTarget => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(10usize as ::core::primitive::u8);
                        }
                        Error::InvalidEraToReward => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(11usize as ::core::primitive::u8);
                        }
                        Error::InvalidNumberOfNominations => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(12usize as ::core::primitive::u8);
                        }
                        Error::NotSortedAndUnique => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(13usize as ::core::primitive::u8);
                        }
                        Error::AlreadyClaimed => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(14usize as ::core::primitive::u8);
                        }
                        Error::InvalidPage => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(15usize as ::core::primitive::u8);
                        }
                        Error::IncorrectHistoryDepth => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(16usize as ::core::primitive::u8);
                        }
                        Error::IncorrectSlashingSpans => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(17usize as ::core::primitive::u8);
                        }
                        Error::BadState => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(18usize as ::core::primitive::u8);
                        }
                        Error::TooManyTargets => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(19usize as ::core::primitive::u8);
                        }
                        Error::BadTarget => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(20usize as ::core::primitive::u8);
                        }
                        Error::CannotChillOther => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(21usize as ::core::primitive::u8);
                        }
                        Error::TooManyNominators => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(22usize as ::core::primitive::u8);
                        }
                        Error::TooManyValidators => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(23usize as ::core::primitive::u8);
                        }
                        Error::CommissionTooLow => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(24usize as ::core::primitive::u8);
                        }
                        Error::BoundNotMet => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(25usize as ::core::primitive::u8);
                        }
                        Error::ControllerDeprecated => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(26usize as ::core::primitive::u8);
                        }
                        Error::CannotRestoreLedger => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(27usize as ::core::primitive::u8);
                        }
                        Error::RewardDestinationRestricted => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(28usize as ::core::primitive::u8);
                        }
                        Error::NotEnoughFunds => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(29usize as ::core::primitive::u8);
                        }
                        Error::VirtualStakerNotAllowed => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy
                                .push_byte(30usize as ::core::primitive::u8);
                        }
                        _ => {}
                    }
                }
            }
            #[automatically_derived]
            impl<T> ::codec::EncodeLike for Error<T> {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<T> ::codec::Decode for Error<T> {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    match __codec_input_edqy
                        .read_byte()
                        .map_err(|e| {
                            e
                                .chain(
                                    "Could not decode `Error`, failed to read variant byte",
                                )
                        })?
                    {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 0usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::NotController)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 1usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::NotStash)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 2usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::AlreadyBonded)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 3usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::AlreadyPaired)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 4usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::EmptyTargets)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 5usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::DuplicateIndex)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 6usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::InvalidSlashIndex)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 7usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::InsufficientBond)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 8usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::NoMoreChunks)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 9usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::NoUnlockChunk)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 10usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::FundedTarget)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 11usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::InvalidEraToReward)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 12usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    Error::<T>::InvalidNumberOfNominations,
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 13usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::NotSortedAndUnique)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 14usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::AlreadyClaimed)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 15usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::InvalidPage)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 16usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    Error::<T>::IncorrectHistoryDepth,
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 17usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    Error::<T>::IncorrectSlashingSpans,
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 18usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::BadState)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 19usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::TooManyTargets)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 20usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::BadTarget)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 21usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::CannotChillOther)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 22usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::TooManyNominators)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 23usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::TooManyValidators)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 24usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::CommissionTooLow)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 25usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::BoundNotMet)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 26usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::ControllerDeprecated)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 27usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::CannotRestoreLedger)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 28usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    Error::<T>::RewardDestinationRestricted,
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 29usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Error::<T>::NotEnoughFunds)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 30usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    Error::<T>::VirtualStakerNotAllowed,
                                )
                            })();
                        }
                        _ => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Err(
                                    <_ as ::core::convert::Into<
                                        _,
                                    >>::into("Could not decode `Error`, variant doesn't exist"),
                                )
                            })();
                        }
                    }
                }
            }
        };
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            impl<T> ::scale_info::TypeInfo for Error<T>
            where
                core::marker::PhantomData<(T)>: ::scale_info::TypeInfo + 'static,
                T: 'static,
            {
                type Identity = Self;
                fn type_info() -> ::scale_info::Type {
                    ::scale_info::Type::builder()
                        .path(
                            ::scale_info::Path::new_with_replace(
                                "Error",
                                "pallet_staking::pallet::pallet",
                                &[],
                            ),
                        )
                        .type_params(
                            <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    ::scale_info::TypeParameter::new(
                                        "T",
                                        ::core::option::Option::None,
                                    ),
                                ]),
                            ),
                        )
                        .docs_always(&["The `Error` enum of this pallet."])
                        .variant(
                            ::scale_info::build::Variants::new()
                                .variant(
                                    "NotController",
                                    |v| {
                                        v
                                            .index(0usize as ::core::primitive::u8)
                                            .docs_always(&["Not a controller account."])
                                    },
                                )
                                .variant(
                                    "NotStash",
                                    |v| {
                                        v
                                            .index(1usize as ::core::primitive::u8)
                                            .docs_always(&["Not a stash account."])
                                    },
                                )
                                .variant(
                                    "AlreadyBonded",
                                    |v| {
                                        v
                                            .index(2usize as ::core::primitive::u8)
                                            .docs_always(&["Stash is already bonded."])
                                    },
                                )
                                .variant(
                                    "AlreadyPaired",
                                    |v| {
                                        v
                                            .index(3usize as ::core::primitive::u8)
                                            .docs_always(&["Controller is already paired."])
                                    },
                                )
                                .variant(
                                    "EmptyTargets",
                                    |v| {
                                        v
                                            .index(4usize as ::core::primitive::u8)
                                            .docs_always(&["Targets cannot be empty."])
                                    },
                                )
                                .variant(
                                    "DuplicateIndex",
                                    |v| {
                                        v
                                            .index(5usize as ::core::primitive::u8)
                                            .docs_always(&["Duplicate index."])
                                    },
                                )
                                .variant(
                                    "InvalidSlashIndex",
                                    |v| {
                                        v
                                            .index(6usize as ::core::primitive::u8)
                                            .docs_always(&["Slash record index out of bounds."])
                                    },
                                )
                                .variant(
                                    "InsufficientBond",
                                    |v| {
                                        v
                                            .index(7usize as ::core::primitive::u8)
                                            .docs_always(
                                                &[
                                                    "Cannot have a validator or nominator role, with value less than the minimum defined by",
                                                    "governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the",
                                                    "intention, `chill` first to remove one's role as validator/nominator.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "NoMoreChunks",
                                    |v| {
                                        v
                                            .index(8usize as ::core::primitive::u8)
                                            .docs_always(&["Can not schedule more unlock chunks."])
                                    },
                                )
                                .variant(
                                    "NoUnlockChunk",
                                    |v| {
                                        v
                                            .index(9usize as ::core::primitive::u8)
                                            .docs_always(&["Can not rebond without unlocking chunks."])
                                    },
                                )
                                .variant(
                                    "FundedTarget",
                                    |v| {
                                        v
                                            .index(10usize as ::core::primitive::u8)
                                            .docs_always(
                                                &["Attempting to target a stash that still has funds."],
                                            )
                                    },
                                )
                                .variant(
                                    "InvalidEraToReward",
                                    |v| {
                                        v
                                            .index(11usize as ::core::primitive::u8)
                                            .docs_always(&["Invalid era to reward."])
                                    },
                                )
                                .variant(
                                    "InvalidNumberOfNominations",
                                    |v| {
                                        v
                                            .index(12usize as ::core::primitive::u8)
                                            .docs_always(&["Invalid number of nominations."])
                                    },
                                )
                                .variant(
                                    "NotSortedAndUnique",
                                    |v| {
                                        v
                                            .index(13usize as ::core::primitive::u8)
                                            .docs_always(&["Items are not sorted and unique."])
                                    },
                                )
                                .variant(
                                    "AlreadyClaimed",
                                    |v| {
                                        v
                                            .index(14usize as ::core::primitive::u8)
                                            .docs_always(
                                                &[
                                                    "Rewards for this era have already been claimed for this validator.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "InvalidPage",
                                    |v| {
                                        v
                                            .index(15usize as ::core::primitive::u8)
                                            .docs_always(&["No nominators exist on this page."])
                                    },
                                )
                                .variant(
                                    "IncorrectHistoryDepth",
                                    |v| {
                                        v
                                            .index(16usize as ::core::primitive::u8)
                                            .docs_always(
                                                &["Incorrect previous history depth input provided."],
                                            )
                                    },
                                )
                                .variant(
                                    "IncorrectSlashingSpans",
                                    |v| {
                                        v
                                            .index(17usize as ::core::primitive::u8)
                                            .docs_always(
                                                &["Incorrect number of slashing spans provided."],
                                            )
                                    },
                                )
                                .variant(
                                    "BadState",
                                    |v| {
                                        v
                                            .index(18usize as ::core::primitive::u8)
                                            .docs_always(
                                                &[
                                                    "Internal state has become somehow corrupted and the operation cannot continue.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "TooManyTargets",
                                    |v| {
                                        v
                                            .index(19usize as ::core::primitive::u8)
                                            .docs_always(&["Too many nomination targets supplied."])
                                    },
                                )
                                .variant(
                                    "BadTarget",
                                    |v| {
                                        v
                                            .index(20usize as ::core::primitive::u8)
                                            .docs_always(
                                                &[
                                                    "A nomination target was supplied that was blocked or otherwise not a validator.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "CannotChillOther",
                                    |v| {
                                        v
                                            .index(21usize as ::core::primitive::u8)
                                            .docs_always(
                                                &[
                                                    "The user has enough bond and thus cannot be chilled forcefully by an external person.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "TooManyNominators",
                                    |v| {
                                        v
                                            .index(22usize as ::core::primitive::u8)
                                            .docs_always(
                                                &[
                                                    "There are too many nominators in the system. Governance needs to adjust the staking",
                                                    "settings to keep things safe for the runtime.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "TooManyValidators",
                                    |v| {
                                        v
                                            .index(23usize as ::core::primitive::u8)
                                            .docs_always(
                                                &[
                                                    "There are too many validator candidates in the system. Governance needs to adjust the",
                                                    "staking settings to keep things safe for the runtime.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "CommissionTooLow",
                                    |v| {
                                        v
                                            .index(24usize as ::core::primitive::u8)
                                            .docs_always(
                                                &[
                                                    "Commission is too low. Must be at least `MinCommission`.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "BoundNotMet",
                                    |v| {
                                        v
                                            .index(25usize as ::core::primitive::u8)
                                            .docs_always(&["Some bound is not met."])
                                    },
                                )
                                .variant(
                                    "ControllerDeprecated",
                                    |v| {
                                        v
                                            .index(26usize as ::core::primitive::u8)
                                            .docs_always(
                                                &[
                                                    "Used when attempting to use deprecated controller account logic.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "CannotRestoreLedger",
                                    |v| {
                                        v
                                            .index(27usize as ::core::primitive::u8)
                                            .docs_always(&["Cannot reset a ledger."])
                                    },
                                )
                                .variant(
                                    "RewardDestinationRestricted",
                                    |v| {
                                        v
                                            .index(28usize as ::core::primitive::u8)
                                            .docs_always(
                                                &["Provided reward destination is not allowed."],
                                            )
                                    },
                                )
                                .variant(
                                    "NotEnoughFunds",
                                    |v| {
                                        v
                                            .index(29usize as ::core::primitive::u8)
                                            .docs_always(&["Not enough funds available to withdraw."])
                                    },
                                )
                                .variant(
                                    "VirtualStakerNotAllowed",
                                    |v| {
                                        v
                                            .index(30usize as ::core::primitive::u8)
                                            .docs_always(
                                                &["Operation not allowed for virtual stakers."],
                                            )
                                    },
                                ),
                        )
                }
            }
        };
        const _: () = {
            impl<T> frame_support::traits::PalletError for Error<T> {
                const MAX_ENCODED_SIZE: usize = 1;
            }
        };
        #[automatically_derived]
        impl<T> ::core::marker::StructuralPartialEq for Error<T> {}
        #[automatically_derived]
        impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Error<T> {
            #[inline]
            fn eq(&self, other: &Error<T>) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            Error::__Ignore(__self_0, __self_1),
                            Error::__Ignore(__arg1_0, __arg1_1),
                        ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                        _ => true,
                    }
            }
        }
        impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
            fn on_initialize(_now: BlockNumberFor<T>) -> Weight {
                T::DbWeight::get().reads(1)
            }
            fn on_finalize(_n: BlockNumberFor<T>) {
                if let Some(mut active_era) = Self::active_era() {
                    if active_era.start.is_none() {
                        let now_as_millis_u64 = T::UnixTime::now()
                            .as_millis()
                            .saturated_into::<u64>();
                        active_era.start = Some(now_as_millis_u64);
                        ActiveEra::<T>::put(active_era);
                    }
                }
            }
            fn integrity_test() {
                match (
                    &MaxNominationsOf::<T>::get(),
                    &<Self as ElectionDataProvider>::MaxVotesPerVoter::get(),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
                if !!MaxNominationsOf::<T>::get().is_zero() {
                    ::core::panicking::panic(
                        "assertion failed: !MaxNominationsOf::<T>::get().is_zero()",
                    )
                }
                if !(<T::ElectionProvider as ElectionProviderBase>::MaxWinners::get()
                    == <T::GenesisElectionProvider as ElectionProviderBase>::MaxWinners::get())
                {
                    ::core::panicking::panic(
                        "assertion failed: <T::ElectionProvider as ElectionProviderBase>::MaxWinners::get() ==\n    <T::GenesisElectionProvider as ElectionProviderBase>::MaxWinners::get()",
                    )
                }
                if !(T::SlashDeferDuration::get() < T::BondingDuration::get()
                    || T::BondingDuration::get() == 0)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "As per documentation, slash defer duration ({0}) should be less than bonding duration ({1}).",
                                T::SlashDeferDuration::get(),
                                T::BondingDuration::get(),
                            ),
                        );
                    }
                }
            }
        }
        impl<T: Config> Pallet<T> {
            /// Take the origin account as a stash and lock up `value` of its balance. `controller` will
            /// be the account that controls it.
            ///
            /// `value` must be more than the `minimum_balance` specified by `T::Currency`.
            ///
            /// The dispatch origin for this call must be _Signed_ by the stash account.
            ///
            /// Emits `Bonded`.
            /// ## Complexity
            /// - Independent of the arguments. Moderate complexity.
            /// - O(1).
            /// - Three extra DB entries.
            ///
            /// NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
            /// unless the `origin` falls below _existential deposit_ (or equal to 0) and gets removed
            /// as dust.
            pub fn bond(
                origin: OriginFor<T>,
                value: BalanceOf<T>,
                payee: RewardDestination<T::AccountId>,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    let stash = ensure_signed(origin)?;
                    if StakingLedger::<
                        T,
                    >::is_bonded(StakingAccount::Stash(stash.clone())) {
                        return Err(Error::<T>::AlreadyBonded.into());
                    }
                    if StakingLedger::<
                        T,
                    >::is_bonded(StakingAccount::Controller(stash.clone())) {
                        return Err(Error::<T>::AlreadyPaired.into());
                    }
                    if value < asset::existential_deposit::<T>() {
                        return Err(Error::<T>::InsufficientBond.into());
                    }
                    frame_system::Pallet::<T>::inc_consumers(&stash)?;
                    let stash_balance = asset::stakeable_balance::<T>(&stash);
                    let value = value.min(stash_balance);
                    Self::deposit_event(Event::<T>::Bonded {
                        stash: stash.clone(),
                        amount: value,
                    });
                    let ledger = StakingLedger::<T>::new(stash.clone(), value);
                    ledger.bond(payee)?;
                    Ok(())
                })
            }
            /// Add some extra amount that have appeared in the stash `free_balance` into the balance up
            /// for staking.
            ///
            /// The dispatch origin for this call must be _Signed_ by the stash, not the controller.
            ///
            /// Use this if there are additional funds in your stash account that you wish to bond.
            /// Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
            /// any limitation on the amount that can be added.
            ///
            /// Emits `Bonded`.
            ///
            /// ## Complexity
            /// - Independent of the arguments. Insignificant complexity.
            /// - O(1).
            pub fn bond_extra(
                origin: OriginFor<T>,
                max_additional: BalanceOf<T>,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    let stash = ensure_signed(origin)?;
                    Self::do_bond_extra(&stash, max_additional)
                })
            }
            /// Schedule a portion of the stash to be unlocked ready for transfer out after the bond
            /// period ends. If this leaves an amount actively bonded less than
            /// [`asset::existential_deposit`], then it is increased to the full amount.
            ///
            /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
            ///
            /// Once the unlock period is done, you can call `withdraw_unbonded` to actually move
            /// the funds out of management ready for transfer.
            ///
            /// No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
            /// can co-exists at the same time. If there are no unlocking chunks slots available
            /// [`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible).
            ///
            /// If a user encounters the `InsufficientBond` error when calling this extrinsic,
            /// they should call `chill` first in order to free up their bonded funds.
            ///
            /// Emits `Unbonded`.
            ///
            /// See also [`Call::withdraw_unbonded`].
            pub fn unbond(
                origin: OriginFor<T>,
                value: BalanceOf<T>,
            ) -> DispatchResultWithPostInfo {
                frame_support::storage::with_storage_layer::<
                    frame_support::dispatch::PostDispatchInfo,
                    frame_support::dispatch::DispatchErrorWithPostInfo,
                    _,
                >(|| {
                    let controller = ensure_signed(origin)?;
                    let unlocking = Self::ledger(Controller(controller.clone()))
                        .map(|l| l.unlocking.len())?;
                    let maybe_withdraw_weight = {
                        if unlocking == T::MaxUnlockingChunks::get() as usize {
                            let real_num_slashing_spans = Self::slashing_spans(
                                    &controller,
                                )
                                .map_or(0, |s| s.iter().count());
                            Some(
                                Self::do_withdraw_unbonded(
                                    &controller,
                                    real_num_slashing_spans as u32,
                                )?,
                            )
                        } else {
                            None
                        }
                    };
                    let mut ledger = Self::ledger(Controller(controller))?;
                    let mut value = value.min(ledger.active);
                    let stash = ledger.stash.clone();
                    {
                        if !(ledger.unlocking.len()
                            < T::MaxUnlockingChunks::get() as usize)
                        {
                            {
                                return Err(Error::<T>::NoMoreChunks.into());
                            };
                        }
                    };
                    if !value.is_zero() {
                        ledger.active -= value;
                        if ledger.active < asset::existential_deposit::<T>() {
                            value += ledger.active;
                            ledger.active = Zero::zero();
                        }
                        let min_active_bond = if Nominators::<T>::contains_key(&stash) {
                            MinNominatorBond::<T>::get()
                        } else if Validators::<T>::contains_key(&stash) {
                            MinValidatorBond::<T>::get()
                        } else {
                            Zero::zero()
                        };
                        {
                            if !(ledger.active >= min_active_bond) {
                                {
                                    return Err(Error::<T>::InsufficientBond.into());
                                };
                            }
                        };
                        let era = Self::current_era()
                            .unwrap_or(0)
                            .defensive_saturating_add(T::BondingDuration::get());
                        if let Some(chunk) = ledger
                            .unlocking
                            .last_mut()
                            .filter(|chunk| chunk.era == era)
                        {
                            chunk.value = chunk.value.defensive_saturating_add(value)
                        } else {
                            ledger
                                .unlocking
                                .try_push(UnlockChunk { value, era })
                                .map_err(|_| Error::<T>::NoMoreChunks)?;
                        };
                        ledger.update()?;
                        if T::VoterList::contains(&stash) {
                            let _ = T::VoterList::on_update(
                                    &stash,
                                    Self::weight_of(&stash),
                                )
                                .defensive();
                        }
                        Self::deposit_event(Event::<T>::Unbonded {
                            stash,
                            amount: value,
                        });
                    }
                    let actual_weight = if let Some(withdraw_weight) = maybe_withdraw_weight {
                        Some(T::WeightInfo::unbond().saturating_add(withdraw_weight))
                    } else {
                        Some(T::WeightInfo::unbond())
                    };
                    Ok(actual_weight.into())
                })
            }
            /// Remove any unlocked chunks from the `unlocking` queue from our management.
            ///
            /// This essentially frees up that balance to be used by the stash account to do whatever
            /// it wants.
            ///
            /// The dispatch origin for this call must be _Signed_ by the controller.
            ///
            /// Emits `Withdrawn`.
            ///
            /// See also [`Call::unbond`].
            ///
            /// ## Parameters
            ///
            /// - `num_slashing_spans` indicates the number of metadata slashing spans to clear when
            /// this call results in a complete removal of all the data related to the stash account.
            /// In this case, the `num_slashing_spans` must be larger or equal to the number of
            /// slashing spans associated with the stash account in the [`SlashingSpans`] storage type,
            /// otherwise the call will fail. The call weight is directly proportional to
            /// `num_slashing_spans`.
            ///
            /// ## Complexity
            /// O(S) where S is the number of slashing spans to remove
            /// NOTE: Weight annotation is the kill scenario, we refund otherwise.
            pub fn withdraw_unbonded(
                origin: OriginFor<T>,
                num_slashing_spans: u32,
            ) -> DispatchResultWithPostInfo {
                frame_support::storage::with_storage_layer::<
                    frame_support::dispatch::PostDispatchInfo,
                    frame_support::dispatch::DispatchErrorWithPostInfo,
                    _,
                >(|| {
                    let controller = ensure_signed(origin)?;
                    let actual_weight = Self::do_withdraw_unbonded(
                        &controller,
                        num_slashing_spans,
                    )?;
                    Ok(Some(actual_weight).into())
                })
            }
            /// Declare the desire to validate for the origin controller.
            ///
            /// Effects will be felt at the beginning of the next era.
            ///
            /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
            pub fn validate(
                origin: OriginFor<T>,
                prefs: ValidatorPrefs,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    let controller = ensure_signed(origin)?;
                    let ledger = Self::ledger(Controller(controller))?;
                    {
                        if !(ledger.active >= MinValidatorBond::<T>::get()) {
                            {
                                return Err(Error::<T>::InsufficientBond.into());
                            };
                        }
                    };
                    let stash = &ledger.stash;
                    {
                        if !(prefs.commission >= MinCommission::<T>::get()) {
                            {
                                return Err(Error::<T>::CommissionTooLow.into());
                            };
                        }
                    };
                    if !Validators::<T>::contains_key(stash) {
                        if let Some(max_validators) = MaxValidatorsCount::<T>::get() {
                            {
                                if !(Validators::<T>::count() < max_validators) {
                                    {
                                        return Err(Error::<T>::TooManyValidators.into());
                                    };
                                }
                            };
                        }
                    }
                    Self::do_remove_nominator(stash);
                    Self::do_add_validator(stash, prefs.clone());
                    Self::deposit_event(Event::<T>::ValidatorPrefsSet {
                        stash: ledger.stash,
                        prefs,
                    });
                    Ok(())
                })
            }
            /// Declare the desire to nominate `targets` for the origin controller.
            ///
            /// Effects will be felt at the beginning of the next era.
            ///
            /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
            ///
            /// ## Complexity
            /// - The transaction's complexity is proportional to the size of `targets` (N)
            /// which is capped at CompactAssignments::LIMIT (T::MaxNominations).
            /// - Both the reads and writes follow a similar pattern.
            pub fn nominate(
                origin: OriginFor<T>,
                targets: Vec<AccountIdLookupOf<T>>,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    let controller = ensure_signed(origin)?;
                    let ledger = Self::ledger(
                        StakingAccount::Controller(controller.clone()),
                    )?;
                    {
                        if !(ledger.active >= MinNominatorBond::<T>::get()) {
                            {
                                return Err(Error::<T>::InsufficientBond.into());
                            };
                        }
                    };
                    let stash = &ledger.stash;
                    if !Nominators::<T>::contains_key(stash) {
                        if let Some(max_nominators) = MaxNominatorsCount::<T>::get() {
                            {
                                if !(Nominators::<T>::count() < max_nominators) {
                                    {
                                        return Err(Error::<T>::TooManyNominators.into());
                                    };
                                }
                            };
                        }
                    }
                    {
                        if !!targets.is_empty() {
                            {
                                return Err(Error::<T>::EmptyTargets.into());
                            };
                        }
                    };
                    {
                        if !(targets.len()
                            <= T::NominationsQuota::get_quota(ledger.active) as usize)
                        {
                            {
                                return Err(Error::<T>::TooManyTargets.into());
                            };
                        }
                    };
                    let old = Nominators::<T>::get(stash)
                        .map_or_else(Vec::new, |x| x.targets.into_inner());
                    let targets: BoundedVec<_, _> = targets
                        .into_iter()
                        .map(|t| T::Lookup::lookup(t).map_err(DispatchError::from))
                        .map(|n| {
                            n.and_then(|n| {
                                if old.contains(&n) || !Validators::<T>::get(&n).blocked {
                                    Ok(n)
                                } else {
                                    Err(Error::<T>::BadTarget.into())
                                }
                            })
                        })
                        .collect::<Result<Vec<_>, _>>()?
                        .try_into()
                        .map_err(|_| Error::<T>::TooManyNominators)?;
                    let nominations = Nominations {
                        targets,
                        submitted_in: Self::current_era().unwrap_or(0),
                        suppressed: false,
                    };
                    Self::do_remove_validator(stash);
                    Self::do_add_nominator(stash, nominations);
                    Ok(())
                })
            }
            /// Declare no desire to either validate or nominate.
            ///
            /// Effects will be felt at the beginning of the next era.
            ///
            /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
            ///
            /// ## Complexity
            /// - Independent of the arguments. Insignificant complexity.
            /// - Contains one read.
            /// - Writes are limited to the `origin` account key.
            pub fn chill(origin: OriginFor<T>) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    let controller = ensure_signed(origin)?;
                    let ledger = Self::ledger(StakingAccount::Controller(controller))?;
                    Self::chill_stash(&ledger.stash);
                    Ok(())
                })
            }
            /// (Re-)set the payment target for a controller.
            ///
            /// Effects will be felt instantly (as soon as this function is completed successfully).
            ///
            /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
            ///
            /// ## Complexity
            /// - O(1)
            /// - Independent of the arguments. Insignificant complexity.
            /// - Contains a limited number of reads.
            /// - Writes are limited to the `origin` account key.
            /// ---------
            pub fn set_payee(
                origin: OriginFor<T>,
                payee: RewardDestination<T::AccountId>,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    let controller = ensure_signed(origin)?;
                    let ledger = Self::ledger(Controller(controller.clone()))?;
                    {
                        if !(payee
                            != { #[allow(deprecated)] RewardDestination::Controller })
                        {
                            {
                                return Err(Error::<T>::ControllerDeprecated.into());
                            };
                        }
                    };
                    let _ = ledger
                        .set_payee(payee)
                        .defensive_proof(
                            "ledger was retrieved from storage, thus its bonded; qed.",
                        )?;
                    Ok(())
                })
            }
            /// (Re-)sets the controller of a stash to the stash itself. This function previously
            /// accepted a `controller` argument to set the controller to an account other than the
            /// stash itself. This functionality has now been removed, now only setting the controller
            /// to the stash, if it is not already.
            ///
            /// Effects will be felt instantly (as soon as this function is completed successfully).
            ///
            /// The dispatch origin for this call must be _Signed_ by the stash, not the controller.
            ///
            /// ## Complexity
            /// O(1)
            /// - Independent of the arguments. Insignificant complexity.
            /// - Contains a limited number of reads.
            /// - Writes are limited to the `origin` account key.
            pub fn set_controller(origin: OriginFor<T>) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    let stash = ensure_signed(origin)?;
                    Self::ledger(StakingAccount::Stash(stash.clone()))
                        .map(|ledger| {
                            let controller = ledger
                                .controller()
                                .defensive_proof(
                                    "Ledger's controller field didn't exist. The controller should have been fetched using StakingLedger.",
                                )
                                .ok_or(Error::<T>::NotController)?;
                            if controller == stash {
                                return Err(Error::<T>::AlreadyPaired.into());
                            }
                            let _ = ledger.set_controller_to_stash()?;
                            Ok(())
                        })?
                })
            }
            /// Sets the ideal number of validators.
            ///
            /// The dispatch origin must be Root.
            ///
            /// ## Complexity
            /// O(1)
            pub fn set_validator_count(
                origin: OriginFor<T>,
                new: u32,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    ensure_root(origin)?;
                    {
                        if !(new
                            <= <T::ElectionProvider as ElectionProviderBase>::MaxWinners::get())
                        {
                            {
                                return Err(Error::<T>::TooManyValidators.into());
                            };
                        }
                    };
                    ValidatorCount::<T>::put(new);
                    Ok(())
                })
            }
            /// Increments the ideal number of validators up to maximum of
            /// `ElectionProviderBase::MaxWinners`.
            ///
            /// The dispatch origin must be Root.
            ///
            /// ## Complexity
            /// Same as [`Self::set_validator_count`].
            pub fn increase_validator_count(
                origin: OriginFor<T>,
                additional: u32,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    ensure_root(origin)?;
                    let old = ValidatorCount::<T>::get();
                    let new = old
                        .checked_add(additional)
                        .ok_or(ArithmeticError::Overflow)?;
                    {
                        if !(new
                            <= <T::ElectionProvider as ElectionProviderBase>::MaxWinners::get())
                        {
                            {
                                return Err(Error::<T>::TooManyValidators.into());
                            };
                        }
                    };
                    ValidatorCount::<T>::put(new);
                    Ok(())
                })
            }
            /// Scale up the ideal number of validators by a factor up to maximum of
            /// `ElectionProviderBase::MaxWinners`.
            ///
            /// The dispatch origin must be Root.
            ///
            /// ## Complexity
            /// Same as [`Self::set_validator_count`].
            pub fn scale_validator_count(
                origin: OriginFor<T>,
                factor: Percent,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    ensure_root(origin)?;
                    let old = ValidatorCount::<T>::get();
                    let new = old
                        .checked_add(factor.mul_floor(old))
                        .ok_or(ArithmeticError::Overflow)?;
                    {
                        if !(new
                            <= <T::ElectionProvider as ElectionProviderBase>::MaxWinners::get())
                        {
                            {
                                return Err(Error::<T>::TooManyValidators.into());
                            };
                        }
                    };
                    ValidatorCount::<T>::put(new);
                    Ok(())
                })
            }
            /// Force there to be no new eras indefinitely.
            ///
            /// The dispatch origin must be Root.
            ///
            /// # Warning
            ///
            /// The election process starts multiple blocks before the end of the era.
            /// Thus the election process may be ongoing when this is called. In this case the
            /// election will continue until the next era is triggered.
            ///
            /// ## Complexity
            /// - No arguments.
            /// - Weight: O(1)
            pub fn force_no_eras(origin: OriginFor<T>) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    ensure_root(origin)?;
                    Self::set_force_era(Forcing::ForceNone);
                    Ok(())
                })
            }
            /// Force there to be a new era at the end of the next session. After this, it will be
            /// reset to normal (non-forced) behaviour.
            ///
            /// The dispatch origin must be Root.
            ///
            /// # Warning
            ///
            /// The election process starts multiple blocks before the end of the era.
            /// If this is called just before a new era is triggered, the election process may not
            /// have enough blocks to get a result.
            ///
            /// ## Complexity
            /// - No arguments.
            /// - Weight: O(1)
            pub fn force_new_era(origin: OriginFor<T>) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    ensure_root(origin)?;
                    Self::set_force_era(Forcing::ForceNew);
                    Ok(())
                })
            }
            /// Set the validators who cannot be slashed (if any).
            ///
            /// The dispatch origin must be Root.
            pub fn set_invulnerables(
                origin: OriginFor<T>,
                invulnerables: Vec<T::AccountId>,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    ensure_root(origin)?;
                    <Invulnerables<T>>::put(invulnerables);
                    Ok(())
                })
            }
            /// Force a current staker to become completely unstaked, immediately.
            ///
            /// The dispatch origin must be Root.
            ///
            /// ## Parameters
            ///
            /// - `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more
            /// details.
            pub fn force_unstake(
                origin: OriginFor<T>,
                stash: T::AccountId,
                num_slashing_spans: u32,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    ensure_root(origin)?;
                    Self::kill_stash(&stash, num_slashing_spans)?;
                    Ok(())
                })
            }
            /// Force there to be a new era at the end of sessions indefinitely.
            ///
            /// The dispatch origin must be Root.
            ///
            /// # Warning
            ///
            /// The election process starts multiple blocks before the end of the era.
            /// If this is called just before a new era is triggered, the election process may not
            /// have enough blocks to get a result.
            pub fn force_new_era_always(origin: OriginFor<T>) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    ensure_root(origin)?;
                    Self::set_force_era(Forcing::ForceAlways);
                    Ok(())
                })
            }
            /// Cancel enactment of a deferred slash.
            ///
            /// Can be called by the `T::AdminOrigin`.
            ///
            /// Parameters: era and indices of the slashes for that era to kill.
            pub fn cancel_deferred_slash(
                origin: OriginFor<T>,
                era: EraIndex,
                slash_indices: Vec<u32>,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    T::AdminOrigin::ensure_origin(origin)?;
                    {
                        if !!slash_indices.is_empty() {
                            {
                                return Err(Error::<T>::EmptyTargets.into());
                            };
                        }
                    };
                    {
                        if !is_sorted_and_unique(&slash_indices) {
                            {
                                return Err(Error::<T>::NotSortedAndUnique.into());
                            };
                        }
                    };
                    let mut unapplied = UnappliedSlashes::<T>::get(&era);
                    let last_item = slash_indices[slash_indices.len() - 1];
                    {
                        if !((last_item as usize) < unapplied.len()) {
                            {
                                return Err(Error::<T>::InvalidSlashIndex.into());
                            };
                        }
                    };
                    for (removed, index) in slash_indices.into_iter().enumerate() {
                        let index = (index as usize) - removed;
                        unapplied.remove(index);
                    }
                    UnappliedSlashes::<T>::insert(&era, &unapplied);
                    Ok(())
                })
            }
            /// Pay out next page of the stakers behind a validator for the given era.
            ///
            /// - `validator_stash` is the stash account of the validator.
            /// - `era` may be any era between `[current_era - history_depth; current_era]`.
            ///
            /// The origin of this call must be _Signed_. Any account can call this function, even if
            /// it is not one of the stakers.
            ///
            /// The reward payout could be paged in case there are too many nominators backing the
            /// `validator_stash`. This call will payout unpaid pages in an ascending order. To claim a
            /// specific page, use `payout_stakers_by_page`.`
            ///
            /// If all pages are claimed, it returns an error `InvalidPage`.
            pub fn payout_stakers(
                origin: OriginFor<T>,
                validator_stash: T::AccountId,
                era: EraIndex,
            ) -> DispatchResultWithPostInfo {
                frame_support::storage::with_storage_layer::<
                    frame_support::dispatch::PostDispatchInfo,
                    frame_support::dispatch::DispatchErrorWithPostInfo,
                    _,
                >(|| {
                    ensure_signed(origin)?;
                    Self::do_payout_stakers(validator_stash, era)
                })
            }
            /// Rebond a portion of the stash scheduled to be unlocked.
            ///
            /// The dispatch origin must be signed by the controller.
            ///
            /// ## Complexity
            /// - Time complexity: O(L), where L is unlocking chunks
            /// - Bounded by `MaxUnlockingChunks`.
            pub fn rebond(
                origin: OriginFor<T>,
                value: BalanceOf<T>,
            ) -> DispatchResultWithPostInfo {
                frame_support::storage::with_storage_layer::<
                    frame_support::dispatch::PostDispatchInfo,
                    frame_support::dispatch::DispatchErrorWithPostInfo,
                    _,
                >(|| {
                    let controller = ensure_signed(origin)?;
                    let ledger = Self::ledger(Controller(controller))?;
                    {
                        if !!ledger.unlocking.is_empty() {
                            {
                                return Err(Error::<T>::NoUnlockChunk.into());
                            };
                        }
                    };
                    let initial_unlocking = ledger.unlocking.len() as u32;
                    let (ledger, rebonded_value) = ledger.rebond(value);
                    {
                        if !(ledger.active >= asset::existential_deposit::<T>()) {
                            {
                                return Err(Error::<T>::InsufficientBond.into());
                            };
                        }
                    };
                    Self::deposit_event(Event::<T>::Bonded {
                        stash: ledger.stash.clone(),
                        amount: rebonded_value,
                    });
                    let stash = ledger.stash.clone();
                    let final_unlocking = ledger.unlocking.len();
                    ledger.update()?;
                    if T::VoterList::contains(&stash) {
                        let _ = T::VoterList::on_update(&stash, Self::weight_of(&stash))
                            .defensive();
                    }
                    let removed_chunks = 1u32
                        .saturating_add(initial_unlocking)
                        .saturating_sub(final_unlocking as u32);
                    Ok(Some(T::WeightInfo::rebond(removed_chunks)).into())
                })
            }
            /// Remove all data structures concerning a staker/stash once it is at a state where it can
            /// be considered `dust` in the staking system. The requirements are:
            ///
            /// 1. the `total_balance` of the stash is below existential deposit.
            /// 2. or, the `ledger.total` of the stash is below existential deposit.
            /// 3. or, existential deposit is zero and either `total_balance` or `ledger.total` is zero.
            ///
            /// The former can happen in cases like a slash; the latter when a fully unbonded account
            /// is still receiving staking rewards in `RewardDestination::Staked`.
            ///
            /// It can be called by anyone, as long as `stash` meets the above requirements.
            ///
            /// Refunds the transaction fees upon successful execution.
            ///
            /// ## Parameters
            ///
            /// - `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more
            /// details.
            pub fn reap_stash(
                origin: OriginFor<T>,
                stash: T::AccountId,
                num_slashing_spans: u32,
            ) -> DispatchResultWithPostInfo {
                frame_support::storage::with_storage_layer::<
                    frame_support::dispatch::PostDispatchInfo,
                    frame_support::dispatch::DispatchErrorWithPostInfo,
                    _,
                >(|| {
                    let _ = ensure_signed(origin)?;
                    {
                        if !!Self::is_virtual_staker(&stash) {
                            {
                                return Err(Error::<T>::VirtualStakerNotAllowed.into());
                            };
                        }
                    };
                    let ed = asset::existential_deposit::<T>();
                    let origin_balance = asset::total_balance::<T>(&stash);
                    let ledger_total = Self::ledger(Stash(stash.clone()))
                        .map(|l| l.total)
                        .unwrap_or_default();
                    let reapable = origin_balance < ed || origin_balance.is_zero()
                        || ledger_total < ed || ledger_total.is_zero();
                    {
                        if !reapable {
                            {
                                return Err(Error::<T>::FundedTarget.into());
                            };
                        }
                    };
                    Self::kill_stash(&stash, num_slashing_spans)?;
                    Ok(Pays::No.into())
                })
            }
            /// Remove the given nominations from the calling validator.
            ///
            /// Effects will be felt at the beginning of the next era.
            ///
            /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
            ///
            /// - `who`: A list of nominator stash accounts who are nominating this validator which
            ///   should no longer be nominating this validator.
            ///
            /// Note: Making this call only makes sense if you first set the validator preferences to
            /// block any further nominations.
            pub fn kick(
                origin: OriginFor<T>,
                who: Vec<AccountIdLookupOf<T>>,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    let controller = ensure_signed(origin)?;
                    let ledger = Self::ledger(Controller(controller))?;
                    let stash = &ledger.stash;
                    for nom_stash in who
                        .into_iter()
                        .map(T::Lookup::lookup)
                        .collect::<Result<Vec<T::AccountId>, _>>()?
                        .into_iter()
                    {
                        Nominators::<
                            T,
                        >::mutate(
                            &nom_stash,
                            |maybe_nom| {
                                if let Some(ref mut nom) = maybe_nom {
                                    if let Some(pos) = nom
                                        .targets
                                        .iter()
                                        .position(|v| v == stash)
                                    {
                                        nom.targets.swap_remove(pos);
                                        Self::deposit_event(Event::<T>::Kicked {
                                            nominator: nom_stash.clone(),
                                            stash: stash.clone(),
                                        });
                                    }
                                }
                            },
                        );
                    }
                    Ok(())
                })
            }
            /// Update the various staking configurations .
            ///
            /// * `min_nominator_bond`: The minimum active bond needed to be a nominator.
            /// * `min_validator_bond`: The minimum active bond needed to be a validator.
            /// * `max_nominator_count`: The max number of users who can be a nominator at once. When
            ///   set to `None`, no limit is enforced.
            /// * `max_validator_count`: The max number of users who can be a validator at once. When
            ///   set to `None`, no limit is enforced.
            /// * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
            ///   should be filled in order for the `chill_other` transaction to work.
            /// * `min_commission`: The minimum amount of commission that each validators must maintain.
            ///   This is checked only upon calling `validate`. Existing validators are not affected.
            ///
            /// RuntimeOrigin must be Root to call this function.
            ///
            /// NOTE: Existing nominators and validators will not be affected by this update.
            /// to kick people under the new limits, `chill_other` should be called.
            pub fn set_staking_configs(
                origin: OriginFor<T>,
                min_nominator_bond: ConfigOp<BalanceOf<T>>,
                min_validator_bond: ConfigOp<BalanceOf<T>>,
                max_nominator_count: ConfigOp<u32>,
                max_validator_count: ConfigOp<u32>,
                chill_threshold: ConfigOp<Percent>,
                min_commission: ConfigOp<Perbill>,
                max_staked_rewards: ConfigOp<Percent>,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    ensure_root(origin)?;
                    match min_nominator_bond {
                        ConfigOp::Noop => {}
                        ConfigOp::Set(v) => <MinNominatorBond<T>>::put(v),
                        ConfigOp::Remove => <MinNominatorBond<T>>::kill(),
                    };
                    match min_validator_bond {
                        ConfigOp::Noop => {}
                        ConfigOp::Set(v) => <MinValidatorBond<T>>::put(v),
                        ConfigOp::Remove => <MinValidatorBond<T>>::kill(),
                    };
                    match max_nominator_count {
                        ConfigOp::Noop => {}
                        ConfigOp::Set(v) => <MaxNominatorsCount<T>>::put(v),
                        ConfigOp::Remove => <MaxNominatorsCount<T>>::kill(),
                    };
                    match max_validator_count {
                        ConfigOp::Noop => {}
                        ConfigOp::Set(v) => <MaxValidatorsCount<T>>::put(v),
                        ConfigOp::Remove => <MaxValidatorsCount<T>>::kill(),
                    };
                    match chill_threshold {
                        ConfigOp::Noop => {}
                        ConfigOp::Set(v) => <ChillThreshold<T>>::put(v),
                        ConfigOp::Remove => <ChillThreshold<T>>::kill(),
                    };
                    match min_commission {
                        ConfigOp::Noop => {}
                        ConfigOp::Set(v) => <MinCommission<T>>::put(v),
                        ConfigOp::Remove => <MinCommission<T>>::kill(),
                    };
                    match max_staked_rewards {
                        ConfigOp::Noop => {}
                        ConfigOp::Set(v) => <MaxStakedRewards<T>>::put(v),
                        ConfigOp::Remove => <MaxStakedRewards<T>>::kill(),
                    };
                    Ok(())
                })
            }
            /// Declare a `controller` to stop participating as either a validator or nominator.
            ///
            /// Effects will be felt at the beginning of the next era.
            ///
            /// The dispatch origin for this call must be _Signed_, but can be called by anyone.
            ///
            /// If the caller is the same as the controller being targeted, then no further checks are
            /// enforced, and this function behaves just like `chill`.
            ///
            /// If the caller is different than the controller being targeted, the following conditions
            /// must be met:
            ///
            /// * `controller` must belong to a nominator who has become non-decodable,
            ///
            /// Or:
            ///
            /// * A `ChillThreshold` must be set and checked which defines how close to the max
            ///   nominators or validators we must reach before users can start chilling one-another.
            /// * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
            ///   how close we are to the threshold.
            /// * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
            ///   if this is a person that should be chilled because they have not met the threshold
            ///   bond required.
            ///
            /// This can be helpful if bond requirements are updated, and we need to remove old users
            /// who do not satisfy these requirements.
            pub fn chill_other(
                origin: OriginFor<T>,
                stash: T::AccountId,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    let caller = ensure_signed(origin)?;
                    let ledger = Self::ledger(Stash(stash.clone()))?;
                    let controller = ledger
                        .controller()
                        .defensive_proof(
                            "Ledger's controller field didn't exist. The controller should have been fetched using StakingLedger.",
                        )
                        .ok_or(Error::<T>::NotController)?;
                    if Nominators::<T>::contains_key(&stash)
                        && Nominators::<T>::get(&stash).is_none()
                    {
                        Self::chill_stash(&stash);
                        return Ok(());
                    }
                    if caller != controller {
                        let threshold = ChillThreshold::<T>::get()
                            .ok_or(Error::<T>::CannotChillOther)?;
                        let min_active_bond = if Nominators::<T>::contains_key(&stash) {
                            let max_nominator_count = MaxNominatorsCount::<T>::get()
                                .ok_or(Error::<T>::CannotChillOther)?;
                            let current_nominator_count = Nominators::<T>::count();
                            {
                                if !(threshold * max_nominator_count
                                    < current_nominator_count)
                                {
                                    {
                                        return Err(Error::<T>::CannotChillOther.into());
                                    };
                                }
                            };
                            MinNominatorBond::<T>::get()
                        } else if Validators::<T>::contains_key(&stash) {
                            let max_validator_count = MaxValidatorsCount::<T>::get()
                                .ok_or(Error::<T>::CannotChillOther)?;
                            let current_validator_count = Validators::<T>::count();
                            {
                                if !(threshold * max_validator_count
                                    < current_validator_count)
                                {
                                    {
                                        return Err(Error::<T>::CannotChillOther.into());
                                    };
                                }
                            };
                            MinValidatorBond::<T>::get()
                        } else {
                            Zero::zero()
                        };
                        {
                            if !(ledger.active < min_active_bond) {
                                {
                                    return Err(Error::<T>::CannotChillOther.into());
                                };
                            }
                        };
                    }
                    Self::chill_stash(&stash);
                    Ok(())
                })
            }
            /// Force a validator to have at least the minimum commission. This will not affect a
            /// validator who already has a commission greater than or equal to the minimum. Any account
            /// can call this.
            pub fn force_apply_min_commission(
                origin: OriginFor<T>,
                validator_stash: T::AccountId,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    ensure_signed(origin)?;
                    let min_commission = MinCommission::<T>::get();
                    Validators::<
                        T,
                    >::try_mutate_exists(
                        validator_stash,
                        |maybe_prefs| {
                            maybe_prefs
                                .as_mut()
                                .map(|prefs| {
                                    (prefs.commission < min_commission)
                                        .then(|| prefs.commission = min_commission)
                                })
                                .ok_or(Error::<T>::NotStash)
                        },
                    )?;
                    Ok(())
                })
            }
            /// Sets the minimum amount of commission that each validators must maintain.
            ///
            /// This call has lower privilege requirements than `set_staking_config` and can be called
            /// by the `T::AdminOrigin`. Root can always call this.
            pub fn set_min_commission(
                origin: OriginFor<T>,
                new: Perbill,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    T::AdminOrigin::ensure_origin(origin)?;
                    MinCommission::<T>::put(new);
                    Ok(())
                })
            }
            /// Pay out a page of the stakers behind a validator for the given era and page.
            ///
            /// - `validator_stash` is the stash account of the validator.
            /// - `era` may be any era between `[current_era - history_depth; current_era]`.
            /// - `page` is the page index of nominators to pay out with value between 0 and
            ///   `num_nominators / T::MaxExposurePageSize`.
            ///
            /// The origin of this call must be _Signed_. Any account can call this function, even if
            /// it is not one of the stakers.
            ///
            /// If a validator has more than [`Config::MaxExposurePageSize`] nominators backing
            /// them, then the list of nominators is paged, with each page being capped at
            /// [`Config::MaxExposurePageSize`.] If a validator has more than one page of nominators,
            /// the call needs to be made for each page separately in order for all the nominators
            /// backing a validator to receive the reward. The nominators are not sorted across pages
            /// and so it should not be assumed the highest staker would be on the topmost page and vice
            /// versa. If rewards are not claimed in [`Config::HistoryDepth`] eras, they are lost.
            pub fn payout_stakers_by_page(
                origin: OriginFor<T>,
                validator_stash: T::AccountId,
                era: EraIndex,
                page: Page,
            ) -> DispatchResultWithPostInfo {
                frame_support::storage::with_storage_layer::<
                    frame_support::dispatch::PostDispatchInfo,
                    frame_support::dispatch::DispatchErrorWithPostInfo,
                    _,
                >(|| {
                    ensure_signed(origin)?;
                    Self::do_payout_stakers_by_page(validator_stash, era, page)
                })
            }
            /// Migrates an account's `RewardDestination::Controller` to
            /// `RewardDestination::Account(controller)`.
            ///
            /// Effects will be felt instantly (as soon as this function is completed successfully).
            ///
            /// This will waive the transaction fee if the `payee` is successfully migrated.
            pub fn update_payee(
                origin: OriginFor<T>,
                controller: T::AccountId,
            ) -> DispatchResultWithPostInfo {
                frame_support::storage::with_storage_layer::<
                    frame_support::dispatch::PostDispatchInfo,
                    frame_support::dispatch::DispatchErrorWithPostInfo,
                    _,
                >(|| {
                    let _ = ensure_signed(origin)?;
                    let ledger = Self::ledger(
                        StakingAccount::Controller(controller.clone()),
                    )?;
                    {
                        if !(Payee::<T>::get(&ledger.stash)
                            == {
                                #[allow(deprecated)] Some(RewardDestination::Controller)
                            })
                        {
                            {
                                return Err(Error::<T>::NotController.into());
                            };
                        }
                    };
                    let _ = ledger
                        .set_payee(RewardDestination::Account(controller))
                        .defensive_proof(
                            "ledger should have been previously retrieved from storage.",
                        )?;
                    Ok(Pays::No.into())
                })
            }
            /// Updates a batch of controller accounts to their corresponding stash account if they are
            /// not the same. Ignores any controller accounts that do not exist, and does not operate if
            /// the stash and controller are already the same.
            ///
            /// Effects will be felt instantly (as soon as this function is completed successfully).
            ///
            /// The dispatch origin must be `T::AdminOrigin`.
            pub fn deprecate_controller_batch(
                origin: OriginFor<T>,
                controllers: BoundedVec<
                    T::AccountId,
                    T::MaxControllersInDeprecationBatch,
                >,
            ) -> DispatchResultWithPostInfo {
                frame_support::storage::with_storage_layer::<
                    frame_support::dispatch::PostDispatchInfo,
                    frame_support::dispatch::DispatchErrorWithPostInfo,
                    _,
                >(|| {
                    T::AdminOrigin::ensure_origin(origin)?;
                    let filtered_batch_with_ledger: Vec<_> = controllers
                        .iter()
                        .filter_map(|controller| {
                            let ledger = Self::ledger(
                                StakingAccount::Controller(controller.clone()),
                            );
                            ledger
                                .ok()
                                .map_or(
                                    None,
                                    |ledger| {
                                        let payee_deprecated = Payee::<T>::get(&ledger.stash)
                                            == {
                                                #[allow(deprecated)] Some(RewardDestination::Controller)
                                            };
                                        if ledger.stash != *controller && !payee_deprecated {
                                            Some(ledger)
                                        } else {
                                            None
                                        }
                                    },
                                )
                        })
                        .collect();
                    let mut failures = 0;
                    for ledger in filtered_batch_with_ledger {
                        let _ = ledger
                            .clone()
                            .set_controller_to_stash()
                            .map_err(|_| failures += 1);
                    }
                    Self::deposit_event(Event::<T>::ControllerBatchDeprecated {
                        failures,
                    });
                    Ok(
                        Some(
                                T::WeightInfo::deprecate_controller_batch(
                                    controllers.len() as u32,
                                ),
                            )
                            .into(),
                    )
                })
            }
            /// Restores the state of a ledger which is in an inconsistent state.
            ///
            /// The requirements to restore a ledger are the following:
            /// * The stash is bonded; or
            /// * The stash is not bonded but it has a staking lock left behind; or
            /// * If the stash has an associated ledger and its state is inconsistent; or
            /// * If the ledger is not corrupted *but* its staking lock is out of sync.
            ///
            /// The `maybe_*` input parameters will overwrite the corresponding data and metadata of the
            /// ledger associated with the stash. If the input parameters are not set, the ledger will
            /// be reset values from on-chain state.
            pub fn restore_ledger(
                origin: OriginFor<T>,
                stash: T::AccountId,
                maybe_controller: Option<T::AccountId>,
                maybe_total: Option<BalanceOf<T>>,
                maybe_unlocking: Option<
                    BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>,
                >,
            ) -> DispatchResult {
                frame_support::storage::with_storage_layer::<
                    (),
                    frame_support::pallet_prelude::DispatchError,
                    _,
                >(|| {
                    T::AdminOrigin::ensure_origin(origin)?;
                    {
                        if !!Self::is_virtual_staker(&stash) {
                            {
                                return Err(Error::<T>::VirtualStakerNotAllowed.into());
                            };
                        }
                    };
                    let current_lock = asset::staked::<T>(&stash);
                    let stash_balance = asset::stakeable_balance::<T>(&stash);
                    let (new_controller, new_total) = match Self::inspect_bond_state(
                        &stash,
                    ) {
                        Ok(LedgerIntegrityState::Corrupted) => {
                            let new_controller = maybe_controller
                                .unwrap_or(stash.clone());
                            let new_total = if let Some(total) = maybe_total {
                                let new_total = total.min(stash_balance);
                                asset::update_stake::<T>(&stash, new_total);
                                new_total
                            } else {
                                current_lock
                            };
                            Ok((new_controller, new_total))
                        }
                        Ok(LedgerIntegrityState::CorruptedKilled) => {
                            if current_lock == Zero::zero() {
                                {
                                    if !maybe_total.is_some() {
                                        {
                                            return Err(Error::<T>::CannotRestoreLedger.into());
                                        };
                                    }
                                };
                                Ok((
                                    stash.clone(),
                                    maybe_total
                                        .expect("total exists as per the check above; qed."),
                                ))
                            } else {
                                Ok((stash.clone(), current_lock))
                            }
                        }
                        Ok(LedgerIntegrityState::LockCorrupted) => {
                            let new_total = maybe_total
                                .ok_or(Error::<T>::CannotRestoreLedger)?
                                .min(stash_balance);
                            asset::update_stake::<T>(&stash, new_total);
                            Ok((stash.clone(), new_total))
                        }
                        Err(Error::<T>::BadState) => {
                            asset::kill_stake::<T>(&stash);
                            {
                                if !(Self::inspect_bond_state(&stash)
                                    == Err(Error::<T>::NotStash))
                                {
                                    {
                                        return Err(Error::<T>::BadState.into());
                                    };
                                }
                            };
                            return Ok(());
                        }
                        Ok(LedgerIntegrityState::Ok) | Err(_) => {
                            Err(Error::<T>::CannotRestoreLedger)
                        }
                    }?;
                    Bonded::<T>::insert(&stash, &new_controller);
                    let mut ledger = StakingLedger::<T>::new(stash.clone(), new_total);
                    ledger.controller = Some(new_controller);
                    ledger.unlocking = maybe_unlocking.unwrap_or_default();
                    ledger.update()?;
                    {
                        if !(Self::inspect_bond_state(&stash)
                            == Ok(LedgerIntegrityState::Ok))
                        {
                            {
                                return Err(Error::<T>::BadState.into());
                            };
                        }
                    };
                    Ok(())
                })
            }
        }
        impl<T: Config> Pallet<T> {
            #[doc(hidden)]
            pub fn pallet_documentation_metadata() -> frame_support::__private::Vec<
                &'static str,
            > {
                ::alloc::vec::Vec::new()
            }
        }
        impl<T: Config> Pallet<T> {
            #[doc(hidden)]
            pub fn pallet_constants_metadata() -> frame_support::__private::Vec<
                frame_support::__private::metadata_ir::PalletConstantMetadataIR,
            > {
                <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        {
                            frame_support::__private::metadata_ir::PalletConstantMetadataIR {
                                name: "HistoryDepth",
                                ty: frame_support::__private::scale_info::meta_type::<
                                    u32,
                                >(),
                                value: {
                                    let value = <<T as Config>::HistoryDepth as frame_support::traits::Get<
                                        u32,
                                    >>::get();
                                    frame_support::__private::codec::Encode::encode(&value)
                                },
                                docs: <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([
                                        " Number of eras to keep in history.",
                                        "",
                                        " Following information is kept for eras in `[current_era -",
                                        " HistoryDepth, current_era]`: `ErasStakers`, `ErasStakersClipped`,",
                                        " `ErasValidatorPrefs`, `ErasValidatorReward`, `ErasRewardPoints`,",
                                        " `ErasTotalStake`, `ErasStartSessionIndex`, `ClaimedRewards`, `ErasStakersPaged`,",
                                        " `ErasStakersOverview`.",
                                        "",
                                        " Must be more than the number of eras delayed by session.",
                                        " I.e. active era must always be in history. I.e. `active_era >",
                                        " current_era - history_depth` must be guaranteed.",
                                        "",
                                        " If migrating an existing pallet from storage value to config value,",
                                        " this should be set to same value or greater as in storage.",
                                        "",
                                        " Note: `HistoryDepth` is used as the upper bound for the `BoundedVec`",
                                        " item `StakingLedger.legacy_claimed_rewards`. Setting this value lower than",
                                        " the existing value can lead to inconsistencies in the",
                                        " `StakingLedger` and will need to be handled properly in a migration.",
                                        " The test `reducing_history_depth_abrupt` shows this effect.",
                                    ]),
                                ),
                                deprecation_info: frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                            }
                        },
                        {
                            frame_support::__private::metadata_ir::PalletConstantMetadataIR {
                                name: "SessionsPerEra",
                                ty: frame_support::__private::scale_info::meta_type::<
                                    SessionIndex,
                                >(),
                                value: {
                                    let value = <<T as Config>::SessionsPerEra as frame_support::traits::Get<
                                        SessionIndex,
                                    >>::get();
                                    frame_support::__private::codec::Encode::encode(&value)
                                },
                                docs: <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([" Number of sessions per era."]),
                                ),
                                deprecation_info: frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                            }
                        },
                        {
                            frame_support::__private::metadata_ir::PalletConstantMetadataIR {
                                name: "BondingDuration",
                                ty: frame_support::__private::scale_info::meta_type::<
                                    EraIndex,
                                >(),
                                value: {
                                    let value = <<T as Config>::BondingDuration as frame_support::traits::Get<
                                        EraIndex,
                                    >>::get();
                                    frame_support::__private::codec::Encode::encode(&value)
                                },
                                docs: <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([
                                        " Number of eras that staked funds must remain bonded for.",
                                    ]),
                                ),
                                deprecation_info: frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                            }
                        },
                        {
                            frame_support::__private::metadata_ir::PalletConstantMetadataIR {
                                name: "SlashDeferDuration",
                                ty: frame_support::__private::scale_info::meta_type::<
                                    EraIndex,
                                >(),
                                value: {
                                    let value = <<T as Config>::SlashDeferDuration as frame_support::traits::Get<
                                        EraIndex,
                                    >>::get();
                                    frame_support::__private::codec::Encode::encode(&value)
                                },
                                docs: <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([
                                        " Number of eras that slashes are deferred by, after computation.",
                                        "",
                                        " This should be less than the bonding duration. Set to 0 if slashes",
                                        " should be applied immediately, without opportunity for intervention.",
                                    ]),
                                ),
                                deprecation_info: frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                            }
                        },
                        {
                            frame_support::__private::metadata_ir::PalletConstantMetadataIR {
                                name: "MaxExposurePageSize",
                                ty: frame_support::__private::scale_info::meta_type::<
                                    u32,
                                >(),
                                value: {
                                    let value = <<T as Config>::MaxExposurePageSize as frame_support::traits::Get<
                                        u32,
                                    >>::get();
                                    frame_support::__private::codec::Encode::encode(&value)
                                },
                                docs: <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([
                                        " The maximum size of each `T::ExposurePage`.",
                                        "",
                                        " An `ExposurePage` is weakly bounded to a maximum of `MaxExposurePageSize`",
                                        " nominators.",
                                        "",
                                        " For older non-paged exposure, a reward payout was restricted to the top",
                                        " `MaxExposurePageSize` nominators. This is to limit the i/o cost for the",
                                        " nominator payout.",
                                        "",
                                        " Note: `MaxExposurePageSize` is used to bound `ClaimedRewards` and is unsafe to reduce",
                                        " without handling it in a migration.",
                                    ]),
                                ),
                                deprecation_info: frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                            }
                        },
                        {
                            frame_support::__private::metadata_ir::PalletConstantMetadataIR {
                                name: "MaxUnlockingChunks",
                                ty: frame_support::__private::scale_info::meta_type::<
                                    u32,
                                >(),
                                value: {
                                    let value = <<T as Config>::MaxUnlockingChunks as frame_support::traits::Get<
                                        u32,
                                    >>::get();
                                    frame_support::__private::codec::Encode::encode(&value)
                                },
                                docs: <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([
                                        " The maximum number of `unlocking` chunks a [`StakingLedger`] can",
                                        " have. Effectively determines how many unique eras a staker may be",
                                        " unbonding in.",
                                        "",
                                        " Note: `MaxUnlockingChunks` is used as the upper bound for the",
                                        " `BoundedVec` item `StakingLedger.unlocking`. Setting this value",
                                        " lower than the existing value can lead to inconsistencies in the",
                                        " `StakingLedger` and will need to be handled properly in a runtime",
                                        " migration. The test `reducing_max_unlocking_chunks_abrupt` shows",
                                        " this effect.",
                                    ]),
                                ),
                                deprecation_info: frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                            }
                        },
                    ]),
                )
            }
        }
        impl<T: Config> Pallet<T> {
            #[doc(hidden)]
            pub fn error_metadata() -> Option<
                frame_support::__private::metadata_ir::PalletErrorMetadataIR,
            > {
                Some(<Error<T>>::error_metadata())
            }
        }
        /// Type alias to `Pallet`, to be used by `construct_runtime`.
        ///
        /// Generated by `pallet` attribute macro.
        #[deprecated(note = "use `Pallet` instead")]
        #[allow(dead_code)]
        pub type Module<T> = Pallet<T>;
        impl<T: Config> frame_support::traits::GetStorageVersion for Pallet<T> {
            type InCodeStorageVersion = frame_support::traits::StorageVersion;
            fn in_code_storage_version() -> Self::InCodeStorageVersion {
                STORAGE_VERSION
            }
            fn on_chain_storage_version() -> frame_support::traits::StorageVersion {
                frame_support::traits::StorageVersion::get::<Self>()
            }
        }
        impl<T: Config> frame_support::traits::OnGenesis for Pallet<T> {
            fn on_genesis() {
                let storage_version: frame_support::traits::StorageVersion = STORAGE_VERSION;
                storage_version.put::<Self>();
            }
        }
        impl<T: Config> frame_support::traits::PalletInfoAccess for Pallet<T> {
            fn index() -> usize {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::index::<
                    Self,
                >()
                    .expect(
                        "Pallet is part of the runtime because pallet `Config` trait is \
						implemented by the runtime",
                    )
            }
            fn name() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Self,
                >()
                    .expect(
                        "Pallet is part of the runtime because pallet `Config` trait is \
						implemented by the runtime",
                    )
            }
            fn name_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Self,
                >()
                    .expect(
                        "Pallet is part of the runtime because pallet `Config` trait is \
						implemented by the runtime",
                    )
            }
            fn module_name() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::module_name::<
                    Self,
                >()
                    .expect(
                        "Pallet is part of the runtime because pallet `Config` trait is \
						implemented by the runtime",
                    )
            }
            fn crate_version() -> frame_support::traits::CrateVersion {
                frame_support::traits::CrateVersion {
                    major: 28u16,
                    minor: 0u8,
                    patch: 0u8,
                }
            }
        }
        impl<T: Config> frame_support::traits::PalletsInfoAccess for Pallet<T> {
            fn count() -> usize {
                1
            }
            fn infos() -> frame_support::__private::Vec<
                frame_support::traits::PalletInfoData,
            > {
                use frame_support::traits::PalletInfoAccess;
                let item = frame_support::traits::PalletInfoData {
                    index: Self::index(),
                    name: Self::name(),
                    module_name: Self::module_name(),
                    crate_version: Self::crate_version(),
                };
                <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([item]))
            }
        }
        impl<T: Config> frame_support::traits::StorageInfoTrait for Pallet<T> {
            fn storage_info() -> frame_support::__private::Vec<
                frame_support::traits::StorageInfo,
            > {
                #[allow(unused_mut)]
                let mut res = ::alloc::vec::Vec::new();
                {
                    let mut storage_info = <ValidatorCount<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <MinimumValidatorCount<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <Invulnerables<
                        T,
                    > as frame_support::traits::PartialStorageInfoTrait>::partial_storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <Bonded<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <MinNominatorBond<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <MinValidatorBond<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <MinimumActiveStake<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <MinCommission<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <Ledger<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <Payee<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <Validators<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <MaxValidatorsCount<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <Nominators<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <VirtualStakers<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <MaxNominatorsCount<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <CurrentEra<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <ActiveEra<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <ErasStartSessionIndex<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <ErasStakers<
                        T,
                    > as frame_support::traits::PartialStorageInfoTrait>::partial_storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <ErasStakersOverview<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <ErasStakersClipped<
                        T,
                    > as frame_support::traits::PartialStorageInfoTrait>::partial_storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <ErasStakersPaged<
                        T,
                    > as frame_support::traits::PartialStorageInfoTrait>::partial_storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <ClaimedRewards<
                        T,
                    > as frame_support::traits::PartialStorageInfoTrait>::partial_storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <ErasValidatorPrefs<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <ErasValidatorReward<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <ErasRewardPoints<
                        T,
                    > as frame_support::traits::PartialStorageInfoTrait>::partial_storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <ErasTotalStake<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <ForceEra<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <MaxStakedRewards<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <SlashRewardFraction<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <CanceledSlashPayout<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <UnappliedSlashes<
                        T,
                    > as frame_support::traits::PartialStorageInfoTrait>::partial_storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <BondedEras<
                        T,
                    > as frame_support::traits::PartialStorageInfoTrait>::partial_storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <ValidatorSlashInEra<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <NominatorSlashInEra<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <SlashingSpans<
                        T,
                    > as frame_support::traits::PartialStorageInfoTrait>::partial_storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <SpanSlash<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <CurrentPlannedSession<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <DisabledValidators<
                        T,
                    > as frame_support::traits::PartialStorageInfoTrait>::partial_storage_info();
                    res.append(&mut storage_info);
                }
                {
                    let mut storage_info = <ChillThreshold<
                        T,
                    > as frame_support::traits::StorageInfoTrait>::storage_info();
                    res.append(&mut storage_info);
                }
                res
            }
        }
        use frame_support::traits::{
            StorageInfoTrait, TrackedStorageKey, WhitelistedStorageKeys,
        };
        impl<T: Config> WhitelistedStorageKeys for Pallet<T> {
            fn whitelisted_storage_keys() -> frame_support::__private::Vec<
                TrackedStorageKey,
            > {
                use frame_support::__private::vec;
                ::alloc::vec::Vec::new()
            }
        }
        impl<T> Pallet<T> {
            #[allow(dead_code)]
            #[doc(hidden)]
            pub fn deprecation_info() -> frame_support::__private::metadata_ir::DeprecationStatusIR {
                frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated
            }
        }
        /// Based on [`Config`]. Auto-generated by
        /// [`#[pallet::config(with_default)]`](`frame_support::pallet_macros::config`).
        /// Can be used in tandem with
        /// [`#[register_default_config]`](`frame_support::register_default_config`) and
        /// [`#[derive_impl]`](`frame_support::derive_impl`) to derive test config traits
        /// based on existing pallet config traits in a safe and developer-friendly way.
        ///
        /// See [here](`frame_support::pallet_macros::config`) for more information and caveats about
        /// the auto-generated `DefaultConfig` trait and how it is generated.
        pub trait DefaultConfig: frame_system::DefaultConfig {
            /// Just the `Currency::Balance` type; we have this item to allow us to constrain it to
            /// `From<u64>`.
            type CurrencyBalance: sp_runtime::traits::AtLeast32BitUnsigned
                + codec::FullCodec
                + Copy
                + MaybeSerializeDeserialize
                + core::fmt::Debug
                + Default
                + From<u64>
                + TypeInfo
                + MaxEncodedLen;
            /// Convert a balance into a number used for election calculation. This must fit into a
            /// `u64` but is allowed to be sensibly lossy. The `u64` is used to communicate with the
            /// [`frame_election_provider_support`] crate which accepts u64 numbers and does operations
            /// in 128.
            /// Consequently, the backward convert is used convert the u128s from sp-elections back to a
            /// [`BalanceOf`].
            type CurrencyToVote;
            /// Something that defines the maximum number of nominations per nominator.
            type NominationsQuota;
            /// Number of eras to keep in history.
            ///
            /// Following information is kept for eras in `[current_era -
            /// HistoryDepth, current_era]`: `ErasStakers`, `ErasStakersClipped`,
            /// `ErasValidatorPrefs`, `ErasValidatorReward`, `ErasRewardPoints`,
            /// `ErasTotalStake`, `ErasStartSessionIndex`, `ClaimedRewards`, `ErasStakersPaged`,
            /// `ErasStakersOverview`.
            ///
            /// Must be more than the number of eras delayed by session.
            /// I.e. active era must always be in history. I.e. `active_era >
            /// current_era - history_depth` must be guaranteed.
            ///
            /// If migrating an existing pallet from storage value to config value,
            /// this should be set to same value or greater as in storage.
            ///
            /// Note: `HistoryDepth` is used as the upper bound for the `BoundedVec`
            /// item `StakingLedger.legacy_claimed_rewards`. Setting this value lower than
            /// the existing value can lead to inconsistencies in the
            /// `StakingLedger` and will need to be handled properly in a migration.
            /// The test `reducing_history_depth_abrupt` shows this effect.
            type HistoryDepth: Get<u32>;
            /// Tokens have been minted and are unused for validator-reward.
            /// See [Era payout](./index.html#era-payout).
            type RewardRemainder;
            /// The overarching event type.
            type RuntimeEvent;
            /// Handler for the unbalanced reduction when slashing a staker.
            type Slash;
            /// Handler for the unbalanced increment when rewarding a staker.
            /// NOTE: in most cases, the implementation of `OnUnbalanced` should modify the total
            /// issuance.
            type Reward;
            /// Number of sessions per era.
            type SessionsPerEra: Get<SessionIndex>;
            /// Number of eras that staked funds must remain bonded for.
            type BondingDuration: Get<EraIndex>;
            /// Number of eras that slashes are deferred by, after computation.
            ///
            /// This should be less than the bonding duration. Set to 0 if slashes
            /// should be applied immediately, without opportunity for intervention.
            type SlashDeferDuration: Get<EraIndex>;
            /// Interface for interacting with a session pallet.
            type SessionInterface: SessionInterface<Self::AccountId>;
            /// Something that can estimate the next session change, accurately or as a best effort
            /// guess.
            type NextNewSession;
            /// The maximum size of each `T::ExposurePage`.
            ///
            /// An `ExposurePage` is weakly bounded to a maximum of `MaxExposurePageSize`
            /// nominators.
            ///
            /// For older non-paged exposure, a reward payout was restricted to the top
            /// `MaxExposurePageSize` nominators. This is to limit the i/o cost for the
            /// nominator payout.
            ///
            /// Note: `MaxExposurePageSize` is used to bound `ClaimedRewards` and is unsafe to reduce
            /// without handling it in a migration.
            type MaxExposurePageSize: Get<u32>;
            /// The maximum number of `unlocking` chunks a [`StakingLedger`] can
            /// have. Effectively determines how many unique eras a staker may be
            /// unbonding in.
            ///
            /// Note: `MaxUnlockingChunks` is used as the upper bound for the
            /// `BoundedVec` item `StakingLedger.unlocking`. Setting this value
            /// lower than the existing value can lead to inconsistencies in the
            /// `StakingLedger` and will need to be handled properly in a runtime
            /// migration. The test `reducing_max_unlocking_chunks_abrupt` shows
            /// this effect.
            type MaxUnlockingChunks: Get<u32>;
            /// The maximum amount of controller accounts that can be deprecated in one call.
            type MaxControllersInDeprecationBatch: Get<u32>;
            /// Something that listens to staking updates and performs actions based on the data it
            /// receives.
            ///
            /// WARNING: this only reports slashing and withdraw events for the time being.
            type EventListeners;
            /// `DisablingStragegy` controls how validators are disabled
            type DisablingStrategy;
            /// Some parameters of the benchmarking.
            #[cfg(feature = "std")]
            type BenchmarkingConfig: BenchmarkingConfig;
            /// Weight information for extrinsics in this pallet.
            type WeightInfo: WeightInfo;
        }
        impl<T: Config> Pallet<T> {
            #[doc(hidden)]
            pub fn pallet_associated_types_metadata() -> frame_support::__private::sp_std::vec::Vec<
                frame_support::__private::metadata_ir::PalletAssociatedTypeMetadataIR,
            > {
                <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        {
                            frame_support::__private::metadata_ir::PalletAssociatedTypeMetadataIR {
                                name: "CurrencyBalance",
                                ty: frame_support::__private::scale_info::meta_type::<
                                    <T as Config>::CurrencyBalance,
                                >(),
                                docs: <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([
                                        " Just the `Currency::Balance` type; we have this item to allow us to constrain it to",
                                        " `From<u64>`.",
                                    ]),
                                ),
                            }
                        },
                    ]),
                )
            }
        }
        #[doc(hidden)]
        mod warnings {}
        #[allow(unused_imports)]
        #[doc(hidden)]
        pub mod __substrate_call_check {
            #[doc(hidden)]
            pub use __is_call_part_defined_0 as is_call_part_defined;
        }
        ///Contains a variant per dispatchable extrinsic that this pallet has.
        #[codec(encode_bound())]
        #[codec(decode_bound())]
        #[scale_info(skip_type_params(T), capture_docs = "always")]
        #[allow(non_camel_case_types)]
        pub enum Call<T: Config> {
            #[doc(hidden)]
            #[codec(skip)]
            __Ignore(::core::marker::PhantomData<(T,)>, frame_support::Never),
            /// Take the origin account as a stash and lock up `value` of its balance. `controller` will
            /// be the account that controls it.
            ///
            /// `value` must be more than the `minimum_balance` specified by `T::Currency`.
            ///
            /// The dispatch origin for this call must be _Signed_ by the stash account.
            ///
            /// Emits `Bonded`.
            /// ## Complexity
            /// - Independent of the arguments. Moderate complexity.
            /// - O(1).
            /// - Three extra DB entries.
            ///
            /// NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
            /// unless the `origin` falls below _existential deposit_ (or equal to 0) and gets removed
            /// as dust.
            #[codec(index = 0u8)]
            bond {
                #[allow(missing_docs)]
                #[codec(compact)]
                value: BalanceOf<T>,
                #[allow(missing_docs)]
                payee: RewardDestination<T::AccountId>,
            },
            /// Add some extra amount that have appeared in the stash `free_balance` into the balance up
            /// for staking.
            ///
            /// The dispatch origin for this call must be _Signed_ by the stash, not the controller.
            ///
            /// Use this if there are additional funds in your stash account that you wish to bond.
            /// Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
            /// any limitation on the amount that can be added.
            ///
            /// Emits `Bonded`.
            ///
            /// ## Complexity
            /// - Independent of the arguments. Insignificant complexity.
            /// - O(1).
            #[codec(index = 1u8)]
            bond_extra {
                #[allow(missing_docs)]
                #[codec(compact)]
                max_additional: BalanceOf<T>,
            },
            /// Schedule a portion of the stash to be unlocked ready for transfer out after the bond
            /// period ends. If this leaves an amount actively bonded less than
            /// [`asset::existential_deposit`], then it is increased to the full amount.
            ///
            /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
            ///
            /// Once the unlock period is done, you can call `withdraw_unbonded` to actually move
            /// the funds out of management ready for transfer.
            ///
            /// No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
            /// can co-exists at the same time. If there are no unlocking chunks slots available
            /// [`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible).
            ///
            /// If a user encounters the `InsufficientBond` error when calling this extrinsic,
            /// they should call `chill` first in order to free up their bonded funds.
            ///
            /// Emits `Unbonded`.
            ///
            /// See also [`Call::withdraw_unbonded`].
            #[codec(index = 2u8)]
            unbond { #[allow(missing_docs)] #[codec(compact)] value: BalanceOf<T> },
            /// Remove any unlocked chunks from the `unlocking` queue from our management.
            ///
            /// This essentially frees up that balance to be used by the stash account to do whatever
            /// it wants.
            ///
            /// The dispatch origin for this call must be _Signed_ by the controller.
            ///
            /// Emits `Withdrawn`.
            ///
            /// See also [`Call::unbond`].
            ///
            /// ## Parameters
            ///
            /// - `num_slashing_spans` indicates the number of metadata slashing spans to clear when
            /// this call results in a complete removal of all the data related to the stash account.
            /// In this case, the `num_slashing_spans` must be larger or equal to the number of
            /// slashing spans associated with the stash account in the [`SlashingSpans`] storage type,
            /// otherwise the call will fail. The call weight is directly proportional to
            /// `num_slashing_spans`.
            ///
            /// ## Complexity
            /// O(S) where S is the number of slashing spans to remove
            /// NOTE: Weight annotation is the kill scenario, we refund otherwise.
            #[codec(index = 3u8)]
            withdraw_unbonded { #[allow(missing_docs)] num_slashing_spans: u32 },
            /// Declare the desire to validate for the origin controller.
            ///
            /// Effects will be felt at the beginning of the next era.
            ///
            /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
            #[codec(index = 4u8)]
            validate { #[allow(missing_docs)] prefs: ValidatorPrefs },
            /// Declare the desire to nominate `targets` for the origin controller.
            ///
            /// Effects will be felt at the beginning of the next era.
            ///
            /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
            ///
            /// ## Complexity
            /// - The transaction's complexity is proportional to the size of `targets` (N)
            /// which is capped at CompactAssignments::LIMIT (T::MaxNominations).
            /// - Both the reads and writes follow a similar pattern.
            #[codec(index = 5u8)]
            nominate { #[allow(missing_docs)] targets: Vec<AccountIdLookupOf<T>> },
            /// Declare no desire to either validate or nominate.
            ///
            /// Effects will be felt at the beginning of the next era.
            ///
            /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
            ///
            /// ## Complexity
            /// - Independent of the arguments. Insignificant complexity.
            /// - Contains one read.
            /// - Writes are limited to the `origin` account key.
            #[codec(index = 6u8)]
            chill {},
            /// (Re-)set the payment target for a controller.
            ///
            /// Effects will be felt instantly (as soon as this function is completed successfully).
            ///
            /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
            ///
            /// ## Complexity
            /// - O(1)
            /// - Independent of the arguments. Insignificant complexity.
            /// - Contains a limited number of reads.
            /// - Writes are limited to the `origin` account key.
            /// ---------
            #[codec(index = 7u8)]
            set_payee { #[allow(missing_docs)] payee: RewardDestination<T::AccountId> },
            /// (Re-)sets the controller of a stash to the stash itself. This function previously
            /// accepted a `controller` argument to set the controller to an account other than the
            /// stash itself. This functionality has now been removed, now only setting the controller
            /// to the stash, if it is not already.
            ///
            /// Effects will be felt instantly (as soon as this function is completed successfully).
            ///
            /// The dispatch origin for this call must be _Signed_ by the stash, not the controller.
            ///
            /// ## Complexity
            /// O(1)
            /// - Independent of the arguments. Insignificant complexity.
            /// - Contains a limited number of reads.
            /// - Writes are limited to the `origin` account key.
            #[codec(index = 8u8)]
            set_controller {},
            /// Sets the ideal number of validators.
            ///
            /// The dispatch origin must be Root.
            ///
            /// ## Complexity
            /// O(1)
            #[codec(index = 9u8)]
            set_validator_count { #[allow(missing_docs)] #[codec(compact)] new: u32 },
            /// Increments the ideal number of validators up to maximum of
            /// `ElectionProviderBase::MaxWinners`.
            ///
            /// The dispatch origin must be Root.
            ///
            /// ## Complexity
            /// Same as [`Self::set_validator_count`].
            #[codec(index = 10u8)]
            increase_validator_count {
                #[allow(missing_docs)]
                #[codec(compact)]
                additional: u32,
            },
            /// Scale up the ideal number of validators by a factor up to maximum of
            /// `ElectionProviderBase::MaxWinners`.
            ///
            /// The dispatch origin must be Root.
            ///
            /// ## Complexity
            /// Same as [`Self::set_validator_count`].
            #[codec(index = 11u8)]
            scale_validator_count { #[allow(missing_docs)] factor: Percent },
            /// Force there to be no new eras indefinitely.
            ///
            /// The dispatch origin must be Root.
            ///
            /// # Warning
            ///
            /// The election process starts multiple blocks before the end of the era.
            /// Thus the election process may be ongoing when this is called. In this case the
            /// election will continue until the next era is triggered.
            ///
            /// ## Complexity
            /// - No arguments.
            /// - Weight: O(1)
            #[codec(index = 12u8)]
            force_no_eras {},
            /// Force there to be a new era at the end of the next session. After this, it will be
            /// reset to normal (non-forced) behaviour.
            ///
            /// The dispatch origin must be Root.
            ///
            /// # Warning
            ///
            /// The election process starts multiple blocks before the end of the era.
            /// If this is called just before a new era is triggered, the election process may not
            /// have enough blocks to get a result.
            ///
            /// ## Complexity
            /// - No arguments.
            /// - Weight: O(1)
            #[codec(index = 13u8)]
            force_new_era {},
            /// Set the validators who cannot be slashed (if any).
            ///
            /// The dispatch origin must be Root.
            #[codec(index = 14u8)]
            set_invulnerables {
                #[allow(missing_docs)]
                invulnerables: Vec<T::AccountId>,
            },
            /// Force a current staker to become completely unstaked, immediately.
            ///
            /// The dispatch origin must be Root.
            ///
            /// ## Parameters
            ///
            /// - `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more
            /// details.
            #[codec(index = 15u8)]
            force_unstake {
                #[allow(missing_docs)]
                stash: T::AccountId,
                #[allow(missing_docs)]
                num_slashing_spans: u32,
            },
            /// Force there to be a new era at the end of sessions indefinitely.
            ///
            /// The dispatch origin must be Root.
            ///
            /// # Warning
            ///
            /// The election process starts multiple blocks before the end of the era.
            /// If this is called just before a new era is triggered, the election process may not
            /// have enough blocks to get a result.
            #[codec(index = 16u8)]
            force_new_era_always {},
            /// Cancel enactment of a deferred slash.
            ///
            /// Can be called by the `T::AdminOrigin`.
            ///
            /// Parameters: era and indices of the slashes for that era to kill.
            #[codec(index = 17u8)]
            cancel_deferred_slash {
                #[allow(missing_docs)]
                era: EraIndex,
                #[allow(missing_docs)]
                slash_indices: Vec<u32>,
            },
            /// Pay out next page of the stakers behind a validator for the given era.
            ///
            /// - `validator_stash` is the stash account of the validator.
            /// - `era` may be any era between `[current_era - history_depth; current_era]`.
            ///
            /// The origin of this call must be _Signed_. Any account can call this function, even if
            /// it is not one of the stakers.
            ///
            /// The reward payout could be paged in case there are too many nominators backing the
            /// `validator_stash`. This call will payout unpaid pages in an ascending order. To claim a
            /// specific page, use `payout_stakers_by_page`.`
            ///
            /// If all pages are claimed, it returns an error `InvalidPage`.
            #[codec(index = 18u8)]
            payout_stakers {
                #[allow(missing_docs)]
                validator_stash: T::AccountId,
                #[allow(missing_docs)]
                era: EraIndex,
            },
            /// Rebond a portion of the stash scheduled to be unlocked.
            ///
            /// The dispatch origin must be signed by the controller.
            ///
            /// ## Complexity
            /// - Time complexity: O(L), where L is unlocking chunks
            /// - Bounded by `MaxUnlockingChunks`.
            #[codec(index = 19u8)]
            rebond { #[allow(missing_docs)] #[codec(compact)] value: BalanceOf<T> },
            /// Remove all data structures concerning a staker/stash once it is at a state where it can
            /// be considered `dust` in the staking system. The requirements are:
            ///
            /// 1. the `total_balance` of the stash is below existential deposit.
            /// 2. or, the `ledger.total` of the stash is below existential deposit.
            /// 3. or, existential deposit is zero and either `total_balance` or `ledger.total` is zero.
            ///
            /// The former can happen in cases like a slash; the latter when a fully unbonded account
            /// is still receiving staking rewards in `RewardDestination::Staked`.
            ///
            /// It can be called by anyone, as long as `stash` meets the above requirements.
            ///
            /// Refunds the transaction fees upon successful execution.
            ///
            /// ## Parameters
            ///
            /// - `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more
            /// details.
            #[codec(index = 20u8)]
            reap_stash {
                #[allow(missing_docs)]
                stash: T::AccountId,
                #[allow(missing_docs)]
                num_slashing_spans: u32,
            },
            /// Remove the given nominations from the calling validator.
            ///
            /// Effects will be felt at the beginning of the next era.
            ///
            /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
            ///
            /// - `who`: A list of nominator stash accounts who are nominating this validator which
            ///   should no longer be nominating this validator.
            ///
            /// Note: Making this call only makes sense if you first set the validator preferences to
            /// block any further nominations.
            #[codec(index = 21u8)]
            kick { #[allow(missing_docs)] who: Vec<AccountIdLookupOf<T>> },
            /// Update the various staking configurations .
            ///
            /// * `min_nominator_bond`: The minimum active bond needed to be a nominator.
            /// * `min_validator_bond`: The minimum active bond needed to be a validator.
            /// * `max_nominator_count`: The max number of users who can be a nominator at once. When
            ///   set to `None`, no limit is enforced.
            /// * `max_validator_count`: The max number of users who can be a validator at once. When
            ///   set to `None`, no limit is enforced.
            /// * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
            ///   should be filled in order for the `chill_other` transaction to work.
            /// * `min_commission`: The minimum amount of commission that each validators must maintain.
            ///   This is checked only upon calling `validate`. Existing validators are not affected.
            ///
            /// RuntimeOrigin must be Root to call this function.
            ///
            /// NOTE: Existing nominators and validators will not be affected by this update.
            /// to kick people under the new limits, `chill_other` should be called.
            #[codec(index = 22u8)]
            set_staking_configs {
                #[allow(missing_docs)]
                min_nominator_bond: ConfigOp<BalanceOf<T>>,
                #[allow(missing_docs)]
                min_validator_bond: ConfigOp<BalanceOf<T>>,
                #[allow(missing_docs)]
                max_nominator_count: ConfigOp<u32>,
                #[allow(missing_docs)]
                max_validator_count: ConfigOp<u32>,
                #[allow(missing_docs)]
                chill_threshold: ConfigOp<Percent>,
                #[allow(missing_docs)]
                min_commission: ConfigOp<Perbill>,
                #[allow(missing_docs)]
                max_staked_rewards: ConfigOp<Percent>,
            },
            /// Declare a `controller` to stop participating as either a validator or nominator.
            ///
            /// Effects will be felt at the beginning of the next era.
            ///
            /// The dispatch origin for this call must be _Signed_, but can be called by anyone.
            ///
            /// If the caller is the same as the controller being targeted, then no further checks are
            /// enforced, and this function behaves just like `chill`.
            ///
            /// If the caller is different than the controller being targeted, the following conditions
            /// must be met:
            ///
            /// * `controller` must belong to a nominator who has become non-decodable,
            ///
            /// Or:
            ///
            /// * A `ChillThreshold` must be set and checked which defines how close to the max
            ///   nominators or validators we must reach before users can start chilling one-another.
            /// * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
            ///   how close we are to the threshold.
            /// * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
            ///   if this is a person that should be chilled because they have not met the threshold
            ///   bond required.
            ///
            /// This can be helpful if bond requirements are updated, and we need to remove old users
            /// who do not satisfy these requirements.
            #[codec(index = 23u8)]
            chill_other { #[allow(missing_docs)] stash: T::AccountId },
            /// Force a validator to have at least the minimum commission. This will not affect a
            /// validator who already has a commission greater than or equal to the minimum. Any account
            /// can call this.
            #[codec(index = 24u8)]
            force_apply_min_commission {
                #[allow(missing_docs)]
                validator_stash: T::AccountId,
            },
            /// Sets the minimum amount of commission that each validators must maintain.
            ///
            /// This call has lower privilege requirements than `set_staking_config` and can be called
            /// by the `T::AdminOrigin`. Root can always call this.
            #[codec(index = 25u8)]
            set_min_commission { #[allow(missing_docs)] new: Perbill },
            /// Pay out a page of the stakers behind a validator for the given era and page.
            ///
            /// - `validator_stash` is the stash account of the validator.
            /// - `era` may be any era between `[current_era - history_depth; current_era]`.
            /// - `page` is the page index of nominators to pay out with value between 0 and
            ///   `num_nominators / T::MaxExposurePageSize`.
            ///
            /// The origin of this call must be _Signed_. Any account can call this function, even if
            /// it is not one of the stakers.
            ///
            /// If a validator has more than [`Config::MaxExposurePageSize`] nominators backing
            /// them, then the list of nominators is paged, with each page being capped at
            /// [`Config::MaxExposurePageSize`.] If a validator has more than one page of nominators,
            /// the call needs to be made for each page separately in order for all the nominators
            /// backing a validator to receive the reward. The nominators are not sorted across pages
            /// and so it should not be assumed the highest staker would be on the topmost page and vice
            /// versa. If rewards are not claimed in [`Config::HistoryDepth`] eras, they are lost.
            #[codec(index = 26u8)]
            payout_stakers_by_page {
                #[allow(missing_docs)]
                validator_stash: T::AccountId,
                #[allow(missing_docs)]
                era: EraIndex,
                #[allow(missing_docs)]
                page: Page,
            },
            /// Migrates an account's `RewardDestination::Controller` to
            /// `RewardDestination::Account(controller)`.
            ///
            /// Effects will be felt instantly (as soon as this function is completed successfully).
            ///
            /// This will waive the transaction fee if the `payee` is successfully migrated.
            #[codec(index = 27u8)]
            update_payee { #[allow(missing_docs)] controller: T::AccountId },
            /// Updates a batch of controller accounts to their corresponding stash account if they are
            /// not the same. Ignores any controller accounts that do not exist, and does not operate if
            /// the stash and controller are already the same.
            ///
            /// Effects will be felt instantly (as soon as this function is completed successfully).
            ///
            /// The dispatch origin must be `T::AdminOrigin`.
            #[codec(index = 28u8)]
            deprecate_controller_batch {
                #[allow(missing_docs)]
                controllers: BoundedVec<
                    T::AccountId,
                    T::MaxControllersInDeprecationBatch,
                >,
            },
            /// Restores the state of a ledger which is in an inconsistent state.
            ///
            /// The requirements to restore a ledger are the following:
            /// * The stash is bonded; or
            /// * The stash is not bonded but it has a staking lock left behind; or
            /// * If the stash has an associated ledger and its state is inconsistent; or
            /// * If the ledger is not corrupted *but* its staking lock is out of sync.
            ///
            /// The `maybe_*` input parameters will overwrite the corresponding data and metadata of the
            /// ledger associated with the stash. If the input parameters are not set, the ledger will
            /// be reset values from on-chain state.
            #[codec(index = 29u8)]
            restore_ledger {
                #[allow(missing_docs)]
                stash: T::AccountId,
                #[allow(missing_docs)]
                maybe_controller: Option<T::AccountId>,
                #[allow(missing_docs)]
                maybe_total: Option<BalanceOf<T>>,
                #[allow(missing_docs)]
                maybe_unlocking: Option<
                    BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>,
                >,
            },
        }
        const _: () = {
            #[automatically_derived]
            impl<T: Config> ::core::fmt::Debug for Call<T> {
                fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        Self::__Ignore(ref _0, ref _1) => {
                            fmt.debug_tuple("Call::__Ignore")
                                .field(&_0)
                                .field(&_1)
                                .finish()
                        }
                        Self::bond { ref value, ref payee } => {
                            fmt.debug_struct("Call::bond")
                                .field("value", &value)
                                .field("payee", &payee)
                                .finish()
                        }
                        Self::bond_extra { ref max_additional } => {
                            fmt.debug_struct("Call::bond_extra")
                                .field("max_additional", &max_additional)
                                .finish()
                        }
                        Self::unbond { ref value } => {
                            fmt.debug_struct("Call::unbond")
                                .field("value", &value)
                                .finish()
                        }
                        Self::withdraw_unbonded { ref num_slashing_spans } => {
                            fmt.debug_struct("Call::withdraw_unbonded")
                                .field("num_slashing_spans", &num_slashing_spans)
                                .finish()
                        }
                        Self::validate { ref prefs } => {
                            fmt.debug_struct("Call::validate")
                                .field("prefs", &prefs)
                                .finish()
                        }
                        Self::nominate { ref targets } => {
                            fmt.debug_struct("Call::nominate")
                                .field("targets", &targets)
                                .finish()
                        }
                        Self::chill {} => fmt.debug_struct("Call::chill").finish(),
                        Self::set_payee { ref payee } => {
                            fmt.debug_struct("Call::set_payee")
                                .field("payee", &payee)
                                .finish()
                        }
                        Self::set_controller {} => {
                            fmt.debug_struct("Call::set_controller").finish()
                        }
                        Self::set_validator_count { ref new } => {
                            fmt.debug_struct("Call::set_validator_count")
                                .field("new", &new)
                                .finish()
                        }
                        Self::increase_validator_count { ref additional } => {
                            fmt.debug_struct("Call::increase_validator_count")
                                .field("additional", &additional)
                                .finish()
                        }
                        Self::scale_validator_count { ref factor } => {
                            fmt.debug_struct("Call::scale_validator_count")
                                .field("factor", &factor)
                                .finish()
                        }
                        Self::force_no_eras {} => {
                            fmt.debug_struct("Call::force_no_eras").finish()
                        }
                        Self::force_new_era {} => {
                            fmt.debug_struct("Call::force_new_era").finish()
                        }
                        Self::set_invulnerables { ref invulnerables } => {
                            fmt.debug_struct("Call::set_invulnerables")
                                .field("invulnerables", &invulnerables)
                                .finish()
                        }
                        Self::force_unstake { ref stash, ref num_slashing_spans } => {
                            fmt.debug_struct("Call::force_unstake")
                                .field("stash", &stash)
                                .field("num_slashing_spans", &num_slashing_spans)
                                .finish()
                        }
                        Self::force_new_era_always {} => {
                            fmt.debug_struct("Call::force_new_era_always").finish()
                        }
                        Self::cancel_deferred_slash { ref era, ref slash_indices } => {
                            fmt.debug_struct("Call::cancel_deferred_slash")
                                .field("era", &era)
                                .field("slash_indices", &slash_indices)
                                .finish()
                        }
                        Self::payout_stakers { ref validator_stash, ref era } => {
                            fmt.debug_struct("Call::payout_stakers")
                                .field("validator_stash", &validator_stash)
                                .field("era", &era)
                                .finish()
                        }
                        Self::rebond { ref value } => {
                            fmt.debug_struct("Call::rebond")
                                .field("value", &value)
                                .finish()
                        }
                        Self::reap_stash { ref stash, ref num_slashing_spans } => {
                            fmt.debug_struct("Call::reap_stash")
                                .field("stash", &stash)
                                .field("num_slashing_spans", &num_slashing_spans)
                                .finish()
                        }
                        Self::kick { ref who } => {
                            fmt.debug_struct("Call::kick").field("who", &who).finish()
                        }
                        Self::set_staking_configs {
                            ref min_nominator_bond,
                            ref min_validator_bond,
                            ref max_nominator_count,
                            ref max_validator_count,
                            ref chill_threshold,
                            ref min_commission,
                            ref max_staked_rewards,
                        } => {
                            fmt.debug_struct("Call::set_staking_configs")
                                .field("min_nominator_bond", &min_nominator_bond)
                                .field("min_validator_bond", &min_validator_bond)
                                .field("max_nominator_count", &max_nominator_count)
                                .field("max_validator_count", &max_validator_count)
                                .field("chill_threshold", &chill_threshold)
                                .field("min_commission", &min_commission)
                                .field("max_staked_rewards", &max_staked_rewards)
                                .finish()
                        }
                        Self::chill_other { ref stash } => {
                            fmt.debug_struct("Call::chill_other")
                                .field("stash", &stash)
                                .finish()
                        }
                        Self::force_apply_min_commission { ref validator_stash } => {
                            fmt.debug_struct("Call::force_apply_min_commission")
                                .field("validator_stash", &validator_stash)
                                .finish()
                        }
                        Self::set_min_commission { ref new } => {
                            fmt.debug_struct("Call::set_min_commission")
                                .field("new", &new)
                                .finish()
                        }
                        Self::payout_stakers_by_page {
                            ref validator_stash,
                            ref era,
                            ref page,
                        } => {
                            fmt.debug_struct("Call::payout_stakers_by_page")
                                .field("validator_stash", &validator_stash)
                                .field("era", &era)
                                .field("page", &page)
                                .finish()
                        }
                        Self::update_payee { ref controller } => {
                            fmt.debug_struct("Call::update_payee")
                                .field("controller", &controller)
                                .finish()
                        }
                        Self::deprecate_controller_batch { ref controllers } => {
                            fmt.debug_struct("Call::deprecate_controller_batch")
                                .field("controllers", &controllers)
                                .finish()
                        }
                        Self::restore_ledger {
                            ref stash,
                            ref maybe_controller,
                            ref maybe_total,
                            ref maybe_unlocking,
                        } => {
                            fmt.debug_struct("Call::restore_ledger")
                                .field("stash", &stash)
                                .field("maybe_controller", &maybe_controller)
                                .field("maybe_total", &maybe_total)
                                .field("maybe_unlocking", &maybe_unlocking)
                                .finish()
                        }
                    }
                }
            }
        };
        const _: () = {
            #[automatically_derived]
            impl<T: Config> ::core::clone::Clone for Call<T> {
                fn clone(&self) -> Self {
                    match self {
                        Self::__Ignore(ref _0, ref _1) => {
                            Self::__Ignore(
                                ::core::clone::Clone::clone(_0),
                                ::core::clone::Clone::clone(_1),
                            )
                        }
                        Self::bond { ref value, ref payee } => {
                            Self::bond {
                                value: ::core::clone::Clone::clone(value),
                                payee: ::core::clone::Clone::clone(payee),
                            }
                        }
                        Self::bond_extra { ref max_additional } => {
                            Self::bond_extra {
                                max_additional: ::core::clone::Clone::clone(max_additional),
                            }
                        }
                        Self::unbond { ref value } => {
                            Self::unbond {
                                value: ::core::clone::Clone::clone(value),
                            }
                        }
                        Self::withdraw_unbonded { ref num_slashing_spans } => {
                            Self::withdraw_unbonded {
                                num_slashing_spans: ::core::clone::Clone::clone(
                                    num_slashing_spans,
                                ),
                            }
                        }
                        Self::validate { ref prefs } => {
                            Self::validate {
                                prefs: ::core::clone::Clone::clone(prefs),
                            }
                        }
                        Self::nominate { ref targets } => {
                            Self::nominate {
                                targets: ::core::clone::Clone::clone(targets),
                            }
                        }
                        Self::chill {} => Self::chill {},
                        Self::set_payee { ref payee } => {
                            Self::set_payee {
                                payee: ::core::clone::Clone::clone(payee),
                            }
                        }
                        Self::set_controller {} => Self::set_controller {},
                        Self::set_validator_count { ref new } => {
                            Self::set_validator_count {
                                new: ::core::clone::Clone::clone(new),
                            }
                        }
                        Self::increase_validator_count { ref additional } => {
                            Self::increase_validator_count {
                                additional: ::core::clone::Clone::clone(additional),
                            }
                        }
                        Self::scale_validator_count { ref factor } => {
                            Self::scale_validator_count {
                                factor: ::core::clone::Clone::clone(factor),
                            }
                        }
                        Self::force_no_eras {} => Self::force_no_eras {},
                        Self::force_new_era {} => Self::force_new_era {},
                        Self::set_invulnerables { ref invulnerables } => {
                            Self::set_invulnerables {
                                invulnerables: ::core::clone::Clone::clone(invulnerables),
                            }
                        }
                        Self::force_unstake { ref stash, ref num_slashing_spans } => {
                            Self::force_unstake {
                                stash: ::core::clone::Clone::clone(stash),
                                num_slashing_spans: ::core::clone::Clone::clone(
                                    num_slashing_spans,
                                ),
                            }
                        }
                        Self::force_new_era_always {} => Self::force_new_era_always {},
                        Self::cancel_deferred_slash { ref era, ref slash_indices } => {
                            Self::cancel_deferred_slash {
                                era: ::core::clone::Clone::clone(era),
                                slash_indices: ::core::clone::Clone::clone(slash_indices),
                            }
                        }
                        Self::payout_stakers { ref validator_stash, ref era } => {
                            Self::payout_stakers {
                                validator_stash: ::core::clone::Clone::clone(
                                    validator_stash,
                                ),
                                era: ::core::clone::Clone::clone(era),
                            }
                        }
                        Self::rebond { ref value } => {
                            Self::rebond {
                                value: ::core::clone::Clone::clone(value),
                            }
                        }
                        Self::reap_stash { ref stash, ref num_slashing_spans } => {
                            Self::reap_stash {
                                stash: ::core::clone::Clone::clone(stash),
                                num_slashing_spans: ::core::clone::Clone::clone(
                                    num_slashing_spans,
                                ),
                            }
                        }
                        Self::kick { ref who } => {
                            Self::kick {
                                who: ::core::clone::Clone::clone(who),
                            }
                        }
                        Self::set_staking_configs {
                            ref min_nominator_bond,
                            ref min_validator_bond,
                            ref max_nominator_count,
                            ref max_validator_count,
                            ref chill_threshold,
                            ref min_commission,
                            ref max_staked_rewards,
                        } => {
                            Self::set_staking_configs {
                                min_nominator_bond: ::core::clone::Clone::clone(
                                    min_nominator_bond,
                                ),
                                min_validator_bond: ::core::clone::Clone::clone(
                                    min_validator_bond,
                                ),
                                max_nominator_count: ::core::clone::Clone::clone(
                                    max_nominator_count,
                                ),
                                max_validator_count: ::core::clone::Clone::clone(
                                    max_validator_count,
                                ),
                                chill_threshold: ::core::clone::Clone::clone(
                                    chill_threshold,
                                ),
                                min_commission: ::core::clone::Clone::clone(min_commission),
                                max_staked_rewards: ::core::clone::Clone::clone(
                                    max_staked_rewards,
                                ),
                            }
                        }
                        Self::chill_other { ref stash } => {
                            Self::chill_other {
                                stash: ::core::clone::Clone::clone(stash),
                            }
                        }
                        Self::force_apply_min_commission { ref validator_stash } => {
                            Self::force_apply_min_commission {
                                validator_stash: ::core::clone::Clone::clone(
                                    validator_stash,
                                ),
                            }
                        }
                        Self::set_min_commission { ref new } => {
                            Self::set_min_commission {
                                new: ::core::clone::Clone::clone(new),
                            }
                        }
                        Self::payout_stakers_by_page {
                            ref validator_stash,
                            ref era,
                            ref page,
                        } => {
                            Self::payout_stakers_by_page {
                                validator_stash: ::core::clone::Clone::clone(
                                    validator_stash,
                                ),
                                era: ::core::clone::Clone::clone(era),
                                page: ::core::clone::Clone::clone(page),
                            }
                        }
                        Self::update_payee { ref controller } => {
                            Self::update_payee {
                                controller: ::core::clone::Clone::clone(controller),
                            }
                        }
                        Self::deprecate_controller_batch { ref controllers } => {
                            Self::deprecate_controller_batch {
                                controllers: ::core::clone::Clone::clone(controllers),
                            }
                        }
                        Self::restore_ledger {
                            ref stash,
                            ref maybe_controller,
                            ref maybe_total,
                            ref maybe_unlocking,
                        } => {
                            Self::restore_ledger {
                                stash: ::core::clone::Clone::clone(stash),
                                maybe_controller: ::core::clone::Clone::clone(
                                    maybe_controller,
                                ),
                                maybe_total: ::core::clone::Clone::clone(maybe_total),
                                maybe_unlocking: ::core::clone::Clone::clone(
                                    maybe_unlocking,
                                ),
                            }
                        }
                    }
                }
            }
        };
        const _: () = {
            impl<T: Config> ::core::cmp::Eq for Call<T> {}
        };
        const _: () = {
            #[automatically_derived]
            impl<T: Config> ::core::cmp::PartialEq for Call<T> {
                fn eq(&self, other: &Self) -> bool {
                    match (self, other) {
                        (Self::__Ignore(_0, _1), Self::__Ignore(_0_other, _1_other)) => {
                            true && _0 == _0_other && _1 == _1_other
                        }
                        (
                            Self::bond { value, payee },
                            Self::bond { value: _0, payee: _1 },
                        ) => true && value == _0 && payee == _1,
                        (
                            Self::bond_extra { max_additional },
                            Self::bond_extra { max_additional: _0 },
                        ) => true && max_additional == _0,
                        (Self::unbond { value }, Self::unbond { value: _0 }) => {
                            true && value == _0
                        }
                        (
                            Self::withdraw_unbonded { num_slashing_spans },
                            Self::withdraw_unbonded { num_slashing_spans: _0 },
                        ) => true && num_slashing_spans == _0,
                        (Self::validate { prefs }, Self::validate { prefs: _0 }) => {
                            true && prefs == _0
                        }
                        (Self::nominate { targets }, Self::nominate { targets: _0 }) => {
                            true && targets == _0
                        }
                        (Self::chill {}, Self::chill {}) => true,
                        (Self::set_payee { payee }, Self::set_payee { payee: _0 }) => {
                            true && payee == _0
                        }
                        (Self::set_controller {}, Self::set_controller {}) => true,
                        (
                            Self::set_validator_count { new },
                            Self::set_validator_count { new: _0 },
                        ) => true && new == _0,
                        (
                            Self::increase_validator_count { additional },
                            Self::increase_validator_count { additional: _0 },
                        ) => true && additional == _0,
                        (
                            Self::scale_validator_count { factor },
                            Self::scale_validator_count { factor: _0 },
                        ) => true && factor == _0,
                        (Self::force_no_eras {}, Self::force_no_eras {}) => true,
                        (Self::force_new_era {}, Self::force_new_era {}) => true,
                        (
                            Self::set_invulnerables { invulnerables },
                            Self::set_invulnerables { invulnerables: _0 },
                        ) => true && invulnerables == _0,
                        (
                            Self::force_unstake { stash, num_slashing_spans },
                            Self::force_unstake { stash: _0, num_slashing_spans: _1 },
                        ) => true && stash == _0 && num_slashing_spans == _1,
                        (
                            Self::force_new_era_always {},
                            Self::force_new_era_always {},
                        ) => true,
                        (
                            Self::cancel_deferred_slash { era, slash_indices },
                            Self::cancel_deferred_slash { era: _0, slash_indices: _1 },
                        ) => true && era == _0 && slash_indices == _1,
                        (
                            Self::payout_stakers { validator_stash, era },
                            Self::payout_stakers { validator_stash: _0, era: _1 },
                        ) => true && validator_stash == _0 && era == _1,
                        (Self::rebond { value }, Self::rebond { value: _0 }) => {
                            true && value == _0
                        }
                        (
                            Self::reap_stash { stash, num_slashing_spans },
                            Self::reap_stash { stash: _0, num_slashing_spans: _1 },
                        ) => true && stash == _0 && num_slashing_spans == _1,
                        (Self::kick { who }, Self::kick { who: _0 }) => true && who == _0,
                        (
                            Self::set_staking_configs {
                                min_nominator_bond,
                                min_validator_bond,
                                max_nominator_count,
                                max_validator_count,
                                chill_threshold,
                                min_commission,
                                max_staked_rewards,
                            },
                            Self::set_staking_configs {
                                min_nominator_bond: _0,
                                min_validator_bond: _1,
                                max_nominator_count: _2,
                                max_validator_count: _3,
                                chill_threshold: _4,
                                min_commission: _5,
                                max_staked_rewards: _6,
                            },
                        ) => {
                            true && min_nominator_bond == _0 && min_validator_bond == _1
                                && max_nominator_count == _2 && max_validator_count == _3
                                && chill_threshold == _4 && min_commission == _5
                                && max_staked_rewards == _6
                        }
                        (
                            Self::chill_other { stash },
                            Self::chill_other { stash: _0 },
                        ) => true && stash == _0,
                        (
                            Self::force_apply_min_commission { validator_stash },
                            Self::force_apply_min_commission { validator_stash: _0 },
                        ) => true && validator_stash == _0,
                        (
                            Self::set_min_commission { new },
                            Self::set_min_commission { new: _0 },
                        ) => true && new == _0,
                        (
                            Self::payout_stakers_by_page { validator_stash, era, page },
                            Self::payout_stakers_by_page {
                                validator_stash: _0,
                                era: _1,
                                page: _2,
                            },
                        ) => true && validator_stash == _0 && era == _1 && page == _2,
                        (
                            Self::update_payee { controller },
                            Self::update_payee { controller: _0 },
                        ) => true && controller == _0,
                        (
                            Self::deprecate_controller_batch { controllers },
                            Self::deprecate_controller_batch { controllers: _0 },
                        ) => true && controllers == _0,
                        (
                            Self::restore_ledger {
                                stash,
                                maybe_controller,
                                maybe_total,
                                maybe_unlocking,
                            },
                            Self::restore_ledger {
                                stash: _0,
                                maybe_controller: _1,
                                maybe_total: _2,
                                maybe_unlocking: _3,
                            },
                        ) => {
                            true && stash == _0 && maybe_controller == _1
                                && maybe_total == _2 && maybe_unlocking == _3
                        }
                        (Self::__Ignore { .. }, Self::bond { .. }) => false,
                        (Self::__Ignore { .. }, Self::bond_extra { .. }) => false,
                        (Self::__Ignore { .. }, Self::unbond { .. }) => false,
                        (Self::__Ignore { .. }, Self::withdraw_unbonded { .. }) => false,
                        (Self::__Ignore { .. }, Self::validate { .. }) => false,
                        (Self::__Ignore { .. }, Self::nominate { .. }) => false,
                        (Self::__Ignore { .. }, Self::chill { .. }) => false,
                        (Self::__Ignore { .. }, Self::set_payee { .. }) => false,
                        (Self::__Ignore { .. }, Self::set_controller { .. }) => false,
                        (Self::__Ignore { .. }, Self::set_validator_count { .. }) => {
                            false
                        }
                        (
                            Self::__Ignore { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (Self::__Ignore { .. }, Self::scale_validator_count { .. }) => {
                            false
                        }
                        (Self::__Ignore { .. }, Self::force_no_eras { .. }) => false,
                        (Self::__Ignore { .. }, Self::force_new_era { .. }) => false,
                        (Self::__Ignore { .. }, Self::set_invulnerables { .. }) => false,
                        (Self::__Ignore { .. }, Self::force_unstake { .. }) => false,
                        (Self::__Ignore { .. }, Self::force_new_era_always { .. }) => {
                            false
                        }
                        (Self::__Ignore { .. }, Self::cancel_deferred_slash { .. }) => {
                            false
                        }
                        (Self::__Ignore { .. }, Self::payout_stakers { .. }) => false,
                        (Self::__Ignore { .. }, Self::rebond { .. }) => false,
                        (Self::__Ignore { .. }, Self::reap_stash { .. }) => false,
                        (Self::__Ignore { .. }, Self::kick { .. }) => false,
                        (Self::__Ignore { .. }, Self::set_staking_configs { .. }) => {
                            false
                        }
                        (Self::__Ignore { .. }, Self::chill_other { .. }) => false,
                        (
                            Self::__Ignore { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (Self::__Ignore { .. }, Self::set_min_commission { .. }) => false,
                        (Self::__Ignore { .. }, Self::payout_stakers_by_page { .. }) => {
                            false
                        }
                        (Self::__Ignore { .. }, Self::update_payee { .. }) => false,
                        (
                            Self::__Ignore { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::__Ignore { .. }, Self::restore_ledger { .. }) => false,
                        (Self::bond { .. }, Self::__Ignore { .. }) => false,
                        (Self::bond { .. }, Self::bond_extra { .. }) => false,
                        (Self::bond { .. }, Self::unbond { .. }) => false,
                        (Self::bond { .. }, Self::withdraw_unbonded { .. }) => false,
                        (Self::bond { .. }, Self::validate { .. }) => false,
                        (Self::bond { .. }, Self::nominate { .. }) => false,
                        (Self::bond { .. }, Self::chill { .. }) => false,
                        (Self::bond { .. }, Self::set_payee { .. }) => false,
                        (Self::bond { .. }, Self::set_controller { .. }) => false,
                        (Self::bond { .. }, Self::set_validator_count { .. }) => false,
                        (Self::bond { .. }, Self::increase_validator_count { .. }) => {
                            false
                        }
                        (Self::bond { .. }, Self::scale_validator_count { .. }) => false,
                        (Self::bond { .. }, Self::force_no_eras { .. }) => false,
                        (Self::bond { .. }, Self::force_new_era { .. }) => false,
                        (Self::bond { .. }, Self::set_invulnerables { .. }) => false,
                        (Self::bond { .. }, Self::force_unstake { .. }) => false,
                        (Self::bond { .. }, Self::force_new_era_always { .. }) => false,
                        (Self::bond { .. }, Self::cancel_deferred_slash { .. }) => false,
                        (Self::bond { .. }, Self::payout_stakers { .. }) => false,
                        (Self::bond { .. }, Self::rebond { .. }) => false,
                        (Self::bond { .. }, Self::reap_stash { .. }) => false,
                        (Self::bond { .. }, Self::kick { .. }) => false,
                        (Self::bond { .. }, Self::set_staking_configs { .. }) => false,
                        (Self::bond { .. }, Self::chill_other { .. }) => false,
                        (Self::bond { .. }, Self::force_apply_min_commission { .. }) => {
                            false
                        }
                        (Self::bond { .. }, Self::set_min_commission { .. }) => false,
                        (Self::bond { .. }, Self::payout_stakers_by_page { .. }) => false,
                        (Self::bond { .. }, Self::update_payee { .. }) => false,
                        (Self::bond { .. }, Self::deprecate_controller_batch { .. }) => {
                            false
                        }
                        (Self::bond { .. }, Self::restore_ledger { .. }) => false,
                        (Self::bond_extra { .. }, Self::__Ignore { .. }) => false,
                        (Self::bond_extra { .. }, Self::bond { .. }) => false,
                        (Self::bond_extra { .. }, Self::unbond { .. }) => false,
                        (Self::bond_extra { .. }, Self::withdraw_unbonded { .. }) => {
                            false
                        }
                        (Self::bond_extra { .. }, Self::validate { .. }) => false,
                        (Self::bond_extra { .. }, Self::nominate { .. }) => false,
                        (Self::bond_extra { .. }, Self::chill { .. }) => false,
                        (Self::bond_extra { .. }, Self::set_payee { .. }) => false,
                        (Self::bond_extra { .. }, Self::set_controller { .. }) => false,
                        (Self::bond_extra { .. }, Self::set_validator_count { .. }) => {
                            false
                        }
                        (
                            Self::bond_extra { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (Self::bond_extra { .. }, Self::scale_validator_count { .. }) => {
                            false
                        }
                        (Self::bond_extra { .. }, Self::force_no_eras { .. }) => false,
                        (Self::bond_extra { .. }, Self::force_new_era { .. }) => false,
                        (Self::bond_extra { .. }, Self::set_invulnerables { .. }) => {
                            false
                        }
                        (Self::bond_extra { .. }, Self::force_unstake { .. }) => false,
                        (Self::bond_extra { .. }, Self::force_new_era_always { .. }) => {
                            false
                        }
                        (Self::bond_extra { .. }, Self::cancel_deferred_slash { .. }) => {
                            false
                        }
                        (Self::bond_extra { .. }, Self::payout_stakers { .. }) => false,
                        (Self::bond_extra { .. }, Self::rebond { .. }) => false,
                        (Self::bond_extra { .. }, Self::reap_stash { .. }) => false,
                        (Self::bond_extra { .. }, Self::kick { .. }) => false,
                        (Self::bond_extra { .. }, Self::set_staking_configs { .. }) => {
                            false
                        }
                        (Self::bond_extra { .. }, Self::chill_other { .. }) => false,
                        (
                            Self::bond_extra { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (Self::bond_extra { .. }, Self::set_min_commission { .. }) => {
                            false
                        }
                        (
                            Self::bond_extra { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (Self::bond_extra { .. }, Self::update_payee { .. }) => false,
                        (
                            Self::bond_extra { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::bond_extra { .. }, Self::restore_ledger { .. }) => false,
                        (Self::unbond { .. }, Self::__Ignore { .. }) => false,
                        (Self::unbond { .. }, Self::bond { .. }) => false,
                        (Self::unbond { .. }, Self::bond_extra { .. }) => false,
                        (Self::unbond { .. }, Self::withdraw_unbonded { .. }) => false,
                        (Self::unbond { .. }, Self::validate { .. }) => false,
                        (Self::unbond { .. }, Self::nominate { .. }) => false,
                        (Self::unbond { .. }, Self::chill { .. }) => false,
                        (Self::unbond { .. }, Self::set_payee { .. }) => false,
                        (Self::unbond { .. }, Self::set_controller { .. }) => false,
                        (Self::unbond { .. }, Self::set_validator_count { .. }) => false,
                        (Self::unbond { .. }, Self::increase_validator_count { .. }) => {
                            false
                        }
                        (Self::unbond { .. }, Self::scale_validator_count { .. }) => {
                            false
                        }
                        (Self::unbond { .. }, Self::force_no_eras { .. }) => false,
                        (Self::unbond { .. }, Self::force_new_era { .. }) => false,
                        (Self::unbond { .. }, Self::set_invulnerables { .. }) => false,
                        (Self::unbond { .. }, Self::force_unstake { .. }) => false,
                        (Self::unbond { .. }, Self::force_new_era_always { .. }) => false,
                        (Self::unbond { .. }, Self::cancel_deferred_slash { .. }) => {
                            false
                        }
                        (Self::unbond { .. }, Self::payout_stakers { .. }) => false,
                        (Self::unbond { .. }, Self::rebond { .. }) => false,
                        (Self::unbond { .. }, Self::reap_stash { .. }) => false,
                        (Self::unbond { .. }, Self::kick { .. }) => false,
                        (Self::unbond { .. }, Self::set_staking_configs { .. }) => false,
                        (Self::unbond { .. }, Self::chill_other { .. }) => false,
                        (
                            Self::unbond { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (Self::unbond { .. }, Self::set_min_commission { .. }) => false,
                        (Self::unbond { .. }, Self::payout_stakers_by_page { .. }) => {
                            false
                        }
                        (Self::unbond { .. }, Self::update_payee { .. }) => false,
                        (
                            Self::unbond { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::unbond { .. }, Self::restore_ledger { .. }) => false,
                        (Self::withdraw_unbonded { .. }, Self::__Ignore { .. }) => false,
                        (Self::withdraw_unbonded { .. }, Self::bond { .. }) => false,
                        (Self::withdraw_unbonded { .. }, Self::bond_extra { .. }) => {
                            false
                        }
                        (Self::withdraw_unbonded { .. }, Self::unbond { .. }) => false,
                        (Self::withdraw_unbonded { .. }, Self::validate { .. }) => false,
                        (Self::withdraw_unbonded { .. }, Self::nominate { .. }) => false,
                        (Self::withdraw_unbonded { .. }, Self::chill { .. }) => false,
                        (Self::withdraw_unbonded { .. }, Self::set_payee { .. }) => false,
                        (Self::withdraw_unbonded { .. }, Self::set_controller { .. }) => {
                            false
                        }
                        (
                            Self::withdraw_unbonded { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::withdraw_unbonded { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::withdraw_unbonded { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (Self::withdraw_unbonded { .. }, Self::force_no_eras { .. }) => {
                            false
                        }
                        (Self::withdraw_unbonded { .. }, Self::force_new_era { .. }) => {
                            false
                        }
                        (
                            Self::withdraw_unbonded { .. },
                            Self::set_invulnerables { .. },
                        ) => false,
                        (Self::withdraw_unbonded { .. }, Self::force_unstake { .. }) => {
                            false
                        }
                        (
                            Self::withdraw_unbonded { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::withdraw_unbonded { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (Self::withdraw_unbonded { .. }, Self::payout_stakers { .. }) => {
                            false
                        }
                        (Self::withdraw_unbonded { .. }, Self::rebond { .. }) => false,
                        (Self::withdraw_unbonded { .. }, Self::reap_stash { .. }) => {
                            false
                        }
                        (Self::withdraw_unbonded { .. }, Self::kick { .. }) => false,
                        (
                            Self::withdraw_unbonded { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (Self::withdraw_unbonded { .. }, Self::chill_other { .. }) => {
                            false
                        }
                        (
                            Self::withdraw_unbonded { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (
                            Self::withdraw_unbonded { .. },
                            Self::set_min_commission { .. },
                        ) => false,
                        (
                            Self::withdraw_unbonded { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (Self::withdraw_unbonded { .. }, Self::update_payee { .. }) => {
                            false
                        }
                        (
                            Self::withdraw_unbonded { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::withdraw_unbonded { .. }, Self::restore_ledger { .. }) => {
                            false
                        }
                        (Self::validate { .. }, Self::__Ignore { .. }) => false,
                        (Self::validate { .. }, Self::bond { .. }) => false,
                        (Self::validate { .. }, Self::bond_extra { .. }) => false,
                        (Self::validate { .. }, Self::unbond { .. }) => false,
                        (Self::validate { .. }, Self::withdraw_unbonded { .. }) => false,
                        (Self::validate { .. }, Self::nominate { .. }) => false,
                        (Self::validate { .. }, Self::chill { .. }) => false,
                        (Self::validate { .. }, Self::set_payee { .. }) => false,
                        (Self::validate { .. }, Self::set_controller { .. }) => false,
                        (Self::validate { .. }, Self::set_validator_count { .. }) => {
                            false
                        }
                        (
                            Self::validate { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (Self::validate { .. }, Self::scale_validator_count { .. }) => {
                            false
                        }
                        (Self::validate { .. }, Self::force_no_eras { .. }) => false,
                        (Self::validate { .. }, Self::force_new_era { .. }) => false,
                        (Self::validate { .. }, Self::set_invulnerables { .. }) => false,
                        (Self::validate { .. }, Self::force_unstake { .. }) => false,
                        (Self::validate { .. }, Self::force_new_era_always { .. }) => {
                            false
                        }
                        (Self::validate { .. }, Self::cancel_deferred_slash { .. }) => {
                            false
                        }
                        (Self::validate { .. }, Self::payout_stakers { .. }) => false,
                        (Self::validate { .. }, Self::rebond { .. }) => false,
                        (Self::validate { .. }, Self::reap_stash { .. }) => false,
                        (Self::validate { .. }, Self::kick { .. }) => false,
                        (Self::validate { .. }, Self::set_staking_configs { .. }) => {
                            false
                        }
                        (Self::validate { .. }, Self::chill_other { .. }) => false,
                        (
                            Self::validate { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (Self::validate { .. }, Self::set_min_commission { .. }) => false,
                        (Self::validate { .. }, Self::payout_stakers_by_page { .. }) => {
                            false
                        }
                        (Self::validate { .. }, Self::update_payee { .. }) => false,
                        (
                            Self::validate { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::validate { .. }, Self::restore_ledger { .. }) => false,
                        (Self::nominate { .. }, Self::__Ignore { .. }) => false,
                        (Self::nominate { .. }, Self::bond { .. }) => false,
                        (Self::nominate { .. }, Self::bond_extra { .. }) => false,
                        (Self::nominate { .. }, Self::unbond { .. }) => false,
                        (Self::nominate { .. }, Self::withdraw_unbonded { .. }) => false,
                        (Self::nominate { .. }, Self::validate { .. }) => false,
                        (Self::nominate { .. }, Self::chill { .. }) => false,
                        (Self::nominate { .. }, Self::set_payee { .. }) => false,
                        (Self::nominate { .. }, Self::set_controller { .. }) => false,
                        (Self::nominate { .. }, Self::set_validator_count { .. }) => {
                            false
                        }
                        (
                            Self::nominate { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (Self::nominate { .. }, Self::scale_validator_count { .. }) => {
                            false
                        }
                        (Self::nominate { .. }, Self::force_no_eras { .. }) => false,
                        (Self::nominate { .. }, Self::force_new_era { .. }) => false,
                        (Self::nominate { .. }, Self::set_invulnerables { .. }) => false,
                        (Self::nominate { .. }, Self::force_unstake { .. }) => false,
                        (Self::nominate { .. }, Self::force_new_era_always { .. }) => {
                            false
                        }
                        (Self::nominate { .. }, Self::cancel_deferred_slash { .. }) => {
                            false
                        }
                        (Self::nominate { .. }, Self::payout_stakers { .. }) => false,
                        (Self::nominate { .. }, Self::rebond { .. }) => false,
                        (Self::nominate { .. }, Self::reap_stash { .. }) => false,
                        (Self::nominate { .. }, Self::kick { .. }) => false,
                        (Self::nominate { .. }, Self::set_staking_configs { .. }) => {
                            false
                        }
                        (Self::nominate { .. }, Self::chill_other { .. }) => false,
                        (
                            Self::nominate { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (Self::nominate { .. }, Self::set_min_commission { .. }) => false,
                        (Self::nominate { .. }, Self::payout_stakers_by_page { .. }) => {
                            false
                        }
                        (Self::nominate { .. }, Self::update_payee { .. }) => false,
                        (
                            Self::nominate { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::nominate { .. }, Self::restore_ledger { .. }) => false,
                        (Self::chill { .. }, Self::__Ignore { .. }) => false,
                        (Self::chill { .. }, Self::bond { .. }) => false,
                        (Self::chill { .. }, Self::bond_extra { .. }) => false,
                        (Self::chill { .. }, Self::unbond { .. }) => false,
                        (Self::chill { .. }, Self::withdraw_unbonded { .. }) => false,
                        (Self::chill { .. }, Self::validate { .. }) => false,
                        (Self::chill { .. }, Self::nominate { .. }) => false,
                        (Self::chill { .. }, Self::set_payee { .. }) => false,
                        (Self::chill { .. }, Self::set_controller { .. }) => false,
                        (Self::chill { .. }, Self::set_validator_count { .. }) => false,
                        (Self::chill { .. }, Self::increase_validator_count { .. }) => {
                            false
                        }
                        (Self::chill { .. }, Self::scale_validator_count { .. }) => false,
                        (Self::chill { .. }, Self::force_no_eras { .. }) => false,
                        (Self::chill { .. }, Self::force_new_era { .. }) => false,
                        (Self::chill { .. }, Self::set_invulnerables { .. }) => false,
                        (Self::chill { .. }, Self::force_unstake { .. }) => false,
                        (Self::chill { .. }, Self::force_new_era_always { .. }) => false,
                        (Self::chill { .. }, Self::cancel_deferred_slash { .. }) => false,
                        (Self::chill { .. }, Self::payout_stakers { .. }) => false,
                        (Self::chill { .. }, Self::rebond { .. }) => false,
                        (Self::chill { .. }, Self::reap_stash { .. }) => false,
                        (Self::chill { .. }, Self::kick { .. }) => false,
                        (Self::chill { .. }, Self::set_staking_configs { .. }) => false,
                        (Self::chill { .. }, Self::chill_other { .. }) => false,
                        (Self::chill { .. }, Self::force_apply_min_commission { .. }) => {
                            false
                        }
                        (Self::chill { .. }, Self::set_min_commission { .. }) => false,
                        (Self::chill { .. }, Self::payout_stakers_by_page { .. }) => {
                            false
                        }
                        (Self::chill { .. }, Self::update_payee { .. }) => false,
                        (Self::chill { .. }, Self::deprecate_controller_batch { .. }) => {
                            false
                        }
                        (Self::chill { .. }, Self::restore_ledger { .. }) => false,
                        (Self::set_payee { .. }, Self::__Ignore { .. }) => false,
                        (Self::set_payee { .. }, Self::bond { .. }) => false,
                        (Self::set_payee { .. }, Self::bond_extra { .. }) => false,
                        (Self::set_payee { .. }, Self::unbond { .. }) => false,
                        (Self::set_payee { .. }, Self::withdraw_unbonded { .. }) => false,
                        (Self::set_payee { .. }, Self::validate { .. }) => false,
                        (Self::set_payee { .. }, Self::nominate { .. }) => false,
                        (Self::set_payee { .. }, Self::chill { .. }) => false,
                        (Self::set_payee { .. }, Self::set_controller { .. }) => false,
                        (Self::set_payee { .. }, Self::set_validator_count { .. }) => {
                            false
                        }
                        (
                            Self::set_payee { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (Self::set_payee { .. }, Self::scale_validator_count { .. }) => {
                            false
                        }
                        (Self::set_payee { .. }, Self::force_no_eras { .. }) => false,
                        (Self::set_payee { .. }, Self::force_new_era { .. }) => false,
                        (Self::set_payee { .. }, Self::set_invulnerables { .. }) => false,
                        (Self::set_payee { .. }, Self::force_unstake { .. }) => false,
                        (Self::set_payee { .. }, Self::force_new_era_always { .. }) => {
                            false
                        }
                        (Self::set_payee { .. }, Self::cancel_deferred_slash { .. }) => {
                            false
                        }
                        (Self::set_payee { .. }, Self::payout_stakers { .. }) => false,
                        (Self::set_payee { .. }, Self::rebond { .. }) => false,
                        (Self::set_payee { .. }, Self::reap_stash { .. }) => false,
                        (Self::set_payee { .. }, Self::kick { .. }) => false,
                        (Self::set_payee { .. }, Self::set_staking_configs { .. }) => {
                            false
                        }
                        (Self::set_payee { .. }, Self::chill_other { .. }) => false,
                        (
                            Self::set_payee { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (Self::set_payee { .. }, Self::set_min_commission { .. }) => {
                            false
                        }
                        (Self::set_payee { .. }, Self::payout_stakers_by_page { .. }) => {
                            false
                        }
                        (Self::set_payee { .. }, Self::update_payee { .. }) => false,
                        (
                            Self::set_payee { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::set_payee { .. }, Self::restore_ledger { .. }) => false,
                        (Self::set_controller { .. }, Self::__Ignore { .. }) => false,
                        (Self::set_controller { .. }, Self::bond { .. }) => false,
                        (Self::set_controller { .. }, Self::bond_extra { .. }) => false,
                        (Self::set_controller { .. }, Self::unbond { .. }) => false,
                        (Self::set_controller { .. }, Self::withdraw_unbonded { .. }) => {
                            false
                        }
                        (Self::set_controller { .. }, Self::validate { .. }) => false,
                        (Self::set_controller { .. }, Self::nominate { .. }) => false,
                        (Self::set_controller { .. }, Self::chill { .. }) => false,
                        (Self::set_controller { .. }, Self::set_payee { .. }) => false,
                        (
                            Self::set_controller { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::set_controller { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::set_controller { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (Self::set_controller { .. }, Self::force_no_eras { .. }) => {
                            false
                        }
                        (Self::set_controller { .. }, Self::force_new_era { .. }) => {
                            false
                        }
                        (Self::set_controller { .. }, Self::set_invulnerables { .. }) => {
                            false
                        }
                        (Self::set_controller { .. }, Self::force_unstake { .. }) => {
                            false
                        }
                        (
                            Self::set_controller { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::set_controller { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (Self::set_controller { .. }, Self::payout_stakers { .. }) => {
                            false
                        }
                        (Self::set_controller { .. }, Self::rebond { .. }) => false,
                        (Self::set_controller { .. }, Self::reap_stash { .. }) => false,
                        (Self::set_controller { .. }, Self::kick { .. }) => false,
                        (
                            Self::set_controller { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (Self::set_controller { .. }, Self::chill_other { .. }) => false,
                        (
                            Self::set_controller { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (
                            Self::set_controller { .. },
                            Self::set_min_commission { .. },
                        ) => false,
                        (
                            Self::set_controller { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (Self::set_controller { .. }, Self::update_payee { .. }) => false,
                        (
                            Self::set_controller { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::set_controller { .. }, Self::restore_ledger { .. }) => {
                            false
                        }
                        (Self::set_validator_count { .. }, Self::__Ignore { .. }) => {
                            false
                        }
                        (Self::set_validator_count { .. }, Self::bond { .. }) => false,
                        (Self::set_validator_count { .. }, Self::bond_extra { .. }) => {
                            false
                        }
                        (Self::set_validator_count { .. }, Self::unbond { .. }) => false,
                        (
                            Self::set_validator_count { .. },
                            Self::withdraw_unbonded { .. },
                        ) => false,
                        (Self::set_validator_count { .. }, Self::validate { .. }) => {
                            false
                        }
                        (Self::set_validator_count { .. }, Self::nominate { .. }) => {
                            false
                        }
                        (Self::set_validator_count { .. }, Self::chill { .. }) => false,
                        (Self::set_validator_count { .. }, Self::set_payee { .. }) => {
                            false
                        }
                        (
                            Self::set_validator_count { .. },
                            Self::set_controller { .. },
                        ) => false,
                        (
                            Self::set_validator_count { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::set_validator_count { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (
                            Self::set_validator_count { .. },
                            Self::force_no_eras { .. },
                        ) => false,
                        (
                            Self::set_validator_count { .. },
                            Self::force_new_era { .. },
                        ) => false,
                        (
                            Self::set_validator_count { .. },
                            Self::set_invulnerables { .. },
                        ) => false,
                        (
                            Self::set_validator_count { .. },
                            Self::force_unstake { .. },
                        ) => false,
                        (
                            Self::set_validator_count { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::set_validator_count { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (
                            Self::set_validator_count { .. },
                            Self::payout_stakers { .. },
                        ) => false,
                        (Self::set_validator_count { .. }, Self::rebond { .. }) => false,
                        (Self::set_validator_count { .. }, Self::reap_stash { .. }) => {
                            false
                        }
                        (Self::set_validator_count { .. }, Self::kick { .. }) => false,
                        (
                            Self::set_validator_count { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (Self::set_validator_count { .. }, Self::chill_other { .. }) => {
                            false
                        }
                        (
                            Self::set_validator_count { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (
                            Self::set_validator_count { .. },
                            Self::set_min_commission { .. },
                        ) => false,
                        (
                            Self::set_validator_count { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (Self::set_validator_count { .. }, Self::update_payee { .. }) => {
                            false
                        }
                        (
                            Self::set_validator_count { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (
                            Self::set_validator_count { .. },
                            Self::restore_ledger { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::__Ignore { .. },
                        ) => false,
                        (Self::increase_validator_count { .. }, Self::bond { .. }) => {
                            false
                        }
                        (
                            Self::increase_validator_count { .. },
                            Self::bond_extra { .. },
                        ) => false,
                        (Self::increase_validator_count { .. }, Self::unbond { .. }) => {
                            false
                        }
                        (
                            Self::increase_validator_count { .. },
                            Self::withdraw_unbonded { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::validate { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::nominate { .. },
                        ) => false,
                        (Self::increase_validator_count { .. }, Self::chill { .. }) => {
                            false
                        }
                        (
                            Self::increase_validator_count { .. },
                            Self::set_payee { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::set_controller { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::force_no_eras { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::force_new_era { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::set_invulnerables { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::force_unstake { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::payout_stakers { .. },
                        ) => false,
                        (Self::increase_validator_count { .. }, Self::rebond { .. }) => {
                            false
                        }
                        (
                            Self::increase_validator_count { .. },
                            Self::reap_stash { .. },
                        ) => false,
                        (Self::increase_validator_count { .. }, Self::kick { .. }) => {
                            false
                        }
                        (
                            Self::increase_validator_count { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::chill_other { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::set_min_commission { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::update_payee { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (
                            Self::increase_validator_count { .. },
                            Self::restore_ledger { .. },
                        ) => false,
                        (Self::scale_validator_count { .. }, Self::__Ignore { .. }) => {
                            false
                        }
                        (Self::scale_validator_count { .. }, Self::bond { .. }) => false,
                        (Self::scale_validator_count { .. }, Self::bond_extra { .. }) => {
                            false
                        }
                        (Self::scale_validator_count { .. }, Self::unbond { .. }) => {
                            false
                        }
                        (
                            Self::scale_validator_count { .. },
                            Self::withdraw_unbonded { .. },
                        ) => false,
                        (Self::scale_validator_count { .. }, Self::validate { .. }) => {
                            false
                        }
                        (Self::scale_validator_count { .. }, Self::nominate { .. }) => {
                            false
                        }
                        (Self::scale_validator_count { .. }, Self::chill { .. }) => false,
                        (Self::scale_validator_count { .. }, Self::set_payee { .. }) => {
                            false
                        }
                        (
                            Self::scale_validator_count { .. },
                            Self::set_controller { .. },
                        ) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::force_no_eras { .. },
                        ) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::force_new_era { .. },
                        ) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::set_invulnerables { .. },
                        ) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::force_unstake { .. },
                        ) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::payout_stakers { .. },
                        ) => false,
                        (Self::scale_validator_count { .. }, Self::rebond { .. }) => {
                            false
                        }
                        (Self::scale_validator_count { .. }, Self::reap_stash { .. }) => {
                            false
                        }
                        (Self::scale_validator_count { .. }, Self::kick { .. }) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::chill_other { .. },
                        ) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::set_min_commission { .. },
                        ) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::update_payee { .. },
                        ) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (
                            Self::scale_validator_count { .. },
                            Self::restore_ledger { .. },
                        ) => false,
                        (Self::force_no_eras { .. }, Self::__Ignore { .. }) => false,
                        (Self::force_no_eras { .. }, Self::bond { .. }) => false,
                        (Self::force_no_eras { .. }, Self::bond_extra { .. }) => false,
                        (Self::force_no_eras { .. }, Self::unbond { .. }) => false,
                        (Self::force_no_eras { .. }, Self::withdraw_unbonded { .. }) => {
                            false
                        }
                        (Self::force_no_eras { .. }, Self::validate { .. }) => false,
                        (Self::force_no_eras { .. }, Self::nominate { .. }) => false,
                        (Self::force_no_eras { .. }, Self::chill { .. }) => false,
                        (Self::force_no_eras { .. }, Self::set_payee { .. }) => false,
                        (Self::force_no_eras { .. }, Self::set_controller { .. }) => {
                            false
                        }
                        (
                            Self::force_no_eras { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::force_no_eras { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::force_no_eras { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (Self::force_no_eras { .. }, Self::force_new_era { .. }) => false,
                        (Self::force_no_eras { .. }, Self::set_invulnerables { .. }) => {
                            false
                        }
                        (Self::force_no_eras { .. }, Self::force_unstake { .. }) => false,
                        (
                            Self::force_no_eras { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::force_no_eras { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (Self::force_no_eras { .. }, Self::payout_stakers { .. }) => {
                            false
                        }
                        (Self::force_no_eras { .. }, Self::rebond { .. }) => false,
                        (Self::force_no_eras { .. }, Self::reap_stash { .. }) => false,
                        (Self::force_no_eras { .. }, Self::kick { .. }) => false,
                        (
                            Self::force_no_eras { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (Self::force_no_eras { .. }, Self::chill_other { .. }) => false,
                        (
                            Self::force_no_eras { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (Self::force_no_eras { .. }, Self::set_min_commission { .. }) => {
                            false
                        }
                        (
                            Self::force_no_eras { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (Self::force_no_eras { .. }, Self::update_payee { .. }) => false,
                        (
                            Self::force_no_eras { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::force_no_eras { .. }, Self::restore_ledger { .. }) => {
                            false
                        }
                        (Self::force_new_era { .. }, Self::__Ignore { .. }) => false,
                        (Self::force_new_era { .. }, Self::bond { .. }) => false,
                        (Self::force_new_era { .. }, Self::bond_extra { .. }) => false,
                        (Self::force_new_era { .. }, Self::unbond { .. }) => false,
                        (Self::force_new_era { .. }, Self::withdraw_unbonded { .. }) => {
                            false
                        }
                        (Self::force_new_era { .. }, Self::validate { .. }) => false,
                        (Self::force_new_era { .. }, Self::nominate { .. }) => false,
                        (Self::force_new_era { .. }, Self::chill { .. }) => false,
                        (Self::force_new_era { .. }, Self::set_payee { .. }) => false,
                        (Self::force_new_era { .. }, Self::set_controller { .. }) => {
                            false
                        }
                        (
                            Self::force_new_era { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::force_new_era { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::force_new_era { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (Self::force_new_era { .. }, Self::force_no_eras { .. }) => false,
                        (Self::force_new_era { .. }, Self::set_invulnerables { .. }) => {
                            false
                        }
                        (Self::force_new_era { .. }, Self::force_unstake { .. }) => false,
                        (
                            Self::force_new_era { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::force_new_era { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (Self::force_new_era { .. }, Self::payout_stakers { .. }) => {
                            false
                        }
                        (Self::force_new_era { .. }, Self::rebond { .. }) => false,
                        (Self::force_new_era { .. }, Self::reap_stash { .. }) => false,
                        (Self::force_new_era { .. }, Self::kick { .. }) => false,
                        (
                            Self::force_new_era { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (Self::force_new_era { .. }, Self::chill_other { .. }) => false,
                        (
                            Self::force_new_era { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (Self::force_new_era { .. }, Self::set_min_commission { .. }) => {
                            false
                        }
                        (
                            Self::force_new_era { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (Self::force_new_era { .. }, Self::update_payee { .. }) => false,
                        (
                            Self::force_new_era { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::force_new_era { .. }, Self::restore_ledger { .. }) => {
                            false
                        }
                        (Self::set_invulnerables { .. }, Self::__Ignore { .. }) => false,
                        (Self::set_invulnerables { .. }, Self::bond { .. }) => false,
                        (Self::set_invulnerables { .. }, Self::bond_extra { .. }) => {
                            false
                        }
                        (Self::set_invulnerables { .. }, Self::unbond { .. }) => false,
                        (
                            Self::set_invulnerables { .. },
                            Self::withdraw_unbonded { .. },
                        ) => false,
                        (Self::set_invulnerables { .. }, Self::validate { .. }) => false,
                        (Self::set_invulnerables { .. }, Self::nominate { .. }) => false,
                        (Self::set_invulnerables { .. }, Self::chill { .. }) => false,
                        (Self::set_invulnerables { .. }, Self::set_payee { .. }) => false,
                        (Self::set_invulnerables { .. }, Self::set_controller { .. }) => {
                            false
                        }
                        (
                            Self::set_invulnerables { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::set_invulnerables { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::set_invulnerables { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (Self::set_invulnerables { .. }, Self::force_no_eras { .. }) => {
                            false
                        }
                        (Self::set_invulnerables { .. }, Self::force_new_era { .. }) => {
                            false
                        }
                        (Self::set_invulnerables { .. }, Self::force_unstake { .. }) => {
                            false
                        }
                        (
                            Self::set_invulnerables { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::set_invulnerables { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (Self::set_invulnerables { .. }, Self::payout_stakers { .. }) => {
                            false
                        }
                        (Self::set_invulnerables { .. }, Self::rebond { .. }) => false,
                        (Self::set_invulnerables { .. }, Self::reap_stash { .. }) => {
                            false
                        }
                        (Self::set_invulnerables { .. }, Self::kick { .. }) => false,
                        (
                            Self::set_invulnerables { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (Self::set_invulnerables { .. }, Self::chill_other { .. }) => {
                            false
                        }
                        (
                            Self::set_invulnerables { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (
                            Self::set_invulnerables { .. },
                            Self::set_min_commission { .. },
                        ) => false,
                        (
                            Self::set_invulnerables { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (Self::set_invulnerables { .. }, Self::update_payee { .. }) => {
                            false
                        }
                        (
                            Self::set_invulnerables { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::set_invulnerables { .. }, Self::restore_ledger { .. }) => {
                            false
                        }
                        (Self::force_unstake { .. }, Self::__Ignore { .. }) => false,
                        (Self::force_unstake { .. }, Self::bond { .. }) => false,
                        (Self::force_unstake { .. }, Self::bond_extra { .. }) => false,
                        (Self::force_unstake { .. }, Self::unbond { .. }) => false,
                        (Self::force_unstake { .. }, Self::withdraw_unbonded { .. }) => {
                            false
                        }
                        (Self::force_unstake { .. }, Self::validate { .. }) => false,
                        (Self::force_unstake { .. }, Self::nominate { .. }) => false,
                        (Self::force_unstake { .. }, Self::chill { .. }) => false,
                        (Self::force_unstake { .. }, Self::set_payee { .. }) => false,
                        (Self::force_unstake { .. }, Self::set_controller { .. }) => {
                            false
                        }
                        (
                            Self::force_unstake { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::force_unstake { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::force_unstake { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (Self::force_unstake { .. }, Self::force_no_eras { .. }) => false,
                        (Self::force_unstake { .. }, Self::force_new_era { .. }) => false,
                        (Self::force_unstake { .. }, Self::set_invulnerables { .. }) => {
                            false
                        }
                        (
                            Self::force_unstake { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::force_unstake { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (Self::force_unstake { .. }, Self::payout_stakers { .. }) => {
                            false
                        }
                        (Self::force_unstake { .. }, Self::rebond { .. }) => false,
                        (Self::force_unstake { .. }, Self::reap_stash { .. }) => false,
                        (Self::force_unstake { .. }, Self::kick { .. }) => false,
                        (
                            Self::force_unstake { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (Self::force_unstake { .. }, Self::chill_other { .. }) => false,
                        (
                            Self::force_unstake { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (Self::force_unstake { .. }, Self::set_min_commission { .. }) => {
                            false
                        }
                        (
                            Self::force_unstake { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (Self::force_unstake { .. }, Self::update_payee { .. }) => false,
                        (
                            Self::force_unstake { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::force_unstake { .. }, Self::restore_ledger { .. }) => {
                            false
                        }
                        (Self::force_new_era_always { .. }, Self::__Ignore { .. }) => {
                            false
                        }
                        (Self::force_new_era_always { .. }, Self::bond { .. }) => false,
                        (Self::force_new_era_always { .. }, Self::bond_extra { .. }) => {
                            false
                        }
                        (Self::force_new_era_always { .. }, Self::unbond { .. }) => false,
                        (
                            Self::force_new_era_always { .. },
                            Self::withdraw_unbonded { .. },
                        ) => false,
                        (Self::force_new_era_always { .. }, Self::validate { .. }) => {
                            false
                        }
                        (Self::force_new_era_always { .. }, Self::nominate { .. }) => {
                            false
                        }
                        (Self::force_new_era_always { .. }, Self::chill { .. }) => false,
                        (Self::force_new_era_always { .. }, Self::set_payee { .. }) => {
                            false
                        }
                        (
                            Self::force_new_era_always { .. },
                            Self::set_controller { .. },
                        ) => false,
                        (
                            Self::force_new_era_always { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::force_new_era_always { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::force_new_era_always { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (
                            Self::force_new_era_always { .. },
                            Self::force_no_eras { .. },
                        ) => false,
                        (
                            Self::force_new_era_always { .. },
                            Self::force_new_era { .. },
                        ) => false,
                        (
                            Self::force_new_era_always { .. },
                            Self::set_invulnerables { .. },
                        ) => false,
                        (
                            Self::force_new_era_always { .. },
                            Self::force_unstake { .. },
                        ) => false,
                        (
                            Self::force_new_era_always { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (
                            Self::force_new_era_always { .. },
                            Self::payout_stakers { .. },
                        ) => false,
                        (Self::force_new_era_always { .. }, Self::rebond { .. }) => false,
                        (Self::force_new_era_always { .. }, Self::reap_stash { .. }) => {
                            false
                        }
                        (Self::force_new_era_always { .. }, Self::kick { .. }) => false,
                        (
                            Self::force_new_era_always { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (Self::force_new_era_always { .. }, Self::chill_other { .. }) => {
                            false
                        }
                        (
                            Self::force_new_era_always { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (
                            Self::force_new_era_always { .. },
                            Self::set_min_commission { .. },
                        ) => false,
                        (
                            Self::force_new_era_always { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (
                            Self::force_new_era_always { .. },
                            Self::update_payee { .. },
                        ) => false,
                        (
                            Self::force_new_era_always { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (
                            Self::force_new_era_always { .. },
                            Self::restore_ledger { .. },
                        ) => false,
                        (Self::cancel_deferred_slash { .. }, Self::__Ignore { .. }) => {
                            false
                        }
                        (Self::cancel_deferred_slash { .. }, Self::bond { .. }) => false,
                        (Self::cancel_deferred_slash { .. }, Self::bond_extra { .. }) => {
                            false
                        }
                        (Self::cancel_deferred_slash { .. }, Self::unbond { .. }) => {
                            false
                        }
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::withdraw_unbonded { .. },
                        ) => false,
                        (Self::cancel_deferred_slash { .. }, Self::validate { .. }) => {
                            false
                        }
                        (Self::cancel_deferred_slash { .. }, Self::nominate { .. }) => {
                            false
                        }
                        (Self::cancel_deferred_slash { .. }, Self::chill { .. }) => false,
                        (Self::cancel_deferred_slash { .. }, Self::set_payee { .. }) => {
                            false
                        }
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::set_controller { .. },
                        ) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::force_no_eras { .. },
                        ) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::force_new_era { .. },
                        ) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::set_invulnerables { .. },
                        ) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::force_unstake { .. },
                        ) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::payout_stakers { .. },
                        ) => false,
                        (Self::cancel_deferred_slash { .. }, Self::rebond { .. }) => {
                            false
                        }
                        (Self::cancel_deferred_slash { .. }, Self::reap_stash { .. }) => {
                            false
                        }
                        (Self::cancel_deferred_slash { .. }, Self::kick { .. }) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::chill_other { .. },
                        ) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::set_min_commission { .. },
                        ) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::update_payee { .. },
                        ) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (
                            Self::cancel_deferred_slash { .. },
                            Self::restore_ledger { .. },
                        ) => false,
                        (Self::payout_stakers { .. }, Self::__Ignore { .. }) => false,
                        (Self::payout_stakers { .. }, Self::bond { .. }) => false,
                        (Self::payout_stakers { .. }, Self::bond_extra { .. }) => false,
                        (Self::payout_stakers { .. }, Self::unbond { .. }) => false,
                        (Self::payout_stakers { .. }, Self::withdraw_unbonded { .. }) => {
                            false
                        }
                        (Self::payout_stakers { .. }, Self::validate { .. }) => false,
                        (Self::payout_stakers { .. }, Self::nominate { .. }) => false,
                        (Self::payout_stakers { .. }, Self::chill { .. }) => false,
                        (Self::payout_stakers { .. }, Self::set_payee { .. }) => false,
                        (Self::payout_stakers { .. }, Self::set_controller { .. }) => {
                            false
                        }
                        (
                            Self::payout_stakers { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::payout_stakers { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::payout_stakers { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (Self::payout_stakers { .. }, Self::force_no_eras { .. }) => {
                            false
                        }
                        (Self::payout_stakers { .. }, Self::force_new_era { .. }) => {
                            false
                        }
                        (Self::payout_stakers { .. }, Self::set_invulnerables { .. }) => {
                            false
                        }
                        (Self::payout_stakers { .. }, Self::force_unstake { .. }) => {
                            false
                        }
                        (
                            Self::payout_stakers { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::payout_stakers { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (Self::payout_stakers { .. }, Self::rebond { .. }) => false,
                        (Self::payout_stakers { .. }, Self::reap_stash { .. }) => false,
                        (Self::payout_stakers { .. }, Self::kick { .. }) => false,
                        (
                            Self::payout_stakers { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (Self::payout_stakers { .. }, Self::chill_other { .. }) => false,
                        (
                            Self::payout_stakers { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (
                            Self::payout_stakers { .. },
                            Self::set_min_commission { .. },
                        ) => false,
                        (
                            Self::payout_stakers { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (Self::payout_stakers { .. }, Self::update_payee { .. }) => false,
                        (
                            Self::payout_stakers { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::payout_stakers { .. }, Self::restore_ledger { .. }) => {
                            false
                        }
                        (Self::rebond { .. }, Self::__Ignore { .. }) => false,
                        (Self::rebond { .. }, Self::bond { .. }) => false,
                        (Self::rebond { .. }, Self::bond_extra { .. }) => false,
                        (Self::rebond { .. }, Self::unbond { .. }) => false,
                        (Self::rebond { .. }, Self::withdraw_unbonded { .. }) => false,
                        (Self::rebond { .. }, Self::validate { .. }) => false,
                        (Self::rebond { .. }, Self::nominate { .. }) => false,
                        (Self::rebond { .. }, Self::chill { .. }) => false,
                        (Self::rebond { .. }, Self::set_payee { .. }) => false,
                        (Self::rebond { .. }, Self::set_controller { .. }) => false,
                        (Self::rebond { .. }, Self::set_validator_count { .. }) => false,
                        (Self::rebond { .. }, Self::increase_validator_count { .. }) => {
                            false
                        }
                        (Self::rebond { .. }, Self::scale_validator_count { .. }) => {
                            false
                        }
                        (Self::rebond { .. }, Self::force_no_eras { .. }) => false,
                        (Self::rebond { .. }, Self::force_new_era { .. }) => false,
                        (Self::rebond { .. }, Self::set_invulnerables { .. }) => false,
                        (Self::rebond { .. }, Self::force_unstake { .. }) => false,
                        (Self::rebond { .. }, Self::force_new_era_always { .. }) => false,
                        (Self::rebond { .. }, Self::cancel_deferred_slash { .. }) => {
                            false
                        }
                        (Self::rebond { .. }, Self::payout_stakers { .. }) => false,
                        (Self::rebond { .. }, Self::reap_stash { .. }) => false,
                        (Self::rebond { .. }, Self::kick { .. }) => false,
                        (Self::rebond { .. }, Self::set_staking_configs { .. }) => false,
                        (Self::rebond { .. }, Self::chill_other { .. }) => false,
                        (
                            Self::rebond { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (Self::rebond { .. }, Self::set_min_commission { .. }) => false,
                        (Self::rebond { .. }, Self::payout_stakers_by_page { .. }) => {
                            false
                        }
                        (Self::rebond { .. }, Self::update_payee { .. }) => false,
                        (
                            Self::rebond { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::rebond { .. }, Self::restore_ledger { .. }) => false,
                        (Self::reap_stash { .. }, Self::__Ignore { .. }) => false,
                        (Self::reap_stash { .. }, Self::bond { .. }) => false,
                        (Self::reap_stash { .. }, Self::bond_extra { .. }) => false,
                        (Self::reap_stash { .. }, Self::unbond { .. }) => false,
                        (Self::reap_stash { .. }, Self::withdraw_unbonded { .. }) => {
                            false
                        }
                        (Self::reap_stash { .. }, Self::validate { .. }) => false,
                        (Self::reap_stash { .. }, Self::nominate { .. }) => false,
                        (Self::reap_stash { .. }, Self::chill { .. }) => false,
                        (Self::reap_stash { .. }, Self::set_payee { .. }) => false,
                        (Self::reap_stash { .. }, Self::set_controller { .. }) => false,
                        (Self::reap_stash { .. }, Self::set_validator_count { .. }) => {
                            false
                        }
                        (
                            Self::reap_stash { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (Self::reap_stash { .. }, Self::scale_validator_count { .. }) => {
                            false
                        }
                        (Self::reap_stash { .. }, Self::force_no_eras { .. }) => false,
                        (Self::reap_stash { .. }, Self::force_new_era { .. }) => false,
                        (Self::reap_stash { .. }, Self::set_invulnerables { .. }) => {
                            false
                        }
                        (Self::reap_stash { .. }, Self::force_unstake { .. }) => false,
                        (Self::reap_stash { .. }, Self::force_new_era_always { .. }) => {
                            false
                        }
                        (Self::reap_stash { .. }, Self::cancel_deferred_slash { .. }) => {
                            false
                        }
                        (Self::reap_stash { .. }, Self::payout_stakers { .. }) => false,
                        (Self::reap_stash { .. }, Self::rebond { .. }) => false,
                        (Self::reap_stash { .. }, Self::kick { .. }) => false,
                        (Self::reap_stash { .. }, Self::set_staking_configs { .. }) => {
                            false
                        }
                        (Self::reap_stash { .. }, Self::chill_other { .. }) => false,
                        (
                            Self::reap_stash { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (Self::reap_stash { .. }, Self::set_min_commission { .. }) => {
                            false
                        }
                        (
                            Self::reap_stash { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (Self::reap_stash { .. }, Self::update_payee { .. }) => false,
                        (
                            Self::reap_stash { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::reap_stash { .. }, Self::restore_ledger { .. }) => false,
                        (Self::kick { .. }, Self::__Ignore { .. }) => false,
                        (Self::kick { .. }, Self::bond { .. }) => false,
                        (Self::kick { .. }, Self::bond_extra { .. }) => false,
                        (Self::kick { .. }, Self::unbond { .. }) => false,
                        (Self::kick { .. }, Self::withdraw_unbonded { .. }) => false,
                        (Self::kick { .. }, Self::validate { .. }) => false,
                        (Self::kick { .. }, Self::nominate { .. }) => false,
                        (Self::kick { .. }, Self::chill { .. }) => false,
                        (Self::kick { .. }, Self::set_payee { .. }) => false,
                        (Self::kick { .. }, Self::set_controller { .. }) => false,
                        (Self::kick { .. }, Self::set_validator_count { .. }) => false,
                        (Self::kick { .. }, Self::increase_validator_count { .. }) => {
                            false
                        }
                        (Self::kick { .. }, Self::scale_validator_count { .. }) => false,
                        (Self::kick { .. }, Self::force_no_eras { .. }) => false,
                        (Self::kick { .. }, Self::force_new_era { .. }) => false,
                        (Self::kick { .. }, Self::set_invulnerables { .. }) => false,
                        (Self::kick { .. }, Self::force_unstake { .. }) => false,
                        (Self::kick { .. }, Self::force_new_era_always { .. }) => false,
                        (Self::kick { .. }, Self::cancel_deferred_slash { .. }) => false,
                        (Self::kick { .. }, Self::payout_stakers { .. }) => false,
                        (Self::kick { .. }, Self::rebond { .. }) => false,
                        (Self::kick { .. }, Self::reap_stash { .. }) => false,
                        (Self::kick { .. }, Self::set_staking_configs { .. }) => false,
                        (Self::kick { .. }, Self::chill_other { .. }) => false,
                        (Self::kick { .. }, Self::force_apply_min_commission { .. }) => {
                            false
                        }
                        (Self::kick { .. }, Self::set_min_commission { .. }) => false,
                        (Self::kick { .. }, Self::payout_stakers_by_page { .. }) => false,
                        (Self::kick { .. }, Self::update_payee { .. }) => false,
                        (Self::kick { .. }, Self::deprecate_controller_batch { .. }) => {
                            false
                        }
                        (Self::kick { .. }, Self::restore_ledger { .. }) => false,
                        (Self::set_staking_configs { .. }, Self::__Ignore { .. }) => {
                            false
                        }
                        (Self::set_staking_configs { .. }, Self::bond { .. }) => false,
                        (Self::set_staking_configs { .. }, Self::bond_extra { .. }) => {
                            false
                        }
                        (Self::set_staking_configs { .. }, Self::unbond { .. }) => false,
                        (
                            Self::set_staking_configs { .. },
                            Self::withdraw_unbonded { .. },
                        ) => false,
                        (Self::set_staking_configs { .. }, Self::validate { .. }) => {
                            false
                        }
                        (Self::set_staking_configs { .. }, Self::nominate { .. }) => {
                            false
                        }
                        (Self::set_staking_configs { .. }, Self::chill { .. }) => false,
                        (Self::set_staking_configs { .. }, Self::set_payee { .. }) => {
                            false
                        }
                        (
                            Self::set_staking_configs { .. },
                            Self::set_controller { .. },
                        ) => false,
                        (
                            Self::set_staking_configs { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::set_staking_configs { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::set_staking_configs { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (
                            Self::set_staking_configs { .. },
                            Self::force_no_eras { .. },
                        ) => false,
                        (
                            Self::set_staking_configs { .. },
                            Self::force_new_era { .. },
                        ) => false,
                        (
                            Self::set_staking_configs { .. },
                            Self::set_invulnerables { .. },
                        ) => false,
                        (
                            Self::set_staking_configs { .. },
                            Self::force_unstake { .. },
                        ) => false,
                        (
                            Self::set_staking_configs { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::set_staking_configs { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (
                            Self::set_staking_configs { .. },
                            Self::payout_stakers { .. },
                        ) => false,
                        (Self::set_staking_configs { .. }, Self::rebond { .. }) => false,
                        (Self::set_staking_configs { .. }, Self::reap_stash { .. }) => {
                            false
                        }
                        (Self::set_staking_configs { .. }, Self::kick { .. }) => false,
                        (Self::set_staking_configs { .. }, Self::chill_other { .. }) => {
                            false
                        }
                        (
                            Self::set_staking_configs { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (
                            Self::set_staking_configs { .. },
                            Self::set_min_commission { .. },
                        ) => false,
                        (
                            Self::set_staking_configs { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (Self::set_staking_configs { .. }, Self::update_payee { .. }) => {
                            false
                        }
                        (
                            Self::set_staking_configs { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (
                            Self::set_staking_configs { .. },
                            Self::restore_ledger { .. },
                        ) => false,
                        (Self::chill_other { .. }, Self::__Ignore { .. }) => false,
                        (Self::chill_other { .. }, Self::bond { .. }) => false,
                        (Self::chill_other { .. }, Self::bond_extra { .. }) => false,
                        (Self::chill_other { .. }, Self::unbond { .. }) => false,
                        (Self::chill_other { .. }, Self::withdraw_unbonded { .. }) => {
                            false
                        }
                        (Self::chill_other { .. }, Self::validate { .. }) => false,
                        (Self::chill_other { .. }, Self::nominate { .. }) => false,
                        (Self::chill_other { .. }, Self::chill { .. }) => false,
                        (Self::chill_other { .. }, Self::set_payee { .. }) => false,
                        (Self::chill_other { .. }, Self::set_controller { .. }) => false,
                        (Self::chill_other { .. }, Self::set_validator_count { .. }) => {
                            false
                        }
                        (
                            Self::chill_other { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::chill_other { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (Self::chill_other { .. }, Self::force_no_eras { .. }) => false,
                        (Self::chill_other { .. }, Self::force_new_era { .. }) => false,
                        (Self::chill_other { .. }, Self::set_invulnerables { .. }) => {
                            false
                        }
                        (Self::chill_other { .. }, Self::force_unstake { .. }) => false,
                        (Self::chill_other { .. }, Self::force_new_era_always { .. }) => {
                            false
                        }
                        (
                            Self::chill_other { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (Self::chill_other { .. }, Self::payout_stakers { .. }) => false,
                        (Self::chill_other { .. }, Self::rebond { .. }) => false,
                        (Self::chill_other { .. }, Self::reap_stash { .. }) => false,
                        (Self::chill_other { .. }, Self::kick { .. }) => false,
                        (Self::chill_other { .. }, Self::set_staking_configs { .. }) => {
                            false
                        }
                        (
                            Self::chill_other { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (Self::chill_other { .. }, Self::set_min_commission { .. }) => {
                            false
                        }
                        (
                            Self::chill_other { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (Self::chill_other { .. }, Self::update_payee { .. }) => false,
                        (
                            Self::chill_other { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::chill_other { .. }, Self::restore_ledger { .. }) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::__Ignore { .. },
                        ) => false,
                        (Self::force_apply_min_commission { .. }, Self::bond { .. }) => {
                            false
                        }
                        (
                            Self::force_apply_min_commission { .. },
                            Self::bond_extra { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::unbond { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::withdraw_unbonded { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::validate { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::nominate { .. },
                        ) => false,
                        (Self::force_apply_min_commission { .. }, Self::chill { .. }) => {
                            false
                        }
                        (
                            Self::force_apply_min_commission { .. },
                            Self::set_payee { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::set_controller { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::force_no_eras { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::force_new_era { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::set_invulnerables { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::force_unstake { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::payout_stakers { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::rebond { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::reap_stash { .. },
                        ) => false,
                        (Self::force_apply_min_commission { .. }, Self::kick { .. }) => {
                            false
                        }
                        (
                            Self::force_apply_min_commission { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::chill_other { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::set_min_commission { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::update_payee { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (
                            Self::force_apply_min_commission { .. },
                            Self::restore_ledger { .. },
                        ) => false,
                        (Self::set_min_commission { .. }, Self::__Ignore { .. }) => false,
                        (Self::set_min_commission { .. }, Self::bond { .. }) => false,
                        (Self::set_min_commission { .. }, Self::bond_extra { .. }) => {
                            false
                        }
                        (Self::set_min_commission { .. }, Self::unbond { .. }) => false,
                        (
                            Self::set_min_commission { .. },
                            Self::withdraw_unbonded { .. },
                        ) => false,
                        (Self::set_min_commission { .. }, Self::validate { .. }) => false,
                        (Self::set_min_commission { .. }, Self::nominate { .. }) => false,
                        (Self::set_min_commission { .. }, Self::chill { .. }) => false,
                        (Self::set_min_commission { .. }, Self::set_payee { .. }) => {
                            false
                        }
                        (
                            Self::set_min_commission { .. },
                            Self::set_controller { .. },
                        ) => false,
                        (
                            Self::set_min_commission { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::set_min_commission { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::set_min_commission { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (Self::set_min_commission { .. }, Self::force_no_eras { .. }) => {
                            false
                        }
                        (Self::set_min_commission { .. }, Self::force_new_era { .. }) => {
                            false
                        }
                        (
                            Self::set_min_commission { .. },
                            Self::set_invulnerables { .. },
                        ) => false,
                        (Self::set_min_commission { .. }, Self::force_unstake { .. }) => {
                            false
                        }
                        (
                            Self::set_min_commission { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::set_min_commission { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (
                            Self::set_min_commission { .. },
                            Self::payout_stakers { .. },
                        ) => false,
                        (Self::set_min_commission { .. }, Self::rebond { .. }) => false,
                        (Self::set_min_commission { .. }, Self::reap_stash { .. }) => {
                            false
                        }
                        (Self::set_min_commission { .. }, Self::kick { .. }) => false,
                        (
                            Self::set_min_commission { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (Self::set_min_commission { .. }, Self::chill_other { .. }) => {
                            false
                        }
                        (
                            Self::set_min_commission { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (
                            Self::set_min_commission { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (Self::set_min_commission { .. }, Self::update_payee { .. }) => {
                            false
                        }
                        (
                            Self::set_min_commission { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (
                            Self::set_min_commission { .. },
                            Self::restore_ledger { .. },
                        ) => false,
                        (Self::payout_stakers_by_page { .. }, Self::__Ignore { .. }) => {
                            false
                        }
                        (Self::payout_stakers_by_page { .. }, Self::bond { .. }) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::bond_extra { .. },
                        ) => false,
                        (Self::payout_stakers_by_page { .. }, Self::unbond { .. }) => {
                            false
                        }
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::withdraw_unbonded { .. },
                        ) => false,
                        (Self::payout_stakers_by_page { .. }, Self::validate { .. }) => {
                            false
                        }
                        (Self::payout_stakers_by_page { .. }, Self::nominate { .. }) => {
                            false
                        }
                        (Self::payout_stakers_by_page { .. }, Self::chill { .. }) => {
                            false
                        }
                        (Self::payout_stakers_by_page { .. }, Self::set_payee { .. }) => {
                            false
                        }
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::set_controller { .. },
                        ) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::force_no_eras { .. },
                        ) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::force_new_era { .. },
                        ) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::set_invulnerables { .. },
                        ) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::force_unstake { .. },
                        ) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::payout_stakers { .. },
                        ) => false,
                        (Self::payout_stakers_by_page { .. }, Self::rebond { .. }) => {
                            false
                        }
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::reap_stash { .. },
                        ) => false,
                        (Self::payout_stakers_by_page { .. }, Self::kick { .. }) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::chill_other { .. },
                        ) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::set_min_commission { .. },
                        ) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::update_payee { .. },
                        ) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (
                            Self::payout_stakers_by_page { .. },
                            Self::restore_ledger { .. },
                        ) => false,
                        (Self::update_payee { .. }, Self::__Ignore { .. }) => false,
                        (Self::update_payee { .. }, Self::bond { .. }) => false,
                        (Self::update_payee { .. }, Self::bond_extra { .. }) => false,
                        (Self::update_payee { .. }, Self::unbond { .. }) => false,
                        (Self::update_payee { .. }, Self::withdraw_unbonded { .. }) => {
                            false
                        }
                        (Self::update_payee { .. }, Self::validate { .. }) => false,
                        (Self::update_payee { .. }, Self::nominate { .. }) => false,
                        (Self::update_payee { .. }, Self::chill { .. }) => false,
                        (Self::update_payee { .. }, Self::set_payee { .. }) => false,
                        (Self::update_payee { .. }, Self::set_controller { .. }) => false,
                        (Self::update_payee { .. }, Self::set_validator_count { .. }) => {
                            false
                        }
                        (
                            Self::update_payee { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::update_payee { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (Self::update_payee { .. }, Self::force_no_eras { .. }) => false,
                        (Self::update_payee { .. }, Self::force_new_era { .. }) => false,
                        (Self::update_payee { .. }, Self::set_invulnerables { .. }) => {
                            false
                        }
                        (Self::update_payee { .. }, Self::force_unstake { .. }) => false,
                        (
                            Self::update_payee { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::update_payee { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (Self::update_payee { .. }, Self::payout_stakers { .. }) => false,
                        (Self::update_payee { .. }, Self::rebond { .. }) => false,
                        (Self::update_payee { .. }, Self::reap_stash { .. }) => false,
                        (Self::update_payee { .. }, Self::kick { .. }) => false,
                        (Self::update_payee { .. }, Self::set_staking_configs { .. }) => {
                            false
                        }
                        (Self::update_payee { .. }, Self::chill_other { .. }) => false,
                        (
                            Self::update_payee { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (Self::update_payee { .. }, Self::set_min_commission { .. }) => {
                            false
                        }
                        (
                            Self::update_payee { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (
                            Self::update_payee { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                        (Self::update_payee { .. }, Self::restore_ledger { .. }) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::__Ignore { .. },
                        ) => false,
                        (Self::deprecate_controller_batch { .. }, Self::bond { .. }) => {
                            false
                        }
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::bond_extra { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::unbond { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::withdraw_unbonded { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::validate { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::nominate { .. },
                        ) => false,
                        (Self::deprecate_controller_batch { .. }, Self::chill { .. }) => {
                            false
                        }
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::set_payee { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::set_controller { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::force_no_eras { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::force_new_era { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::set_invulnerables { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::force_unstake { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::payout_stakers { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::rebond { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::reap_stash { .. },
                        ) => false,
                        (Self::deprecate_controller_batch { .. }, Self::kick { .. }) => {
                            false
                        }
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::chill_other { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::set_min_commission { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::update_payee { .. },
                        ) => false,
                        (
                            Self::deprecate_controller_batch { .. },
                            Self::restore_ledger { .. },
                        ) => false,
                        (Self::restore_ledger { .. }, Self::__Ignore { .. }) => false,
                        (Self::restore_ledger { .. }, Self::bond { .. }) => false,
                        (Self::restore_ledger { .. }, Self::bond_extra { .. }) => false,
                        (Self::restore_ledger { .. }, Self::unbond { .. }) => false,
                        (Self::restore_ledger { .. }, Self::withdraw_unbonded { .. }) => {
                            false
                        }
                        (Self::restore_ledger { .. }, Self::validate { .. }) => false,
                        (Self::restore_ledger { .. }, Self::nominate { .. }) => false,
                        (Self::restore_ledger { .. }, Self::chill { .. }) => false,
                        (Self::restore_ledger { .. }, Self::set_payee { .. }) => false,
                        (Self::restore_ledger { .. }, Self::set_controller { .. }) => {
                            false
                        }
                        (
                            Self::restore_ledger { .. },
                            Self::set_validator_count { .. },
                        ) => false,
                        (
                            Self::restore_ledger { .. },
                            Self::increase_validator_count { .. },
                        ) => false,
                        (
                            Self::restore_ledger { .. },
                            Self::scale_validator_count { .. },
                        ) => false,
                        (Self::restore_ledger { .. }, Self::force_no_eras { .. }) => {
                            false
                        }
                        (Self::restore_ledger { .. }, Self::force_new_era { .. }) => {
                            false
                        }
                        (Self::restore_ledger { .. }, Self::set_invulnerables { .. }) => {
                            false
                        }
                        (Self::restore_ledger { .. }, Self::force_unstake { .. }) => {
                            false
                        }
                        (
                            Self::restore_ledger { .. },
                            Self::force_new_era_always { .. },
                        ) => false,
                        (
                            Self::restore_ledger { .. },
                            Self::cancel_deferred_slash { .. },
                        ) => false,
                        (Self::restore_ledger { .. }, Self::payout_stakers { .. }) => {
                            false
                        }
                        (Self::restore_ledger { .. }, Self::rebond { .. }) => false,
                        (Self::restore_ledger { .. }, Self::reap_stash { .. }) => false,
                        (Self::restore_ledger { .. }, Self::kick { .. }) => false,
                        (
                            Self::restore_ledger { .. },
                            Self::set_staking_configs { .. },
                        ) => false,
                        (Self::restore_ledger { .. }, Self::chill_other { .. }) => false,
                        (
                            Self::restore_ledger { .. },
                            Self::force_apply_min_commission { .. },
                        ) => false,
                        (
                            Self::restore_ledger { .. },
                            Self::set_min_commission { .. },
                        ) => false,
                        (
                            Self::restore_ledger { .. },
                            Self::payout_stakers_by_page { .. },
                        ) => false,
                        (Self::restore_ledger { .. }, Self::update_payee { .. }) => false,
                        (
                            Self::restore_ledger { .. },
                            Self::deprecate_controller_batch { .. },
                        ) => false,
                    }
                }
            }
        };
        #[allow(deprecated)]
        const _: () = {
            #[allow(non_camel_case_types)]
            #[automatically_derived]
            impl<T: Config> ::codec::Encode for Call<T> {
                fn size_hint(&self) -> usize {
                    1_usize
                        + match *self {
                            Call::bond { ref value, ref payee } => {
                                0_usize
                                    .saturating_add(
                                        ::codec::Encode::size_hint(
                                            &<<BalanceOf<
                                                T,
                                            > as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                                '_,
                                                BalanceOf<T>,
                                            >>::RefType::from(value),
                                        ),
                                    )
                                    .saturating_add(::codec::Encode::size_hint(payee))
                            }
                            Call::bond_extra { ref max_additional } => {
                                0_usize
                                    .saturating_add(
                                        ::codec::Encode::size_hint(
                                            &<<BalanceOf<
                                                T,
                                            > as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                                '_,
                                                BalanceOf<T>,
                                            >>::RefType::from(max_additional),
                                        ),
                                    )
                            }
                            Call::unbond { ref value } => {
                                0_usize
                                    .saturating_add(
                                        ::codec::Encode::size_hint(
                                            &<<BalanceOf<
                                                T,
                                            > as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                                '_,
                                                BalanceOf<T>,
                                            >>::RefType::from(value),
                                        ),
                                    )
                            }
                            Call::withdraw_unbonded { ref num_slashing_spans } => {
                                0_usize
                                    .saturating_add(
                                        ::codec::Encode::size_hint(num_slashing_spans),
                                    )
                            }
                            Call::validate { ref prefs } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(prefs))
                            }
                            Call::nominate { ref targets } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(targets))
                            }
                            Call::chill {} => 0_usize,
                            Call::set_payee { ref payee } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(payee))
                            }
                            Call::set_controller {} => 0_usize,
                            Call::set_validator_count { ref new } => {
                                0_usize
                                    .saturating_add(
                                        ::codec::Encode::size_hint(
                                            &<<u32 as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                                '_,
                                                u32,
                                            >>::RefType::from(new),
                                        ),
                                    )
                            }
                            Call::increase_validator_count { ref additional } => {
                                0_usize
                                    .saturating_add(
                                        ::codec::Encode::size_hint(
                                            &<<u32 as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                                '_,
                                                u32,
                                            >>::RefType::from(additional),
                                        ),
                                    )
                            }
                            Call::scale_validator_count { ref factor } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(factor))
                            }
                            Call::force_no_eras {} => 0_usize,
                            Call::force_new_era {} => 0_usize,
                            Call::set_invulnerables { ref invulnerables } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(invulnerables))
                            }
                            Call::force_unstake { ref stash, ref num_slashing_spans } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(stash))
                                    .saturating_add(
                                        ::codec::Encode::size_hint(num_slashing_spans),
                                    )
                            }
                            Call::force_new_era_always {} => 0_usize,
                            Call::cancel_deferred_slash {
                                ref era,
                                ref slash_indices,
                            } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(era))
                                    .saturating_add(::codec::Encode::size_hint(slash_indices))
                            }
                            Call::payout_stakers { ref validator_stash, ref era } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(validator_stash))
                                    .saturating_add(::codec::Encode::size_hint(era))
                            }
                            Call::rebond { ref value } => {
                                0_usize
                                    .saturating_add(
                                        ::codec::Encode::size_hint(
                                            &<<BalanceOf<
                                                T,
                                            > as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                                '_,
                                                BalanceOf<T>,
                                            >>::RefType::from(value),
                                        ),
                                    )
                            }
                            Call::reap_stash { ref stash, ref num_slashing_spans } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(stash))
                                    .saturating_add(
                                        ::codec::Encode::size_hint(num_slashing_spans),
                                    )
                            }
                            Call::kick { ref who } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(who))
                            }
                            Call::set_staking_configs {
                                ref min_nominator_bond,
                                ref min_validator_bond,
                                ref max_nominator_count,
                                ref max_validator_count,
                                ref chill_threshold,
                                ref min_commission,
                                ref max_staked_rewards,
                            } => {
                                0_usize
                                    .saturating_add(
                                        ::codec::Encode::size_hint(min_nominator_bond),
                                    )
                                    .saturating_add(
                                        ::codec::Encode::size_hint(min_validator_bond),
                                    )
                                    .saturating_add(
                                        ::codec::Encode::size_hint(max_nominator_count),
                                    )
                                    .saturating_add(
                                        ::codec::Encode::size_hint(max_validator_count),
                                    )
                                    .saturating_add(::codec::Encode::size_hint(chill_threshold))
                                    .saturating_add(::codec::Encode::size_hint(min_commission))
                                    .saturating_add(
                                        ::codec::Encode::size_hint(max_staked_rewards),
                                    )
                            }
                            Call::chill_other { ref stash } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(stash))
                            }
                            Call::force_apply_min_commission { ref validator_stash } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(validator_stash))
                            }
                            Call::set_min_commission { ref new } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(new))
                            }
                            Call::payout_stakers_by_page {
                                ref validator_stash,
                                ref era,
                                ref page,
                            } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(validator_stash))
                                    .saturating_add(::codec::Encode::size_hint(era))
                                    .saturating_add(::codec::Encode::size_hint(page))
                            }
                            Call::update_payee { ref controller } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(controller))
                            }
                            Call::deprecate_controller_batch { ref controllers } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(controllers))
                            }
                            Call::restore_ledger {
                                ref stash,
                                ref maybe_controller,
                                ref maybe_total,
                                ref maybe_unlocking,
                            } => {
                                0_usize
                                    .saturating_add(::codec::Encode::size_hint(stash))
                                    .saturating_add(
                                        ::codec::Encode::size_hint(maybe_controller),
                                    )
                                    .saturating_add(::codec::Encode::size_hint(maybe_total))
                                    .saturating_add(::codec::Encode::size_hint(maybe_unlocking))
                            }
                            _ => 0_usize,
                        }
                }
                fn encode_to<
                    __CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized,
                >(&self, __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    match *self {
                        Call::bond { ref value, ref payee } => {
                            __codec_dest_edqy.push_byte(0u8 as ::core::primitive::u8);
                            {
                                ::codec::Encode::encode_to(
                                    &<<BalanceOf<
                                        T,
                                    > as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                        '_,
                                        BalanceOf<T>,
                                    >>::RefType::from(value),
                                    __codec_dest_edqy,
                                );
                            }
                            ::codec::Encode::encode_to(payee, __codec_dest_edqy);
                        }
                        Call::bond_extra { ref max_additional } => {
                            __codec_dest_edqy.push_byte(1u8 as ::core::primitive::u8);
                            {
                                ::codec::Encode::encode_to(
                                    &<<BalanceOf<
                                        T,
                                    > as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                        '_,
                                        BalanceOf<T>,
                                    >>::RefType::from(max_additional),
                                    __codec_dest_edqy,
                                );
                            }
                        }
                        Call::unbond { ref value } => {
                            __codec_dest_edqy.push_byte(2u8 as ::core::primitive::u8);
                            {
                                ::codec::Encode::encode_to(
                                    &<<BalanceOf<
                                        T,
                                    > as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                        '_,
                                        BalanceOf<T>,
                                    >>::RefType::from(value),
                                    __codec_dest_edqy,
                                );
                            }
                        }
                        Call::withdraw_unbonded { ref num_slashing_spans } => {
                            __codec_dest_edqy.push_byte(3u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(
                                num_slashing_spans,
                                __codec_dest_edqy,
                            );
                        }
                        Call::validate { ref prefs } => {
                            __codec_dest_edqy.push_byte(4u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(prefs, __codec_dest_edqy);
                        }
                        Call::nominate { ref targets } => {
                            __codec_dest_edqy.push_byte(5u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(targets, __codec_dest_edqy);
                        }
                        Call::chill {} => {
                            __codec_dest_edqy.push_byte(6u8 as ::core::primitive::u8);
                        }
                        Call::set_payee { ref payee } => {
                            __codec_dest_edqy.push_byte(7u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(payee, __codec_dest_edqy);
                        }
                        Call::set_controller {} => {
                            __codec_dest_edqy.push_byte(8u8 as ::core::primitive::u8);
                        }
                        Call::set_validator_count { ref new } => {
                            __codec_dest_edqy.push_byte(9u8 as ::core::primitive::u8);
                            {
                                ::codec::Encode::encode_to(
                                    &<<u32 as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                        '_,
                                        u32,
                                    >>::RefType::from(new),
                                    __codec_dest_edqy,
                                );
                            }
                        }
                        Call::increase_validator_count { ref additional } => {
                            __codec_dest_edqy.push_byte(10u8 as ::core::primitive::u8);
                            {
                                ::codec::Encode::encode_to(
                                    &<<u32 as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                        '_,
                                        u32,
                                    >>::RefType::from(additional),
                                    __codec_dest_edqy,
                                );
                            }
                        }
                        Call::scale_validator_count { ref factor } => {
                            __codec_dest_edqy.push_byte(11u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(factor, __codec_dest_edqy);
                        }
                        Call::force_no_eras {} => {
                            __codec_dest_edqy.push_byte(12u8 as ::core::primitive::u8);
                        }
                        Call::force_new_era {} => {
                            __codec_dest_edqy.push_byte(13u8 as ::core::primitive::u8);
                        }
                        Call::set_invulnerables { ref invulnerables } => {
                            __codec_dest_edqy.push_byte(14u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(invulnerables, __codec_dest_edqy);
                        }
                        Call::force_unstake { ref stash, ref num_slashing_spans } => {
                            __codec_dest_edqy.push_byte(15u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(stash, __codec_dest_edqy);
                            ::codec::Encode::encode_to(
                                num_slashing_spans,
                                __codec_dest_edqy,
                            );
                        }
                        Call::force_new_era_always {} => {
                            __codec_dest_edqy.push_byte(16u8 as ::core::primitive::u8);
                        }
                        Call::cancel_deferred_slash { ref era, ref slash_indices } => {
                            __codec_dest_edqy.push_byte(17u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(era, __codec_dest_edqy);
                            ::codec::Encode::encode_to(slash_indices, __codec_dest_edqy);
                        }
                        Call::payout_stakers { ref validator_stash, ref era } => {
                            __codec_dest_edqy.push_byte(18u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(
                                validator_stash,
                                __codec_dest_edqy,
                            );
                            ::codec::Encode::encode_to(era, __codec_dest_edqy);
                        }
                        Call::rebond { ref value } => {
                            __codec_dest_edqy.push_byte(19u8 as ::core::primitive::u8);
                            {
                                ::codec::Encode::encode_to(
                                    &<<BalanceOf<
                                        T,
                                    > as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                        '_,
                                        BalanceOf<T>,
                                    >>::RefType::from(value),
                                    __codec_dest_edqy,
                                );
                            }
                        }
                        Call::reap_stash { ref stash, ref num_slashing_spans } => {
                            __codec_dest_edqy.push_byte(20u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(stash, __codec_dest_edqy);
                            ::codec::Encode::encode_to(
                                num_slashing_spans,
                                __codec_dest_edqy,
                            );
                        }
                        Call::kick { ref who } => {
                            __codec_dest_edqy.push_byte(21u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(who, __codec_dest_edqy);
                        }
                        Call::set_staking_configs {
                            ref min_nominator_bond,
                            ref min_validator_bond,
                            ref max_nominator_count,
                            ref max_validator_count,
                            ref chill_threshold,
                            ref min_commission,
                            ref max_staked_rewards,
                        } => {
                            __codec_dest_edqy.push_byte(22u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(
                                min_nominator_bond,
                                __codec_dest_edqy,
                            );
                            ::codec::Encode::encode_to(
                                min_validator_bond,
                                __codec_dest_edqy,
                            );
                            ::codec::Encode::encode_to(
                                max_nominator_count,
                                __codec_dest_edqy,
                            );
                            ::codec::Encode::encode_to(
                                max_validator_count,
                                __codec_dest_edqy,
                            );
                            ::codec::Encode::encode_to(
                                chill_threshold,
                                __codec_dest_edqy,
                            );
                            ::codec::Encode::encode_to(
                                min_commission,
                                __codec_dest_edqy,
                            );
                            ::codec::Encode::encode_to(
                                max_staked_rewards,
                                __codec_dest_edqy,
                            );
                        }
                        Call::chill_other { ref stash } => {
                            __codec_dest_edqy.push_byte(23u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(stash, __codec_dest_edqy);
                        }
                        Call::force_apply_min_commission { ref validator_stash } => {
                            __codec_dest_edqy.push_byte(24u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(
                                validator_stash,
                                __codec_dest_edqy,
                            );
                        }
                        Call::set_min_commission { ref new } => {
                            __codec_dest_edqy.push_byte(25u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(new, __codec_dest_edqy);
                        }
                        Call::payout_stakers_by_page {
                            ref validator_stash,
                            ref era,
                            ref page,
                        } => {
                            __codec_dest_edqy.push_byte(26u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(
                                validator_stash,
                                __codec_dest_edqy,
                            );
                            ::codec::Encode::encode_to(era, __codec_dest_edqy);
                            ::codec::Encode::encode_to(page, __codec_dest_edqy);
                        }
                        Call::update_payee { ref controller } => {
                            __codec_dest_edqy.push_byte(27u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(controller, __codec_dest_edqy);
                        }
                        Call::deprecate_controller_batch { ref controllers } => {
                            __codec_dest_edqy.push_byte(28u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(controllers, __codec_dest_edqy);
                        }
                        Call::restore_ledger {
                            ref stash,
                            ref maybe_controller,
                            ref maybe_total,
                            ref maybe_unlocking,
                        } => {
                            __codec_dest_edqy.push_byte(29u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(stash, __codec_dest_edqy);
                            ::codec::Encode::encode_to(
                                maybe_controller,
                                __codec_dest_edqy,
                            );
                            ::codec::Encode::encode_to(maybe_total, __codec_dest_edqy);
                            ::codec::Encode::encode_to(
                                maybe_unlocking,
                                __codec_dest_edqy,
                            );
                        }
                        _ => {}
                    }
                }
            }
            #[automatically_derived]
            impl<T: Config> ::codec::EncodeLike for Call<T> {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[allow(non_camel_case_types)]
            #[automatically_derived]
            impl<T: Config> ::codec::Decode for Call<T> {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    match __codec_input_edqy
                        .read_byte()
                        .map_err(|e| {
                            e
                                .chain(
                                    "Could not decode `Call`, failed to read variant byte",
                                )
                        })?
                    {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 0u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::bond {
                                    value: {
                                        let __codec_res_edqy = <<BalanceOf<
                                            T,
                                        > as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Call::bond::value`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy.into()
                                            }
                                        }
                                    },
                                    payee: {
                                        let __codec_res_edqy = <RewardDestination<
                                            T::AccountId,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Call::bond::payee`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 1u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::bond_extra {
                                    max_additional: {
                                        let __codec_res_edqy = <<BalanceOf<
                                            T,
                                        > as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::bond_extra::max_additional`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy.into()
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 2u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::unbond {
                                    value: {
                                        let __codec_res_edqy = <<BalanceOf<
                                            T,
                                        > as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Call::unbond::value`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy.into()
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 3u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::withdraw_unbonded {
                                    num_slashing_spans: {
                                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::withdraw_unbonded::num_slashing_spans`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 4u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::validate {
                                    prefs: {
                                        let __codec_res_edqy = <ValidatorPrefs as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Call::validate::prefs`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 5u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::nominate {
                                    targets: {
                                        let __codec_res_edqy = <Vec<
                                            AccountIdLookupOf<T>,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Call::nominate::targets`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 6u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::chill {})
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 7u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::set_payee {
                                    payee: {
                                        let __codec_res_edqy = <RewardDestination<
                                            T::AccountId,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Call::set_payee::payee`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 8u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::set_controller {})
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 9u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::set_validator_count {
                                    new: {
                                        let __codec_res_edqy = <<u32 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Call::set_validator_count::new`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy.into()
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 10u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<
                                    T,
                                >::increase_validator_count {
                                    additional: {
                                        let __codec_res_edqy = <<u32 as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::increase_validator_count::additional`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy.into()
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 11u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<
                                    T,
                                >::scale_validator_count {
                                    factor: {
                                        let __codec_res_edqy = <Percent as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::scale_validator_count::factor`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 12u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::force_no_eras {})
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 13u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::force_new_era {})
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 14u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::set_invulnerables {
                                    invulnerables: {
                                        let __codec_res_edqy = <Vec<
                                            T::AccountId,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::set_invulnerables::invulnerables`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 15u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::force_unstake {
                                    stash: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Call::force_unstake::stash`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    num_slashing_spans: {
                                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::force_unstake::num_slashing_spans`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 16u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::force_new_era_always {})
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 17u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<
                                    T,
                                >::cancel_deferred_slash {
                                    era: {
                                        let __codec_res_edqy = <EraIndex as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::cancel_deferred_slash::era`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    slash_indices: {
                                        let __codec_res_edqy = <Vec<
                                            u32,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::cancel_deferred_slash::slash_indices`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 18u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::payout_stakers {
                                    validator_stash: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::payout_stakers::validator_stash`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    era: {
                                        let __codec_res_edqy = <EraIndex as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Call::payout_stakers::era`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 19u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::rebond {
                                    value: {
                                        let __codec_res_edqy = <<BalanceOf<
                                            T,
                                        > as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Call::rebond::value`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy.into()
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 20u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::reap_stash {
                                    stash: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Call::reap_stash::stash`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    num_slashing_spans: {
                                        let __codec_res_edqy = <u32 as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::reap_stash::num_slashing_spans`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 21u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::kick {
                                    who: {
                                        let __codec_res_edqy = <Vec<
                                            AccountIdLookupOf<T>,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Call::kick::who`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 22u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::set_staking_configs {
                                    min_nominator_bond: {
                                        let __codec_res_edqy = <ConfigOp<
                                            BalanceOf<T>,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::set_staking_configs::min_nominator_bond`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    min_validator_bond: {
                                        let __codec_res_edqy = <ConfigOp<
                                            BalanceOf<T>,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::set_staking_configs::min_validator_bond`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    max_nominator_count: {
                                        let __codec_res_edqy = <ConfigOp<
                                            u32,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::set_staking_configs::max_nominator_count`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    max_validator_count: {
                                        let __codec_res_edqy = <ConfigOp<
                                            u32,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::set_staking_configs::max_validator_count`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    chill_threshold: {
                                        let __codec_res_edqy = <ConfigOp<
                                            Percent,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::set_staking_configs::chill_threshold`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    min_commission: {
                                        let __codec_res_edqy = <ConfigOp<
                                            Perbill,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::set_staking_configs::min_commission`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    max_staked_rewards: {
                                        let __codec_res_edqy = <ConfigOp<
                                            Percent,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::set_staking_configs::max_staked_rewards`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 23u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::chill_other {
                                    stash: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Call::chill_other::stash`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 24u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<
                                    T,
                                >::force_apply_min_commission {
                                    validator_stash: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::force_apply_min_commission::validator_stash`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 25u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::set_min_commission {
                                    new: {
                                        let __codec_res_edqy = <Perbill as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Call::set_min_commission::new`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 26u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<
                                    T,
                                >::payout_stakers_by_page {
                                    validator_stash: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::payout_stakers_by_page::validator_stash`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    era: {
                                        let __codec_res_edqy = <EraIndex as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::payout_stakers_by_page::era`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    page: {
                                        let __codec_res_edqy = <Page as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::payout_stakers_by_page::page`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 27u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::update_payee {
                                    controller: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Call::update_payee::controller`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 28u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<
                                    T,
                                >::deprecate_controller_batch {
                                    controllers: {
                                        let __codec_res_edqy = <BoundedVec<
                                            T::AccountId,
                                            T::MaxControllersInDeprecationBatch,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::deprecate_controller_batch::controllers`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 29u8 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(Call::<T>::restore_ledger {
                                    stash: {
                                        let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `Call::restore_ledger::stash`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    maybe_controller: {
                                        let __codec_res_edqy = <Option<
                                            T::AccountId,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::restore_ledger::maybe_controller`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    maybe_total: {
                                        let __codec_res_edqy = <Option<
                                            BalanceOf<T>,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::restore_ledger::maybe_total`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                    maybe_unlocking: {
                                        let __codec_res_edqy = <Option<
                                            BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e
                                                        .chain(
                                                            "Could not decode `Call::restore_ledger::maybe_unlocking`",
                                                        ),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    },
                                })
                            })();
                        }
                        _ => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Err(
                                    <_ as ::core::convert::Into<
                                        _,
                                    >>::into("Could not decode `Call`, variant doesn't exist"),
                                )
                            })();
                        }
                    }
                }
            }
        };
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            impl<T: Config> ::scale_info::TypeInfo for Call<T>
            where
                ::core::marker::PhantomData<(T,)>: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::scale::HasCompact,
                RewardDestination<T::AccountId>: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::scale::HasCompact,
                BalanceOf<T>: ::scale_info::scale::HasCompact,
                Vec<AccountIdLookupOf<T>>: ::scale_info::TypeInfo + 'static,
                RewardDestination<T::AccountId>: ::scale_info::TypeInfo + 'static,
                Vec<T::AccountId>: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::scale::HasCompact,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                Vec<AccountIdLookupOf<T>>: ::scale_info::TypeInfo + 'static,
                ConfigOp<BalanceOf<T>>: ::scale_info::TypeInfo + 'static,
                ConfigOp<BalanceOf<T>>: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                BoundedVec<
                    T::AccountId,
                    T::MaxControllersInDeprecationBatch,
                >: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                Option<T::AccountId>: ::scale_info::TypeInfo + 'static,
                Option<BalanceOf<T>>: ::scale_info::TypeInfo + 'static,
                Option<
                    BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>,
                >: ::scale_info::TypeInfo + 'static,
                T: Config + 'static,
            {
                type Identity = Self;
                fn type_info() -> ::scale_info::Type {
                    ::scale_info::Type::builder()
                        .path(
                            ::scale_info::Path::new_with_replace(
                                "Call",
                                "pallet_staking::pallet::pallet",
                                &[],
                            ),
                        )
                        .type_params(
                            <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    ::scale_info::TypeParameter::new(
                                        "T",
                                        ::core::option::Option::None,
                                    ),
                                ]),
                            ),
                        )
                        .docs_always(
                            &[
                                "Contains a variant per dispatchable extrinsic that this pallet has.",
                            ],
                        )
                        .variant(
                            ::scale_info::build::Variants::new()
                                .variant(
                                    "bond",
                                    |v| {
                                        v
                                            .index(0u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .compact::<BalanceOf<T>>()
                                                            .name("value")
                                                            .type_name("BalanceOf<T>")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<RewardDestination<T::AccountId>>()
                                                            .name("payee")
                                                            .type_name("RewardDestination<T::AccountId>")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Take the origin account as a stash and lock up `value` of its balance. `controller` will",
                                                    "be the account that controls it.",
                                                    "",
                                                    "`value` must be more than the `minimum_balance` specified by `T::Currency`.",
                                                    "",
                                                    "The dispatch origin for this call must be _Signed_ by the stash account.",
                                                    "",
                                                    "Emits `Bonded`.",
                                                    "## Complexity",
                                                    "- Independent of the arguments. Moderate complexity.",
                                                    "- O(1).",
                                                    "- Three extra DB entries.",
                                                    "",
                                                    "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned",
                                                    "unless the `origin` falls below _existential deposit_ (or equal to 0) and gets removed",
                                                    "as dust.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "bond_extra",
                                    |v| {
                                        v
                                            .index(1u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .compact::<BalanceOf<T>>()
                                                            .name("max_additional")
                                                            .type_name("BalanceOf<T>")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Add some extra amount that have appeared in the stash `free_balance` into the balance up",
                                                    "for staking.",
                                                    "",
                                                    "The dispatch origin for this call must be _Signed_ by the stash, not the controller.",
                                                    "",
                                                    "Use this if there are additional funds in your stash account that you wish to bond.",
                                                    "Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose",
                                                    "any limitation on the amount that can be added.",
                                                    "",
                                                    "Emits `Bonded`.",
                                                    "",
                                                    "## Complexity",
                                                    "- Independent of the arguments. Insignificant complexity.",
                                                    "- O(1).",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "unbond",
                                    |v| {
                                        v
                                            .index(2u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .compact::<BalanceOf<T>>()
                                                            .name("value")
                                                            .type_name("BalanceOf<T>")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Schedule a portion of the stash to be unlocked ready for transfer out after the bond",
                                                    "period ends. If this leaves an amount actively bonded less than",
                                                    "[`asset::existential_deposit`], then it is increased to the full amount.",
                                                    "",
                                                    "The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
                                                    "",
                                                    "Once the unlock period is done, you can call `withdraw_unbonded` to actually move",
                                                    "the funds out of management ready for transfer.",
                                                    "",
                                                    "No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)",
                                                    "can co-exists at the same time. If there are no unlocking chunks slots available",
                                                    "[`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible).",
                                                    "",
                                                    "If a user encounters the `InsufficientBond` error when calling this extrinsic,",
                                                    "they should call `chill` first in order to free up their bonded funds.",
                                                    "",
                                                    "Emits `Unbonded`.",
                                                    "",
                                                    "See also [`Call::withdraw_unbonded`].",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "withdraw_unbonded",
                                    |v| {
                                        v
                                            .index(3u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f.ty::<u32>().name("num_slashing_spans").type_name("u32")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Remove any unlocked chunks from the `unlocking` queue from our management.",
                                                    "",
                                                    "This essentially frees up that balance to be used by the stash account to do whatever",
                                                    "it wants.",
                                                    "",
                                                    "The dispatch origin for this call must be _Signed_ by the controller.",
                                                    "",
                                                    "Emits `Withdrawn`.",
                                                    "",
                                                    "See also [`Call::unbond`].",
                                                    "",
                                                    "## Parameters",
                                                    "",
                                                    "- `num_slashing_spans` indicates the number of metadata slashing spans to clear when",
                                                    "this call results in a complete removal of all the data related to the stash account.",
                                                    "In this case, the `num_slashing_spans` must be larger or equal to the number of",
                                                    "slashing spans associated with the stash account in the [`SlashingSpans`] storage type,",
                                                    "otherwise the call will fail. The call weight is directly proportional to",
                                                    "`num_slashing_spans`.",
                                                    "",
                                                    "## Complexity",
                                                    "O(S) where S is the number of slashing spans to remove",
                                                    "NOTE: Weight annotation is the kill scenario, we refund otherwise.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "validate",
                                    |v| {
                                        v
                                            .index(4u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<ValidatorPrefs>()
                                                            .name("prefs")
                                                            .type_name("ValidatorPrefs")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Declare the desire to validate for the origin controller.",
                                                    "",
                                                    "Effects will be felt at the beginning of the next era.",
                                                    "",
                                                    "The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "nominate",
                                    |v| {
                                        v
                                            .index(5u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<Vec<AccountIdLookupOf<T>>>()
                                                            .name("targets")
                                                            .type_name("Vec<AccountIdLookupOf<T>>")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Declare the desire to nominate `targets` for the origin controller.",
                                                    "",
                                                    "Effects will be felt at the beginning of the next era.",
                                                    "",
                                                    "The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
                                                    "",
                                                    "## Complexity",
                                                    "- The transaction's complexity is proportional to the size of `targets` (N)",
                                                    "which is capped at CompactAssignments::LIMIT (T::MaxNominations).",
                                                    "- Both the reads and writes follow a similar pattern.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "chill",
                                    |v| {
                                        v
                                            .index(6u8 as ::core::primitive::u8)
                                            .fields(::scale_info::build::Fields::named())
                                            .docs_always(
                                                &[
                                                    "Declare no desire to either validate or nominate.",
                                                    "",
                                                    "Effects will be felt at the beginning of the next era.",
                                                    "",
                                                    "The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
                                                    "",
                                                    "## Complexity",
                                                    "- Independent of the arguments. Insignificant complexity.",
                                                    "- Contains one read.",
                                                    "- Writes are limited to the `origin` account key.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "set_payee",
                                    |v| {
                                        v
                                            .index(7u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<RewardDestination<T::AccountId>>()
                                                            .name("payee")
                                                            .type_name("RewardDestination<T::AccountId>")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "(Re-)set the payment target for a controller.",
                                                    "",
                                                    "Effects will be felt instantly (as soon as this function is completed successfully).",
                                                    "",
                                                    "The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
                                                    "",
                                                    "## Complexity",
                                                    "- O(1)",
                                                    "- Independent of the arguments. Insignificant complexity.",
                                                    "- Contains a limited number of reads.",
                                                    "- Writes are limited to the `origin` account key.",
                                                    "---------",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "set_controller",
                                    |v| {
                                        v
                                            .index(8u8 as ::core::primitive::u8)
                                            .fields(::scale_info::build::Fields::named())
                                            .docs_always(
                                                &[
                                                    "(Re-)sets the controller of a stash to the stash itself. This function previously",
                                                    "accepted a `controller` argument to set the controller to an account other than the",
                                                    "stash itself. This functionality has now been removed, now only setting the controller",
                                                    "to the stash, if it is not already.",
                                                    "",
                                                    "Effects will be felt instantly (as soon as this function is completed successfully).",
                                                    "",
                                                    "The dispatch origin for this call must be _Signed_ by the stash, not the controller.",
                                                    "",
                                                    "## Complexity",
                                                    "O(1)",
                                                    "- Independent of the arguments. Insignificant complexity.",
                                                    "- Contains a limited number of reads.",
                                                    "- Writes are limited to the `origin` account key.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "set_validator_count",
                                    |v| {
                                        v
                                            .index(9u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| f.compact::<u32>().name("new").type_name("u32")),
                                            )
                                            .docs_always(
                                                &[
                                                    "Sets the ideal number of validators.",
                                                    "",
                                                    "The dispatch origin must be Root.",
                                                    "",
                                                    "## Complexity",
                                                    "O(1)",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "increase_validator_count",
                                    |v| {
                                        v
                                            .index(10u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f.compact::<u32>().name("additional").type_name("u32")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Increments the ideal number of validators up to maximum of",
                                                    "`ElectionProviderBase::MaxWinners`.",
                                                    "",
                                                    "The dispatch origin must be Root.",
                                                    "",
                                                    "## Complexity",
                                                    "Same as [`Self::set_validator_count`].",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "scale_validator_count",
                                    |v| {
                                        v
                                            .index(11u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f.ty::<Percent>().name("factor").type_name("Percent")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Scale up the ideal number of validators by a factor up to maximum of",
                                                    "`ElectionProviderBase::MaxWinners`.",
                                                    "",
                                                    "The dispatch origin must be Root.",
                                                    "",
                                                    "## Complexity",
                                                    "Same as [`Self::set_validator_count`].",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "force_no_eras",
                                    |v| {
                                        v
                                            .index(12u8 as ::core::primitive::u8)
                                            .fields(::scale_info::build::Fields::named())
                                            .docs_always(
                                                &[
                                                    "Force there to be no new eras indefinitely.",
                                                    "",
                                                    "The dispatch origin must be Root.",
                                                    "",
                                                    "# Warning",
                                                    "",
                                                    "The election process starts multiple blocks before the end of the era.",
                                                    "Thus the election process may be ongoing when this is called. In this case the",
                                                    "election will continue until the next era is triggered.",
                                                    "",
                                                    "## Complexity",
                                                    "- No arguments.",
                                                    "- Weight: O(1)",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "force_new_era",
                                    |v| {
                                        v
                                            .index(13u8 as ::core::primitive::u8)
                                            .fields(::scale_info::build::Fields::named())
                                            .docs_always(
                                                &[
                                                    "Force there to be a new era at the end of the next session. After this, it will be",
                                                    "reset to normal (non-forced) behaviour.",
                                                    "",
                                                    "The dispatch origin must be Root.",
                                                    "",
                                                    "# Warning",
                                                    "",
                                                    "The election process starts multiple blocks before the end of the era.",
                                                    "If this is called just before a new era is triggered, the election process may not",
                                                    "have enough blocks to get a result.",
                                                    "",
                                                    "## Complexity",
                                                    "- No arguments.",
                                                    "- Weight: O(1)",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "set_invulnerables",
                                    |v| {
                                        v
                                            .index(14u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<Vec<T::AccountId>>()
                                                            .name("invulnerables")
                                                            .type_name("Vec<T::AccountId>")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Set the validators who cannot be slashed (if any).",
                                                    "",
                                                    "The dispatch origin must be Root.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "force_unstake",
                                    |v| {
                                        v
                                            .index(15u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("stash")
                                                            .type_name("T::AccountId")
                                                    })
                                                    .field(|f| {
                                                        f.ty::<u32>().name("num_slashing_spans").type_name("u32")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Force a current staker to become completely unstaked, immediately.",
                                                    "",
                                                    "The dispatch origin must be Root.",
                                                    "",
                                                    "## Parameters",
                                                    "",
                                                    "- `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more",
                                                    "details.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "force_new_era_always",
                                    |v| {
                                        v
                                            .index(16u8 as ::core::primitive::u8)
                                            .fields(::scale_info::build::Fields::named())
                                            .docs_always(
                                                &[
                                                    "Force there to be a new era at the end of sessions indefinitely.",
                                                    "",
                                                    "The dispatch origin must be Root.",
                                                    "",
                                                    "# Warning",
                                                    "",
                                                    "The election process starts multiple blocks before the end of the era.",
                                                    "If this is called just before a new era is triggered, the election process may not",
                                                    "have enough blocks to get a result.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "cancel_deferred_slash",
                                    |v| {
                                        v
                                            .index(17u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f.ty::<EraIndex>().name("era").type_name("EraIndex")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<Vec<u32>>()
                                                            .name("slash_indices")
                                                            .type_name("Vec<u32>")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Cancel enactment of a deferred slash.",
                                                    "",
                                                    "Can be called by the `T::AdminOrigin`.",
                                                    "",
                                                    "Parameters: era and indices of the slashes for that era to kill.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "payout_stakers",
                                    |v| {
                                        v
                                            .index(18u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("validator_stash")
                                                            .type_name("T::AccountId")
                                                    })
                                                    .field(|f| {
                                                        f.ty::<EraIndex>().name("era").type_name("EraIndex")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Pay out next page of the stakers behind a validator for the given era.",
                                                    "",
                                                    "- `validator_stash` is the stash account of the validator.",
                                                    "- `era` may be any era between `[current_era - history_depth; current_era]`.",
                                                    "",
                                                    "The origin of this call must be _Signed_. Any account can call this function, even if",
                                                    "it is not one of the stakers.",
                                                    "",
                                                    "The reward payout could be paged in case there are too many nominators backing the",
                                                    "`validator_stash`. This call will payout unpaid pages in an ascending order. To claim a",
                                                    "specific page, use `payout_stakers_by_page`.`",
                                                    "",
                                                    "If all pages are claimed, it returns an error `InvalidPage`.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "rebond",
                                    |v| {
                                        v
                                            .index(19u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .compact::<BalanceOf<T>>()
                                                            .name("value")
                                                            .type_name("BalanceOf<T>")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Rebond a portion of the stash scheduled to be unlocked.",
                                                    "",
                                                    "The dispatch origin must be signed by the controller.",
                                                    "",
                                                    "## Complexity",
                                                    "- Time complexity: O(L), where L is unlocking chunks",
                                                    "- Bounded by `MaxUnlockingChunks`.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "reap_stash",
                                    |v| {
                                        v
                                            .index(20u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("stash")
                                                            .type_name("T::AccountId")
                                                    })
                                                    .field(|f| {
                                                        f.ty::<u32>().name("num_slashing_spans").type_name("u32")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Remove all data structures concerning a staker/stash once it is at a state where it can",
                                                    "be considered `dust` in the staking system. The requirements are:",
                                                    "",
                                                    "1. the `total_balance` of the stash is below existential deposit.",
                                                    "2. or, the `ledger.total` of the stash is below existential deposit.",
                                                    "3. or, existential deposit is zero and either `total_balance` or `ledger.total` is zero.",
                                                    "",
                                                    "The former can happen in cases like a slash; the latter when a fully unbonded account",
                                                    "is still receiving staking rewards in `RewardDestination::Staked`.",
                                                    "",
                                                    "It can be called by anyone, as long as `stash` meets the above requirements.",
                                                    "",
                                                    "Refunds the transaction fees upon successful execution.",
                                                    "",
                                                    "## Parameters",
                                                    "",
                                                    "- `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more",
                                                    "details.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "kick",
                                    |v| {
                                        v
                                            .index(21u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<Vec<AccountIdLookupOf<T>>>()
                                                            .name("who")
                                                            .type_name("Vec<AccountIdLookupOf<T>>")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Remove the given nominations from the calling validator.",
                                                    "",
                                                    "Effects will be felt at the beginning of the next era.",
                                                    "",
                                                    "The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
                                                    "",
                                                    "- `who`: A list of nominator stash accounts who are nominating this validator which",
                                                    "  should no longer be nominating this validator.",
                                                    "",
                                                    "Note: Making this call only makes sense if you first set the validator preferences to",
                                                    "block any further nominations.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "set_staking_configs",
                                    |v| {
                                        v
                                            .index(22u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<ConfigOp<BalanceOf<T>>>()
                                                            .name("min_nominator_bond")
                                                            .type_name("ConfigOp<BalanceOf<T>>")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<ConfigOp<BalanceOf<T>>>()
                                                            .name("min_validator_bond")
                                                            .type_name("ConfigOp<BalanceOf<T>>")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<ConfigOp<u32>>()
                                                            .name("max_nominator_count")
                                                            .type_name("ConfigOp<u32>")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<ConfigOp<u32>>()
                                                            .name("max_validator_count")
                                                            .type_name("ConfigOp<u32>")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<ConfigOp<Percent>>()
                                                            .name("chill_threshold")
                                                            .type_name("ConfigOp<Percent>")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<ConfigOp<Perbill>>()
                                                            .name("min_commission")
                                                            .type_name("ConfigOp<Perbill>")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<ConfigOp<Percent>>()
                                                            .name("max_staked_rewards")
                                                            .type_name("ConfigOp<Percent>")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Update the various staking configurations .",
                                                    "",
                                                    "* `min_nominator_bond`: The minimum active bond needed to be a nominator.",
                                                    "* `min_validator_bond`: The minimum active bond needed to be a validator.",
                                                    "* `max_nominator_count`: The max number of users who can be a nominator at once. When",
                                                    "  set to `None`, no limit is enforced.",
                                                    "* `max_validator_count`: The max number of users who can be a validator at once. When",
                                                    "  set to `None`, no limit is enforced.",
                                                    "* `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which",
                                                    "  should be filled in order for the `chill_other` transaction to work.",
                                                    "* `min_commission`: The minimum amount of commission that each validators must maintain.",
                                                    "  This is checked only upon calling `validate`. Existing validators are not affected.",
                                                    "",
                                                    "RuntimeOrigin must be Root to call this function.",
                                                    "",
                                                    "NOTE: Existing nominators and validators will not be affected by this update.",
                                                    "to kick people under the new limits, `chill_other` should be called.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "chill_other",
                                    |v| {
                                        v
                                            .index(23u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("stash")
                                                            .type_name("T::AccountId")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Declare a `controller` to stop participating as either a validator or nominator.",
                                                    "",
                                                    "Effects will be felt at the beginning of the next era.",
                                                    "",
                                                    "The dispatch origin for this call must be _Signed_, but can be called by anyone.",
                                                    "",
                                                    "If the caller is the same as the controller being targeted, then no further checks are",
                                                    "enforced, and this function behaves just like `chill`.",
                                                    "",
                                                    "If the caller is different than the controller being targeted, the following conditions",
                                                    "must be met:",
                                                    "",
                                                    "* `controller` must belong to a nominator who has become non-decodable,",
                                                    "",
                                                    "Or:",
                                                    "",
                                                    "* A `ChillThreshold` must be set and checked which defines how close to the max",
                                                    "  nominators or validators we must reach before users can start chilling one-another.",
                                                    "* A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine",
                                                    "  how close we are to the threshold.",
                                                    "* A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines",
                                                    "  if this is a person that should be chilled because they have not met the threshold",
                                                    "  bond required.",
                                                    "",
                                                    "This can be helpful if bond requirements are updated, and we need to remove old users",
                                                    "who do not satisfy these requirements.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "force_apply_min_commission",
                                    |v| {
                                        v
                                            .index(24u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("validator_stash")
                                                            .type_name("T::AccountId")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Force a validator to have at least the minimum commission. This will not affect a",
                                                    "validator who already has a commission greater than or equal to the minimum. Any account",
                                                    "can call this.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "set_min_commission",
                                    |v| {
                                        v
                                            .index(25u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f.ty::<Perbill>().name("new").type_name("Perbill")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Sets the minimum amount of commission that each validators must maintain.",
                                                    "",
                                                    "This call has lower privilege requirements than `set_staking_config` and can be called",
                                                    "by the `T::AdminOrigin`. Root can always call this.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "payout_stakers_by_page",
                                    |v| {
                                        v
                                            .index(26u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("validator_stash")
                                                            .type_name("T::AccountId")
                                                    })
                                                    .field(|f| {
                                                        f.ty::<EraIndex>().name("era").type_name("EraIndex")
                                                    })
                                                    .field(|f| f.ty::<Page>().name("page").type_name("Page")),
                                            )
                                            .docs_always(
                                                &[
                                                    "Pay out a page of the stakers behind a validator for the given era and page.",
                                                    "",
                                                    "- `validator_stash` is the stash account of the validator.",
                                                    "- `era` may be any era between `[current_era - history_depth; current_era]`.",
                                                    "- `page` is the page index of nominators to pay out with value between 0 and",
                                                    "  `num_nominators / T::MaxExposurePageSize`.",
                                                    "",
                                                    "The origin of this call must be _Signed_. Any account can call this function, even if",
                                                    "it is not one of the stakers.",
                                                    "",
                                                    "If a validator has more than [`Config::MaxExposurePageSize`] nominators backing",
                                                    "them, then the list of nominators is paged, with each page being capped at",
                                                    "[`Config::MaxExposurePageSize`.] If a validator has more than one page of nominators,",
                                                    "the call needs to be made for each page separately in order for all the nominators",
                                                    "backing a validator to receive the reward. The nominators are not sorted across pages",
                                                    "and so it should not be assumed the highest staker would be on the topmost page and vice",
                                                    "versa. If rewards are not claimed in [`Config::HistoryDepth`] eras, they are lost.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "update_payee",
                                    |v| {
                                        v
                                            .index(27u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("controller")
                                                            .type_name("T::AccountId")
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Migrates an account's `RewardDestination::Controller` to",
                                                    "`RewardDestination::Account(controller)`.",
                                                    "",
                                                    "Effects will be felt instantly (as soon as this function is completed successfully).",
                                                    "",
                                                    "This will waive the transaction fee if the `payee` is successfully migrated.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "deprecate_controller_batch",
                                    |v| {
                                        v
                                            .index(28u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<
                                                                BoundedVec<
                                                                    T::AccountId,
                                                                    T::MaxControllersInDeprecationBatch,
                                                                >,
                                                            >()
                                                            .name("controllers")
                                                            .type_name(
                                                                "BoundedVec<T::AccountId, T::MaxControllersInDeprecationBatch>",
                                                            )
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Updates a batch of controller accounts to their corresponding stash account if they are",
                                                    "not the same. Ignores any controller accounts that do not exist, and does not operate if",
                                                    "the stash and controller are already the same.",
                                                    "",
                                                    "Effects will be felt instantly (as soon as this function is completed successfully).",
                                                    "",
                                                    "The dispatch origin must be `T::AdminOrigin`.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "restore_ledger",
                                    |v| {
                                        v
                                            .index(29u8 as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<T::AccountId>()
                                                            .name("stash")
                                                            .type_name("T::AccountId")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<Option<T::AccountId>>()
                                                            .name("maybe_controller")
                                                            .type_name("Option<T::AccountId>")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<Option<BalanceOf<T>>>()
                                                            .name("maybe_total")
                                                            .type_name("Option<BalanceOf<T>>")
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<
                                                                Option<
                                                                    BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>,
                                                                >,
                                                            >()
                                                            .name("maybe_unlocking")
                                                            .type_name(
                                                                "Option<BoundedVec<UnlockChunk<BalanceOf<T>>, T::\nMaxUnlockingChunks>>",
                                                            )
                                                    }),
                                            )
                                            .docs_always(
                                                &[
                                                    "Restores the state of a ledger which is in an inconsistent state.",
                                                    "",
                                                    "The requirements to restore a ledger are the following:",
                                                    "* The stash is bonded; or",
                                                    "* The stash is not bonded but it has a staking lock left behind; or",
                                                    "* If the stash has an associated ledger and its state is inconsistent; or",
                                                    "* If the ledger is not corrupted *but* its staking lock is out of sync.",
                                                    "",
                                                    "The `maybe_*` input parameters will overwrite the corresponding data and metadata of the",
                                                    "ledger associated with the stash. If the input parameters are not set, the ledger will",
                                                    "be reset values from on-chain state.",
                                                ],
                                            )
                                    },
                                ),
                        )
                }
            }
        };
        impl<T: Config> Call<T> {
            ///Create a call with the variant `bond`.
            pub fn new_call_variant_bond(
                value: BalanceOf<T>,
                payee: RewardDestination<T::AccountId>,
            ) -> Self {
                Self::bond { value, payee }
            }
            ///Create a call with the variant `bond_extra`.
            pub fn new_call_variant_bond_extra(max_additional: BalanceOf<T>) -> Self {
                Self::bond_extra { max_additional }
            }
            ///Create a call with the variant `unbond`.
            pub fn new_call_variant_unbond(value: BalanceOf<T>) -> Self {
                Self::unbond { value }
            }
            ///Create a call with the variant `withdraw_unbonded`.
            pub fn new_call_variant_withdraw_unbonded(num_slashing_spans: u32) -> Self {
                Self::withdraw_unbonded {
                    num_slashing_spans,
                }
            }
            ///Create a call with the variant `validate`.
            pub fn new_call_variant_validate(prefs: ValidatorPrefs) -> Self {
                Self::validate { prefs }
            }
            ///Create a call with the variant `nominate`.
            pub fn new_call_variant_nominate(
                targets: Vec<AccountIdLookupOf<T>>,
            ) -> Self {
                Self::nominate { targets }
            }
            ///Create a call with the variant `chill`.
            pub fn new_call_variant_chill() -> Self {
                Self::chill {}
            }
            ///Create a call with the variant `set_payee`.
            pub fn new_call_variant_set_payee(
                payee: RewardDestination<T::AccountId>,
            ) -> Self {
                Self::set_payee { payee }
            }
            ///Create a call with the variant `set_controller`.
            pub fn new_call_variant_set_controller() -> Self {
                Self::set_controller {}
            }
            ///Create a call with the variant `set_validator_count`.
            pub fn new_call_variant_set_validator_count(new: u32) -> Self {
                Self::set_validator_count { new }
            }
            ///Create a call with the variant `increase_validator_count`.
            pub fn new_call_variant_increase_validator_count(additional: u32) -> Self {
                Self::increase_validator_count {
                    additional,
                }
            }
            ///Create a call with the variant `scale_validator_count`.
            pub fn new_call_variant_scale_validator_count(factor: Percent) -> Self {
                Self::scale_validator_count {
                    factor,
                }
            }
            ///Create a call with the variant `force_no_eras`.
            pub fn new_call_variant_force_no_eras() -> Self {
                Self::force_no_eras {}
            }
            ///Create a call with the variant `force_new_era`.
            pub fn new_call_variant_force_new_era() -> Self {
                Self::force_new_era {}
            }
            ///Create a call with the variant `set_invulnerables`.
            pub fn new_call_variant_set_invulnerables(
                invulnerables: Vec<T::AccountId>,
            ) -> Self {
                Self::set_invulnerables {
                    invulnerables,
                }
            }
            ///Create a call with the variant `force_unstake`.
            pub fn new_call_variant_force_unstake(
                stash: T::AccountId,
                num_slashing_spans: u32,
            ) -> Self {
                Self::force_unstake {
                    stash,
                    num_slashing_spans,
                }
            }
            ///Create a call with the variant `force_new_era_always`.
            pub fn new_call_variant_force_new_era_always() -> Self {
                Self::force_new_era_always {}
            }
            ///Create a call with the variant `cancel_deferred_slash`.
            pub fn new_call_variant_cancel_deferred_slash(
                era: EraIndex,
                slash_indices: Vec<u32>,
            ) -> Self {
                Self::cancel_deferred_slash {
                    era,
                    slash_indices,
                }
            }
            ///Create a call with the variant `payout_stakers`.
            pub fn new_call_variant_payout_stakers(
                validator_stash: T::AccountId,
                era: EraIndex,
            ) -> Self {
                Self::payout_stakers {
                    validator_stash,
                    era,
                }
            }
            ///Create a call with the variant `rebond`.
            pub fn new_call_variant_rebond(value: BalanceOf<T>) -> Self {
                Self::rebond { value }
            }
            ///Create a call with the variant `reap_stash`.
            pub fn new_call_variant_reap_stash(
                stash: T::AccountId,
                num_slashing_spans: u32,
            ) -> Self {
                Self::reap_stash {
                    stash,
                    num_slashing_spans,
                }
            }
            ///Create a call with the variant `kick`.
            pub fn new_call_variant_kick(who: Vec<AccountIdLookupOf<T>>) -> Self {
                Self::kick { who }
            }
            ///Create a call with the variant `set_staking_configs`.
            pub fn new_call_variant_set_staking_configs(
                min_nominator_bond: ConfigOp<BalanceOf<T>>,
                min_validator_bond: ConfigOp<BalanceOf<T>>,
                max_nominator_count: ConfigOp<u32>,
                max_validator_count: ConfigOp<u32>,
                chill_threshold: ConfigOp<Percent>,
                min_commission: ConfigOp<Perbill>,
                max_staked_rewards: ConfigOp<Percent>,
            ) -> Self {
                Self::set_staking_configs {
                    min_nominator_bond,
                    min_validator_bond,
                    max_nominator_count,
                    max_validator_count,
                    chill_threshold,
                    min_commission,
                    max_staked_rewards,
                }
            }
            ///Create a call with the variant `chill_other`.
            pub fn new_call_variant_chill_other(stash: T::AccountId) -> Self {
                Self::chill_other { stash }
            }
            ///Create a call with the variant `force_apply_min_commission`.
            pub fn new_call_variant_force_apply_min_commission(
                validator_stash: T::AccountId,
            ) -> Self {
                Self::force_apply_min_commission {
                    validator_stash,
                }
            }
            ///Create a call with the variant `set_min_commission`.
            pub fn new_call_variant_set_min_commission(new: Perbill) -> Self {
                Self::set_min_commission { new }
            }
            ///Create a call with the variant `payout_stakers_by_page`.
            pub fn new_call_variant_payout_stakers_by_page(
                validator_stash: T::AccountId,
                era: EraIndex,
                page: Page,
            ) -> Self {
                Self::payout_stakers_by_page {
                    validator_stash,
                    era,
                    page,
                }
            }
            ///Create a call with the variant `update_payee`.
            pub fn new_call_variant_update_payee(controller: T::AccountId) -> Self {
                Self::update_payee { controller }
            }
            ///Create a call with the variant `deprecate_controller_batch`.
            pub fn new_call_variant_deprecate_controller_batch(
                controllers: BoundedVec<
                    T::AccountId,
                    T::MaxControllersInDeprecationBatch,
                >,
            ) -> Self {
                Self::deprecate_controller_batch {
                    controllers,
                }
            }
            ///Create a call with the variant `restore_ledger`.
            pub fn new_call_variant_restore_ledger(
                stash: T::AccountId,
                maybe_controller: Option<T::AccountId>,
                maybe_total: Option<BalanceOf<T>>,
                maybe_unlocking: Option<
                    BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>,
                >,
            ) -> Self {
                Self::restore_ledger {
                    stash,
                    maybe_controller,
                    maybe_total,
                    maybe_unlocking,
                }
            }
        }
        impl<T: Config> frame_support::dispatch::GetDispatchInfo for Call<T> {
            fn get_dispatch_info(&self) -> frame_support::dispatch::DispatchInfo {
                match *self {
                    Self::bond { ref value, ref payee } => {
                        let __pallet_base_weight = T::WeightInfo::bond();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&BalanceOf<T>, &RewardDestination<T::AccountId>),
                        >>::weigh_data(&__pallet_base_weight, (value, payee));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&BalanceOf<T>, &RewardDestination<T::AccountId>),
                        >>::classify_dispatch(&__pallet_base_weight, (value, payee));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&BalanceOf<T>, &RewardDestination<T::AccountId>),
                        >>::pays_fee(&__pallet_base_weight, (value, payee));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::bond_extra { ref max_additional } => {
                        let __pallet_base_weight = T::WeightInfo::bond_extra();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&BalanceOf<T>,),
                        >>::weigh_data(&__pallet_base_weight, (max_additional,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&BalanceOf<T>,),
                        >>::classify_dispatch(&__pallet_base_weight, (max_additional,));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&BalanceOf<T>,),
                        >>::pays_fee(&__pallet_base_weight, (max_additional,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::unbond { ref value } => {
                        let __pallet_base_weight = T::WeightInfo::withdraw_unbonded_kill(
                                SPECULATIVE_NUM_SPANS,
                            )
                            .saturating_add(T::WeightInfo::unbond());
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&BalanceOf<T>,),
                        >>::weigh_data(&__pallet_base_weight, (value,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&BalanceOf<T>,),
                        >>::classify_dispatch(&__pallet_base_weight, (value,));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&BalanceOf<T>,),
                        >>::pays_fee(&__pallet_base_weight, (value,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::withdraw_unbonded { ref num_slashing_spans } => {
                        let __pallet_base_weight = T::WeightInfo::withdraw_unbonded_kill(
                            *num_slashing_spans,
                        );
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&u32,),
                        >>::weigh_data(&__pallet_base_weight, (num_slashing_spans,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&u32,),
                        >>::classify_dispatch(
                            &__pallet_base_weight,
                            (num_slashing_spans,),
                        );
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&u32,),
                        >>::pays_fee(&__pallet_base_weight, (num_slashing_spans,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::validate { ref prefs } => {
                        let __pallet_base_weight = T::WeightInfo::validate();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&ValidatorPrefs,),
                        >>::weigh_data(&__pallet_base_weight, (prefs,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&ValidatorPrefs,),
                        >>::classify_dispatch(&__pallet_base_weight, (prefs,));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&ValidatorPrefs,),
                        >>::pays_fee(&__pallet_base_weight, (prefs,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::nominate { ref targets } => {
                        let __pallet_base_weight = T::WeightInfo::nominate(
                            targets.len() as u32,
                        );
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&Vec<AccountIdLookupOf<T>>,),
                        >>::weigh_data(&__pallet_base_weight, (targets,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&Vec<AccountIdLookupOf<T>>,),
                        >>::classify_dispatch(&__pallet_base_weight, (targets,));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&Vec<AccountIdLookupOf<T>>,),
                        >>::pays_fee(&__pallet_base_weight, (targets,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::chill {} => {
                        let __pallet_base_weight = T::WeightInfo::chill();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (),
                        >>::weigh_data(&__pallet_base_weight, ());
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (),
                        >>::classify_dispatch(&__pallet_base_weight, ());
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (),
                        >>::pays_fee(&__pallet_base_weight, ());
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::set_payee { ref payee } => {
                        let __pallet_base_weight = T::WeightInfo::set_payee();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&RewardDestination<T::AccountId>,),
                        >>::weigh_data(&__pallet_base_weight, (payee,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&RewardDestination<T::AccountId>,),
                        >>::classify_dispatch(&__pallet_base_weight, (payee,));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&RewardDestination<T::AccountId>,),
                        >>::pays_fee(&__pallet_base_weight, (payee,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::set_controller {} => {
                        let __pallet_base_weight = T::WeightInfo::set_controller();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (),
                        >>::weigh_data(&__pallet_base_weight, ());
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (),
                        >>::classify_dispatch(&__pallet_base_weight, ());
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (),
                        >>::pays_fee(&__pallet_base_weight, ());
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::set_validator_count { ref new } => {
                        let __pallet_base_weight = T::WeightInfo::set_validator_count();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&u32,),
                        >>::weigh_data(&__pallet_base_weight, (new,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&u32,),
                        >>::classify_dispatch(&__pallet_base_weight, (new,));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&u32,),
                        >>::pays_fee(&__pallet_base_weight, (new,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::increase_validator_count { ref additional } => {
                        let __pallet_base_weight = T::WeightInfo::set_validator_count();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&u32,),
                        >>::weigh_data(&__pallet_base_weight, (additional,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&u32,),
                        >>::classify_dispatch(&__pallet_base_weight, (additional,));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&u32,),
                        >>::pays_fee(&__pallet_base_weight, (additional,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::scale_validator_count { ref factor } => {
                        let __pallet_base_weight = T::WeightInfo::set_validator_count();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&Percent,),
                        >>::weigh_data(&__pallet_base_weight, (factor,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&Percent,),
                        >>::classify_dispatch(&__pallet_base_weight, (factor,));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&Percent,),
                        >>::pays_fee(&__pallet_base_weight, (factor,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::force_no_eras {} => {
                        let __pallet_base_weight = T::WeightInfo::force_no_eras();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (),
                        >>::weigh_data(&__pallet_base_weight, ());
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (),
                        >>::classify_dispatch(&__pallet_base_weight, ());
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (),
                        >>::pays_fee(&__pallet_base_weight, ());
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::force_new_era {} => {
                        let __pallet_base_weight = T::WeightInfo::force_new_era();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (),
                        >>::weigh_data(&__pallet_base_weight, ());
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (),
                        >>::classify_dispatch(&__pallet_base_weight, ());
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (),
                        >>::pays_fee(&__pallet_base_weight, ());
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::set_invulnerables { ref invulnerables } => {
                        let __pallet_base_weight = T::WeightInfo::set_invulnerables(
                            invulnerables.len() as u32,
                        );
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&Vec<T::AccountId>,),
                        >>::weigh_data(&__pallet_base_weight, (invulnerables,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&Vec<T::AccountId>,),
                        >>::classify_dispatch(&__pallet_base_weight, (invulnerables,));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&Vec<T::AccountId>,),
                        >>::pays_fee(&__pallet_base_weight, (invulnerables,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::force_unstake { ref stash, ref num_slashing_spans } => {
                        let __pallet_base_weight = T::WeightInfo::force_unstake(
                            *num_slashing_spans,
                        );
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&T::AccountId, &u32),
                        >>::weigh_data(
                            &__pallet_base_weight,
                            (stash, num_slashing_spans),
                        );
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&T::AccountId, &u32),
                        >>::classify_dispatch(
                            &__pallet_base_weight,
                            (stash, num_slashing_spans),
                        );
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&T::AccountId, &u32),
                        >>::pays_fee(&__pallet_base_weight, (stash, num_slashing_spans));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::force_new_era_always {} => {
                        let __pallet_base_weight = T::WeightInfo::force_new_era_always();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (),
                        >>::weigh_data(&__pallet_base_weight, ());
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (),
                        >>::classify_dispatch(&__pallet_base_weight, ());
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (),
                        >>::pays_fee(&__pallet_base_weight, ());
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::cancel_deferred_slash { ref era, ref slash_indices } => {
                        let __pallet_base_weight = T::WeightInfo::cancel_deferred_slash(
                            slash_indices.len() as u32,
                        );
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&EraIndex, &Vec<u32>),
                        >>::weigh_data(&__pallet_base_weight, (era, slash_indices));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&EraIndex, &Vec<u32>),
                        >>::classify_dispatch(
                            &__pallet_base_weight,
                            (era, slash_indices),
                        );
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&EraIndex, &Vec<u32>),
                        >>::pays_fee(&__pallet_base_weight, (era, slash_indices));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::payout_stakers { ref validator_stash, ref era } => {
                        let __pallet_base_weight = T::WeightInfo::payout_stakers_alive_staked(
                            T::MaxExposurePageSize::get(),
                        );
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&T::AccountId, &EraIndex),
                        >>::weigh_data(&__pallet_base_weight, (validator_stash, era));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&T::AccountId, &EraIndex),
                        >>::classify_dispatch(
                            &__pallet_base_weight,
                            (validator_stash, era),
                        );
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&T::AccountId, &EraIndex),
                        >>::pays_fee(&__pallet_base_weight, (validator_stash, era));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::rebond { ref value } => {
                        let __pallet_base_weight = T::WeightInfo::rebond(
                            T::MaxUnlockingChunks::get() as u32,
                        );
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&BalanceOf<T>,),
                        >>::weigh_data(&__pallet_base_weight, (value,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&BalanceOf<T>,),
                        >>::classify_dispatch(&__pallet_base_weight, (value,));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&BalanceOf<T>,),
                        >>::pays_fee(&__pallet_base_weight, (value,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::reap_stash { ref stash, ref num_slashing_spans } => {
                        let __pallet_base_weight = T::WeightInfo::reap_stash(
                            *num_slashing_spans,
                        );
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&T::AccountId, &u32),
                        >>::weigh_data(
                            &__pallet_base_weight,
                            (stash, num_slashing_spans),
                        );
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&T::AccountId, &u32),
                        >>::classify_dispatch(
                            &__pallet_base_weight,
                            (stash, num_slashing_spans),
                        );
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&T::AccountId, &u32),
                        >>::pays_fee(&__pallet_base_weight, (stash, num_slashing_spans));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::kick { ref who } => {
                        let __pallet_base_weight = T::WeightInfo::kick(who.len() as u32);
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&Vec<AccountIdLookupOf<T>>,),
                        >>::weigh_data(&__pallet_base_weight, (who,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&Vec<AccountIdLookupOf<T>>,),
                        >>::classify_dispatch(&__pallet_base_weight, (who,));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&Vec<AccountIdLookupOf<T>>,),
                        >>::pays_fee(&__pallet_base_weight, (who,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::set_staking_configs {
                        ref min_nominator_bond,
                        ref min_validator_bond,
                        ref max_nominator_count,
                        ref max_validator_count,
                        ref chill_threshold,
                        ref min_commission,
                        ref max_staked_rewards,
                    } => {
                        let __pallet_base_weight = T::WeightInfo::set_staking_configs_all_set()
                            .max(T::WeightInfo::set_staking_configs_all_remove());
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (
                                &ConfigOp<BalanceOf<T>>,
                                &ConfigOp<BalanceOf<T>>,
                                &ConfigOp<u32>,
                                &ConfigOp<u32>,
                                &ConfigOp<Percent>,
                                &ConfigOp<Perbill>,
                                &ConfigOp<Percent>,
                            ),
                        >>::weigh_data(
                            &__pallet_base_weight,
                            (
                                min_nominator_bond,
                                min_validator_bond,
                                max_nominator_count,
                                max_validator_count,
                                chill_threshold,
                                min_commission,
                                max_staked_rewards,
                            ),
                        );
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (
                                &ConfigOp<BalanceOf<T>>,
                                &ConfigOp<BalanceOf<T>>,
                                &ConfigOp<u32>,
                                &ConfigOp<u32>,
                                &ConfigOp<Percent>,
                                &ConfigOp<Perbill>,
                                &ConfigOp<Percent>,
                            ),
                        >>::classify_dispatch(
                            &__pallet_base_weight,
                            (
                                min_nominator_bond,
                                min_validator_bond,
                                max_nominator_count,
                                max_validator_count,
                                chill_threshold,
                                min_commission,
                                max_staked_rewards,
                            ),
                        );
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (
                                &ConfigOp<BalanceOf<T>>,
                                &ConfigOp<BalanceOf<T>>,
                                &ConfigOp<u32>,
                                &ConfigOp<u32>,
                                &ConfigOp<Percent>,
                                &ConfigOp<Perbill>,
                                &ConfigOp<Percent>,
                            ),
                        >>::pays_fee(
                            &__pallet_base_weight,
                            (
                                min_nominator_bond,
                                min_validator_bond,
                                max_nominator_count,
                                max_validator_count,
                                chill_threshold,
                                min_commission,
                                max_staked_rewards,
                            ),
                        );
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::chill_other { ref stash } => {
                        let __pallet_base_weight = T::WeightInfo::chill_other();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&T::AccountId,),
                        >>::weigh_data(&__pallet_base_weight, (stash,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&T::AccountId,),
                        >>::classify_dispatch(&__pallet_base_weight, (stash,));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&T::AccountId,),
                        >>::pays_fee(&__pallet_base_weight, (stash,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::force_apply_min_commission { ref validator_stash } => {
                        let __pallet_base_weight = T::WeightInfo::force_apply_min_commission();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&T::AccountId,),
                        >>::weigh_data(&__pallet_base_weight, (validator_stash,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&T::AccountId,),
                        >>::classify_dispatch(&__pallet_base_weight, (validator_stash,));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&T::AccountId,),
                        >>::pays_fee(&__pallet_base_weight, (validator_stash,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::set_min_commission { ref new } => {
                        let __pallet_base_weight = T::WeightInfo::set_min_commission();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&Perbill,),
                        >>::weigh_data(&__pallet_base_weight, (new,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&Perbill,),
                        >>::classify_dispatch(&__pallet_base_weight, (new,));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&Perbill,),
                        >>::pays_fee(&__pallet_base_weight, (new,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::payout_stakers_by_page {
                        ref validator_stash,
                        ref era,
                        ref page,
                    } => {
                        let __pallet_base_weight = T::WeightInfo::payout_stakers_alive_staked(
                            T::MaxExposurePageSize::get(),
                        );
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&T::AccountId, &EraIndex, &Page),
                        >>::weigh_data(
                            &__pallet_base_weight,
                            (validator_stash, era, page),
                        );
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&T::AccountId, &EraIndex, &Page),
                        >>::classify_dispatch(
                            &__pallet_base_weight,
                            (validator_stash, era, page),
                        );
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&T::AccountId, &EraIndex, &Page),
                        >>::pays_fee(
                            &__pallet_base_weight,
                            (validator_stash, era, page),
                        );
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::update_payee { ref controller } => {
                        let __pallet_base_weight = T::WeightInfo::update_payee();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (&T::AccountId,),
                        >>::weigh_data(&__pallet_base_weight, (controller,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (&T::AccountId,),
                        >>::classify_dispatch(&__pallet_base_weight, (controller,));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (&T::AccountId,),
                        >>::pays_fee(&__pallet_base_weight, (controller,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::deprecate_controller_batch { ref controllers } => {
                        let __pallet_base_weight = T::WeightInfo::deprecate_controller_batch(
                            controllers.len() as u32,
                        );
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (
                                &BoundedVec<
                                    T::AccountId,
                                    T::MaxControllersInDeprecationBatch,
                                >,
                            ),
                        >>::weigh_data(&__pallet_base_weight, (controllers,));
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (
                                &BoundedVec<
                                    T::AccountId,
                                    T::MaxControllersInDeprecationBatch,
                                >,
                            ),
                        >>::classify_dispatch(&__pallet_base_weight, (controllers,));
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (
                                &BoundedVec<
                                    T::AccountId,
                                    T::MaxControllersInDeprecationBatch,
                                >,
                            ),
                        >>::pays_fee(&__pallet_base_weight, (controllers,));
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::restore_ledger {
                        ref stash,
                        ref maybe_controller,
                        ref maybe_total,
                        ref maybe_unlocking,
                    } => {
                        let __pallet_base_weight = T::WeightInfo::restore_ledger();
                        let __pallet_weight = <dyn frame_support::dispatch::WeighData<
                            (
                                &T::AccountId,
                                &Option<T::AccountId>,
                                &Option<BalanceOf<T>>,
                                &Option<
                                    BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>,
                                >,
                            ),
                        >>::weigh_data(
                            &__pallet_base_weight,
                            (stash, maybe_controller, maybe_total, maybe_unlocking),
                        );
                        let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<
                            (
                                &T::AccountId,
                                &Option<T::AccountId>,
                                &Option<BalanceOf<T>>,
                                &Option<
                                    BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>,
                                >,
                            ),
                        >>::classify_dispatch(
                            &__pallet_base_weight,
                            (stash, maybe_controller, maybe_total, maybe_unlocking),
                        );
                        let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<
                            (
                                &T::AccountId,
                                &Option<T::AccountId>,
                                &Option<BalanceOf<T>>,
                                &Option<
                                    BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>,
                                >,
                            ),
                        >>::pays_fee(
                            &__pallet_base_weight,
                            (stash, maybe_controller, maybe_total, maybe_unlocking),
                        );
                        frame_support::dispatch::DispatchInfo {
                            call_weight: __pallet_weight,
                            extension_weight: Default::default(),
                            class: __pallet_class,
                            pays_fee: __pallet_pays_fee,
                        }
                    }
                    Self::__Ignore(_, _) => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("__Ignore cannot be used"),
                            ),
                        );
                    }
                }
            }
        }
        impl<T: Config> frame_support::dispatch::CheckIfFeeless for Call<T> {
            type Origin = frame_system::pallet_prelude::OriginFor<T>;
            #[allow(unused_variables)]
            fn is_feeless(&self, origin: &Self::Origin) -> bool {
                match *self {
                    Self::bond { ref value, ref payee } => {
                        let feeless_check = |_origin, value, payee| { false };
                        feeless_check(origin, value, payee)
                    }
                    Self::bond_extra { ref max_additional } => {
                        let feeless_check = |_origin, max_additional| { false };
                        feeless_check(origin, max_additional)
                    }
                    Self::unbond { ref value } => {
                        let feeless_check = |_origin, value| { false };
                        feeless_check(origin, value)
                    }
                    Self::withdraw_unbonded { ref num_slashing_spans } => {
                        let feeless_check = |_origin, num_slashing_spans| { false };
                        feeless_check(origin, num_slashing_spans)
                    }
                    Self::validate { ref prefs } => {
                        let feeless_check = |_origin, prefs| { false };
                        feeless_check(origin, prefs)
                    }
                    Self::nominate { ref targets } => {
                        let feeless_check = |_origin, targets| { false };
                        feeless_check(origin, targets)
                    }
                    Self::chill {} => {
                        let feeless_check = |_origin| { false };
                        feeless_check(origin)
                    }
                    Self::set_payee { ref payee } => {
                        let feeless_check = |_origin, payee| { false };
                        feeless_check(origin, payee)
                    }
                    Self::set_controller {} => {
                        let feeless_check = |_origin| { false };
                        feeless_check(origin)
                    }
                    Self::set_validator_count { ref new } => {
                        let feeless_check = |_origin, new| { false };
                        feeless_check(origin, new)
                    }
                    Self::increase_validator_count { ref additional } => {
                        let feeless_check = |_origin, additional| { false };
                        feeless_check(origin, additional)
                    }
                    Self::scale_validator_count { ref factor } => {
                        let feeless_check = |_origin, factor| { false };
                        feeless_check(origin, factor)
                    }
                    Self::force_no_eras {} => {
                        let feeless_check = |_origin| { false };
                        feeless_check(origin)
                    }
                    Self::force_new_era {} => {
                        let feeless_check = |_origin| { false };
                        feeless_check(origin)
                    }
                    Self::set_invulnerables { ref invulnerables } => {
                        let feeless_check = |_origin, invulnerables| { false };
                        feeless_check(origin, invulnerables)
                    }
                    Self::force_unstake { ref stash, ref num_slashing_spans } => {
                        let feeless_check = |_origin, stash, num_slashing_spans| {
                            false
                        };
                        feeless_check(origin, stash, num_slashing_spans)
                    }
                    Self::force_new_era_always {} => {
                        let feeless_check = |_origin| { false };
                        feeless_check(origin)
                    }
                    Self::cancel_deferred_slash { ref era, ref slash_indices } => {
                        let feeless_check = |_origin, era, slash_indices| { false };
                        feeless_check(origin, era, slash_indices)
                    }
                    Self::payout_stakers { ref validator_stash, ref era } => {
                        let feeless_check = |_origin, validator_stash, era| { false };
                        feeless_check(origin, validator_stash, era)
                    }
                    Self::rebond { ref value } => {
                        let feeless_check = |_origin, value| { false };
                        feeless_check(origin, value)
                    }
                    Self::reap_stash { ref stash, ref num_slashing_spans } => {
                        let feeless_check = |_origin, stash, num_slashing_spans| {
                            false
                        };
                        feeless_check(origin, stash, num_slashing_spans)
                    }
                    Self::kick { ref who } => {
                        let feeless_check = |_origin, who| { false };
                        feeless_check(origin, who)
                    }
                    Self::set_staking_configs {
                        ref min_nominator_bond,
                        ref min_validator_bond,
                        ref max_nominator_count,
                        ref max_validator_count,
                        ref chill_threshold,
                        ref min_commission,
                        ref max_staked_rewards,
                    } => {
                        let feeless_check = |
                            _origin,
                            min_nominator_bond,
                            min_validator_bond,
                            max_nominator_count,
                            max_validator_count,
                            chill_threshold,
                            min_commission,
                            max_staked_rewards|
                        { false };
                        feeless_check(
                            origin,
                            min_nominator_bond,
                            min_validator_bond,
                            max_nominator_count,
                            max_validator_count,
                            chill_threshold,
                            min_commission,
                            max_staked_rewards,
                        )
                    }
                    Self::chill_other { ref stash } => {
                        let feeless_check = |_origin, stash| { false };
                        feeless_check(origin, stash)
                    }
                    Self::force_apply_min_commission { ref validator_stash } => {
                        let feeless_check = |_origin, validator_stash| { false };
                        feeless_check(origin, validator_stash)
                    }
                    Self::set_min_commission { ref new } => {
                        let feeless_check = |_origin, new| { false };
                        feeless_check(origin, new)
                    }
                    Self::payout_stakers_by_page {
                        ref validator_stash,
                        ref era,
                        ref page,
                    } => {
                        let feeless_check = |_origin, validator_stash, era, page| {
                            false
                        };
                        feeless_check(origin, validator_stash, era, page)
                    }
                    Self::update_payee { ref controller } => {
                        let feeless_check = |_origin, controller| { false };
                        feeless_check(origin, controller)
                    }
                    Self::deprecate_controller_batch { ref controllers } => {
                        let feeless_check = |_origin, controllers| { false };
                        feeless_check(origin, controllers)
                    }
                    Self::restore_ledger {
                        ref stash,
                        ref maybe_controller,
                        ref maybe_total,
                        ref maybe_unlocking,
                    } => {
                        let feeless_check = |
                            _origin,
                            stash,
                            maybe_controller,
                            maybe_total,
                            maybe_unlocking|
                        { false };
                        feeless_check(
                            origin,
                            stash,
                            maybe_controller,
                            maybe_total,
                            maybe_unlocking,
                        )
                    }
                    Self::__Ignore(_, _) => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("__Ignore cannot be used"),
                            ),
                        );
                    }
                }
            }
        }
        impl<T: Config> frame_support::traits::GetCallName for Call<T> {
            fn get_call_name(&self) -> &'static str {
                match *self {
                    Self::bond { .. } => "bond",
                    Self::bond_extra { .. } => "bond_extra",
                    Self::unbond { .. } => "unbond",
                    Self::withdraw_unbonded { .. } => "withdraw_unbonded",
                    Self::validate { .. } => "validate",
                    Self::nominate { .. } => "nominate",
                    Self::chill { .. } => "chill",
                    Self::set_payee { .. } => "set_payee",
                    Self::set_controller { .. } => "set_controller",
                    Self::set_validator_count { .. } => "set_validator_count",
                    Self::increase_validator_count { .. } => "increase_validator_count",
                    Self::scale_validator_count { .. } => "scale_validator_count",
                    Self::force_no_eras { .. } => "force_no_eras",
                    Self::force_new_era { .. } => "force_new_era",
                    Self::set_invulnerables { .. } => "set_invulnerables",
                    Self::force_unstake { .. } => "force_unstake",
                    Self::force_new_era_always { .. } => "force_new_era_always",
                    Self::cancel_deferred_slash { .. } => "cancel_deferred_slash",
                    Self::payout_stakers { .. } => "payout_stakers",
                    Self::rebond { .. } => "rebond",
                    Self::reap_stash { .. } => "reap_stash",
                    Self::kick { .. } => "kick",
                    Self::set_staking_configs { .. } => "set_staking_configs",
                    Self::chill_other { .. } => "chill_other",
                    Self::force_apply_min_commission { .. } => {
                        "force_apply_min_commission"
                    }
                    Self::set_min_commission { .. } => "set_min_commission",
                    Self::payout_stakers_by_page { .. } => "payout_stakers_by_page",
                    Self::update_payee { .. } => "update_payee",
                    Self::deprecate_controller_batch { .. } => {
                        "deprecate_controller_batch"
                    }
                    Self::restore_ledger { .. } => "restore_ledger",
                    Self::__Ignore(_, _) => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("__PhantomItem cannot be used."),
                            ),
                        );
                    }
                }
            }
            fn get_call_names() -> &'static [&'static str] {
                &[
                    "bond",
                    "bond_extra",
                    "unbond",
                    "withdraw_unbonded",
                    "validate",
                    "nominate",
                    "chill",
                    "set_payee",
                    "set_controller",
                    "set_validator_count",
                    "increase_validator_count",
                    "scale_validator_count",
                    "force_no_eras",
                    "force_new_era",
                    "set_invulnerables",
                    "force_unstake",
                    "force_new_era_always",
                    "cancel_deferred_slash",
                    "payout_stakers",
                    "rebond",
                    "reap_stash",
                    "kick",
                    "set_staking_configs",
                    "chill_other",
                    "force_apply_min_commission",
                    "set_min_commission",
                    "payout_stakers_by_page",
                    "update_payee",
                    "deprecate_controller_batch",
                    "restore_ledger",
                ]
            }
        }
        impl<T: Config> frame_support::traits::GetCallIndex for Call<T> {
            fn get_call_index(&self) -> u8 {
                match *self {
                    Self::bond { .. } => 0u8,
                    Self::bond_extra { .. } => 1u8,
                    Self::unbond { .. } => 2u8,
                    Self::withdraw_unbonded { .. } => 3u8,
                    Self::validate { .. } => 4u8,
                    Self::nominate { .. } => 5u8,
                    Self::chill { .. } => 6u8,
                    Self::set_payee { .. } => 7u8,
                    Self::set_controller { .. } => 8u8,
                    Self::set_validator_count { .. } => 9u8,
                    Self::increase_validator_count { .. } => 10u8,
                    Self::scale_validator_count { .. } => 11u8,
                    Self::force_no_eras { .. } => 12u8,
                    Self::force_new_era { .. } => 13u8,
                    Self::set_invulnerables { .. } => 14u8,
                    Self::force_unstake { .. } => 15u8,
                    Self::force_new_era_always { .. } => 16u8,
                    Self::cancel_deferred_slash { .. } => 17u8,
                    Self::payout_stakers { .. } => 18u8,
                    Self::rebond { .. } => 19u8,
                    Self::reap_stash { .. } => 20u8,
                    Self::kick { .. } => 21u8,
                    Self::set_staking_configs { .. } => 22u8,
                    Self::chill_other { .. } => 23u8,
                    Self::force_apply_min_commission { .. } => 24u8,
                    Self::set_min_commission { .. } => 25u8,
                    Self::payout_stakers_by_page { .. } => 26u8,
                    Self::update_payee { .. } => 27u8,
                    Self::deprecate_controller_batch { .. } => 28u8,
                    Self::restore_ledger { .. } => 29u8,
                    Self::__Ignore(_, _) => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("__PhantomItem cannot be used."),
                            ),
                        );
                    }
                }
            }
            fn get_call_indices() -> &'static [u8] {
                &[
                    0u8,
                    1u8,
                    2u8,
                    3u8,
                    4u8,
                    5u8,
                    6u8,
                    7u8,
                    8u8,
                    9u8,
                    10u8,
                    11u8,
                    12u8,
                    13u8,
                    14u8,
                    15u8,
                    16u8,
                    17u8,
                    18u8,
                    19u8,
                    20u8,
                    21u8,
                    22u8,
                    23u8,
                    24u8,
                    25u8,
                    26u8,
                    27u8,
                    28u8,
                    29u8,
                ]
            }
        }
        impl<T: Config> frame_support::traits::UnfilteredDispatchable for Call<T> {
            type RuntimeOrigin = frame_system::pallet_prelude::OriginFor<T>;
            fn dispatch_bypass_filter(
                self,
                origin: Self::RuntimeOrigin,
            ) -> frame_support::dispatch::DispatchResultWithPostInfo {
                frame_support::dispatch_context::run_in_context(|| {
                    match self {
                        Self::bond { value, payee } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "bond",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::bond(origin, value, payee)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::bond_extra { max_additional } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "bond_extra",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::bond_extra(origin, max_additional)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::unbond { value } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "unbond",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::unbond(origin, value)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::withdraw_unbonded { num_slashing_spans } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "withdraw_unbonded",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::withdraw_unbonded(origin, num_slashing_spans)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::validate { prefs } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "validate",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::validate(origin, prefs)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::nominate { targets } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "nominate",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::nominate(origin, targets)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::chill {} => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "chill",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::chill(origin)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::set_payee { payee } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "set_payee",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::set_payee(origin, payee)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::set_controller {} => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "set_controller",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::set_controller(origin)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::set_validator_count { new } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "set_validator_count",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::set_validator_count(origin, new)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::increase_validator_count { additional } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "increase_validator_count",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::increase_validator_count(origin, additional)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::scale_validator_count { factor } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "scale_validator_count",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::scale_validator_count(origin, factor)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::force_no_eras {} => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "force_no_eras",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::force_no_eras(origin)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::force_new_era {} => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "force_new_era",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::force_new_era(origin)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::set_invulnerables { invulnerables } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "set_invulnerables",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::set_invulnerables(origin, invulnerables)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::force_unstake { stash, num_slashing_spans } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "force_unstake",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::force_unstake(origin, stash, num_slashing_spans)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::force_new_era_always {} => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "force_new_era_always",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::force_new_era_always(origin)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::cancel_deferred_slash { era, slash_indices } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "cancel_deferred_slash",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<
                                T,
                            >>::cancel_deferred_slash(origin, era, slash_indices)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::payout_stakers { validator_stash, era } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "payout_stakers",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::payout_stakers(origin, validator_stash, era)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::rebond { value } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "rebond",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::rebond(origin, value)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::reap_stash { stash, num_slashing_spans } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "reap_stash",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::reap_stash(origin, stash, num_slashing_spans)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::kick { who } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "kick",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::kick(origin, who)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::set_staking_configs {
                            min_nominator_bond,
                            min_validator_bond,
                            max_nominator_count,
                            max_validator_count,
                            chill_threshold,
                            min_commission,
                            max_staked_rewards,
                        } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "set_staking_configs",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<
                                T,
                            >>::set_staking_configs(
                                    origin,
                                    min_nominator_bond,
                                    min_validator_bond,
                                    max_nominator_count,
                                    max_validator_count,
                                    chill_threshold,
                                    min_commission,
                                    max_staked_rewards,
                                )
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::chill_other { stash } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "chill_other",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::chill_other(origin, stash)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::force_apply_min_commission { validator_stash } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "force_apply_min_commission",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<
                                T,
                            >>::force_apply_min_commission(origin, validator_stash)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::set_min_commission { new } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "set_min_commission",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::set_min_commission(origin, new)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::payout_stakers_by_page { validator_stash, era, page } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "payout_stakers_by_page",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<
                                T,
                            >>::payout_stakers_by_page(
                                    origin,
                                    validator_stash,
                                    era,
                                    page,
                                )
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::update_payee { controller } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "update_payee",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::update_payee(origin, controller)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::deprecate_controller_batch { controllers } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "deprecate_controller_batch",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<T>>::deprecate_controller_batch(origin, controllers)
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::restore_ledger {
                            stash,
                            maybe_controller,
                            maybe_total,
                            maybe_unlocking,
                        } => {
                            let __within_span__ = {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "restore_ledger",
                                            "pallet_staking::pallet::pallet",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "substrate/frame/staking/src/pallet/mod.rs",
                                            ),
                                            ::core::option::Option::Some(63u32),
                                            ::core::option::Option::Some(
                                                "pallet_staking::pallet::pallet",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &[],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::SPAN,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let mut interest = ::tracing::subscriber::Interest::never();
                                if ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        interest = __CALLSITE.interest();
                                        !interest.is_never()
                                    }
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                                {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Span::new(
                                        meta,
                                        &{ meta.fields().value_set(&[]) },
                                    )
                                } else {
                                    let span = ::tracing::__macro_support::__disabled_span(
                                        __CALLSITE.metadata(),
                                    );
                                    if match ::tracing::Level::TRACE {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                span.record_all(
                                                    &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                                );
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                    span
                                }
                            };
                            let __tracing_guard__ = __within_span__.enter();
                            <Pallet<
                                T,
                            >>::restore_ledger(
                                    origin,
                                    stash,
                                    maybe_controller,
                                    maybe_total,
                                    maybe_unlocking,
                                )
                                .map(Into::into)
                                .map_err(Into::into)
                        }
                        Self::__Ignore(_, _) => {
                            let _ = origin;
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("__PhantomItem cannot be used."),
                                    ),
                                );
                            };
                        }
                    }
                })
            }
        }
        impl<T: Config> frame_support::dispatch::Callable<T> for Pallet<T> {
            type RuntimeCall = Call<T>;
        }
        impl<T: Config> Pallet<T> {
            #[allow(dead_code)]
            #[doc(hidden)]
            pub fn call_functions() -> frame_support::__private::metadata_ir::PalletCallMetadataIR {
                frame_support::__private::metadata_ir::PalletCallMetadataIR {
                    ty: frame_support::__private::scale_info::meta_type::<Call<T>>(),
                    deprecation_info: frame_support::__private::metadata_ir::DeprecationInfoIR::NotDeprecated,
                }
            }
        }
        impl<T: Config> core::fmt::Debug for Error<T> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                f.write_str(self.as_str())
            }
        }
        impl<T: Config> Error<T> {
            #[doc(hidden)]
            pub fn as_str(&self) -> &'static str {
                match &self {
                    Self::__Ignore(_, _) => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("`__Ignore` can never be constructed"),
                            ),
                        );
                    }
                    Self::NotController => "NotController",
                    Self::NotStash => "NotStash",
                    Self::AlreadyBonded => "AlreadyBonded",
                    Self::AlreadyPaired => "AlreadyPaired",
                    Self::EmptyTargets => "EmptyTargets",
                    Self::DuplicateIndex => "DuplicateIndex",
                    Self::InvalidSlashIndex => "InvalidSlashIndex",
                    Self::InsufficientBond => "InsufficientBond",
                    Self::NoMoreChunks => "NoMoreChunks",
                    Self::NoUnlockChunk => "NoUnlockChunk",
                    Self::FundedTarget => "FundedTarget",
                    Self::InvalidEraToReward => "InvalidEraToReward",
                    Self::InvalidNumberOfNominations => "InvalidNumberOfNominations",
                    Self::NotSortedAndUnique => "NotSortedAndUnique",
                    Self::AlreadyClaimed => "AlreadyClaimed",
                    Self::InvalidPage => "InvalidPage",
                    Self::IncorrectHistoryDepth => "IncorrectHistoryDepth",
                    Self::IncorrectSlashingSpans => "IncorrectSlashingSpans",
                    Self::BadState => "BadState",
                    Self::TooManyTargets => "TooManyTargets",
                    Self::BadTarget => "BadTarget",
                    Self::CannotChillOther => "CannotChillOther",
                    Self::TooManyNominators => "TooManyNominators",
                    Self::TooManyValidators => "TooManyValidators",
                    Self::CommissionTooLow => "CommissionTooLow",
                    Self::BoundNotMet => "BoundNotMet",
                    Self::ControllerDeprecated => "ControllerDeprecated",
                    Self::CannotRestoreLedger => "CannotRestoreLedger",
                    Self::RewardDestinationRestricted => "RewardDestinationRestricted",
                    Self::NotEnoughFunds => "NotEnoughFunds",
                    Self::VirtualStakerNotAllowed => "VirtualStakerNotAllowed",
                }
            }
        }
        impl<T: Config> From<Error<T>> for &'static str {
            fn from(err: Error<T>) -> &'static str {
                err.as_str()
            }
        }
        impl<T: Config> From<Error<T>> for frame_support::sp_runtime::DispatchError {
            fn from(err: Error<T>) -> Self {
                use frame_support::__private::codec::Encode;
                let index = <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::index::<
                    Pallet<T>,
                >()
                    .expect("Every active module has an index in the runtime; qed")
                    as u8;
                let mut encoded = err.encode();
                encoded.resize(frame_support::MAX_MODULE_ERROR_ENCODED_SIZE, 0);
                frame_support::sp_runtime::DispatchError::Module(frame_support::sp_runtime::ModuleError {
                    index,
                    error: TryInto::try_into(encoded)
                        .expect(
                            "encoded error is resized to be equal to the maximum encoded error size; qed",
                        ),
                    message: Some(err.as_str()),
                })
            }
        }
        pub use __tt_error_token_1 as tt_error_token;
        impl<T: Config> Error<T> {
            #[allow(dead_code)]
            #[doc(hidden)]
            pub fn error_metadata() -> frame_support::__private::metadata_ir::PalletErrorMetadataIR {
                frame_support::__private::metadata_ir::PalletErrorMetadataIR {
                    ty: frame_support::__private::scale_info::meta_type::<Error<T>>(),
                    deprecation_info: frame_support::__private::metadata_ir::DeprecationInfoIR::NotDeprecated,
                }
            }
        }
        #[doc(hidden)]
        pub mod __substrate_event_check {
            #[doc(hidden)]
            pub use __is_event_part_defined_2 as is_event_part_defined;
        }
        impl<T: Config> Pallet<T> {
            pub(crate) fn deposit_event(event: Event<T>) {
                let event = <<T as Config>::RuntimeEvent as From<Event<T>>>::from(event);
                let event = <<T as Config>::RuntimeEvent as Into<
                    <T as frame_system::Config>::RuntimeEvent,
                >>::into(event);
                <frame_system::Pallet<T>>::deposit_event(event)
            }
        }
        impl<T: Config> From<Event<T>> for () {
            fn from(_: Event<T>) {}
        }
        impl<T: Config> Event<T> {
            #[allow(dead_code)]
            #[doc(hidden)]
            pub fn event_metadata<
                W: frame_support::__private::scale_info::TypeInfo + 'static,
            >() -> frame_support::__private::metadata_ir::PalletEventMetadataIR {
                frame_support::__private::metadata_ir::PalletEventMetadataIR {
                    ty: frame_support::__private::scale_info::meta_type::<W>(),
                    deprecation_info: frame_support::__private::metadata_ir::DeprecationInfoIR::NotDeprecated,
                }
            }
        }
        impl<T: Config> Pallet<T> {
            #[doc(hidden)]
            pub fn storage_metadata() -> frame_support::__private::metadata_ir::PalletStorageMetadataIR {
                frame_support::__private::metadata_ir::PalletStorageMetadataIR {
                    prefix: <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                        Pallet<T>,
                    >()
                        .expect(
                            "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                        ),
                    entries: {
                        #[allow(unused_mut)]
                        let mut entries = ::alloc::vec::Vec::new();
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <ValidatorCount<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The ideal number of active validators.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <MinimumValidatorCount<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " Minimum number of staking participants before emergency conditions are imposed.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <Invulnerables<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " Any validators that may never be slashed or forcibly kicked. It\'s a Vec since they\'re",
                                            " easy to initialize and the performance hit is minimal (we expect no more than four",
                                            " invulnerables) and restricted to testnets.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <Bonded<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " Map from all locked \"stash\" accounts to the controller account.",
                                            "",
                                            " TWOX-NOTE: SAFE since `AccountId` is a secure hash.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <MinNominatorBond<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The minimum active bond to become and maintain the role of a nominator.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <MinValidatorBond<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The minimum active bond to become and maintain the role of a validator.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <MinimumActiveStake<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The minimum active nominator stake of the last successful election.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <MinCommission<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The minimum amount of commission that validators can set.",
                                            "",
                                            " If set to `0`, no limit exists.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <Ledger<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " Map from all (unlocked) \"controller\" accounts to the info regarding the staking.",
                                            "",
                                            " Note: All the reads and mutations to this storage *MUST* be done through the methods exposed",
                                            " by [`StakingLedger`] to ensure data and lock consistency.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <Payee<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " Where the reward payment should be made. Keyed by stash.",
                                            "",
                                            " TWOX-NOTE: SAFE since `AccountId` is a secure hash.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <Validators<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The map from (wannabe) validator stash key to the preferences of that validator.",
                                            "",
                                            " TWOX-NOTE: SAFE since `AccountId` is a secure hash.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <MaxValidatorsCount<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The maximum validator count before we stop allowing new validators to join.",
                                            "",
                                            " When this value is not set, no limits are enforced.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <Nominators<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The map from nominator stash key to their nomination preferences, namely the validators that",
                                            " they wish to support.",
                                            "",
                                            " Note that the keys of this storage map might become non-decodable in case the",
                                            " account\'s [`NominationsQuota::MaxNominations`] configuration is decreased.",
                                            " In this rare case, these nominators",
                                            " are still existent in storage, their key is correct and retrievable (i.e. `contains_key`",
                                            " indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable",
                                            " nominators will effectively not-exist, until they re-submit their preferences such that it",
                                            " is within the bounds of the newly set `Config::MaxNominations`.",
                                            "",
                                            " This implies that `::iter_keys().count()` and `::iter().count()` might return different",
                                            " values for this map. Moreover, the main `::count()` is aligned with the former, namely the",
                                            " number of keys that exist.",
                                            "",
                                            " Lastly, if any of the nominators become non-decodable, they can be chilled immediately via",
                                            " [`Call::chill_other`] dispatchable by anyone.",
                                            "",
                                            " TWOX-NOTE: SAFE since `AccountId` is a secure hash.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <VirtualStakers<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " Stakers whose funds are managed by other pallets.",
                                            "",
                                            " This pallet does not apply any locks on them, therefore they are only virtually bonded. They",
                                            " are expected to be keyless accounts and hence should not be allowed to mutate their ledger",
                                            " directly via this pallet. Instead, these accounts are managed by other pallets and accessed",
                                            " via low level apis. We keep track of them to do minimal integrity checks.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <MaxNominatorsCount<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The maximum nominator count before we stop allowing new validators to join.",
                                            "",
                                            " When this value is not set, no limits are enforced.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <CurrentEra<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The current era index.",
                                            "",
                                            " This is the latest planned era, depending on how the Session pallet queues the validator",
                                            " set, it might be active or not.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <ActiveEra<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The active era information, it holds index and start.",
                                            "",
                                            " The active era is the era being currently rewarded. Validator set of this era must be",
                                            " equal to [`SessionInterface::validators`].",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <ErasStartSessionIndex<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The session index at which the era start for the last [`Config::HistoryDepth`] eras.",
                                            "",
                                            " Note: This tracks the starting session (i.e. session index when era start being active)",
                                            " for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <ErasStakers<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " Exposure of validator at era.",
                                            "",
                                            " This is keyed first by the era index to allow bulk deletion and then the stash account.",
                                            "",
                                            " Is it removed after [`Config::HistoryDepth`] eras.",
                                            " If stakers hasn\'t been set or has been removed then empty exposure is returned.",
                                            "",
                                            " Note: Deprecated since v14. Use `EraInfo` instead to work with exposures.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <ErasStakersOverview<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " Summary of validator exposure at a given era.",
                                            "",
                                            " This contains the total stake in support of the validator and their own stake. In addition,",
                                            " it can also be used to get the number of nominators backing this validator and the number of",
                                            " exposure pages they are divided into. The page count is useful to determine the number of",
                                            " pages of rewards that needs to be claimed.",
                                            "",
                                            " This is keyed first by the era index to allow bulk deletion and then the stash account.",
                                            " Should only be accessed through `EraInfo`.",
                                            "",
                                            " Is it removed after [`Config::HistoryDepth`] eras.",
                                            " If stakers hasn\'t been set or has been removed then empty overview is returned.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <ErasStakersClipped<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " Clipped Exposure of validator at era.",
                                            "",
                                            " Note: This is deprecated, should be used as read-only and will be removed in the future.",
                                            " New `Exposure`s are stored in a paged manner in `ErasStakersPaged` instead.",
                                            "",
                                            " This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the",
                                            " `T::MaxExposurePageSize` biggest stakers.",
                                            " (Note: the field `total` and `own` of the exposure remains unchanged).",
                                            " This is used to limit the i/o cost for the nominator payout.",
                                            "",
                                            " This is keyed fist by the era index to allow bulk deletion and then the stash account.",
                                            "",
                                            " It is removed after [`Config::HistoryDepth`] eras.",
                                            " If stakers hasn\'t been set or has been removed then empty exposure is returned.",
                                            "",
                                            " Note: Deprecated since v14. Use `EraInfo` instead to work with exposures.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <ErasStakersPaged<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " Paginated exposure of a validator at given era.",
                                            "",
                                            " This is keyed first by the era index to allow bulk deletion, then stash account and finally",
                                            " the page. Should only be accessed through `EraInfo`.",
                                            "",
                                            " This is cleared after [`Config::HistoryDepth`] eras.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <ClaimedRewards<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " History of claimed paged rewards by era and validator.",
                                            "",
                                            " This is keyed by era and validator stash which maps to the set of page indexes which have",
                                            " been claimed.",
                                            "",
                                            " It is removed after [`Config::HistoryDepth`] eras.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <ErasValidatorPrefs<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " Similar to `ErasStakers`, this holds the preferences of validators.",
                                            "",
                                            " This is keyed first by the era index to allow bulk deletion and then the stash account.",
                                            "",
                                            " Is it removed after [`Config::HistoryDepth`] eras.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <ErasValidatorReward<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The total validator era payout for the last [`Config::HistoryDepth`] eras.",
                                            "",
                                            " Eras that haven\'t finished yet or has been removed doesn\'t have reward.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <ErasRewardPoints<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " Rewards for the last [`Config::HistoryDepth`] eras.",
                                            " If reward hasn\'t been set or has been removed then 0 reward is returned.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <ErasTotalStake<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The total amount staked for the last [`Config::HistoryDepth`] eras.",
                                            " If total hasn\'t been set or has been removed then 0 stake is returned.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <ForceEra<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([" Mode of era forcing."]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <MaxStakedRewards<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " Maximum staked rewards, i.e. the percentage of the era inflation that",
                                            " is used for stake rewards.",
                                            " See [Era payout](./index.html#era-payout).",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <SlashRewardFraction<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The percentage of the slash that is distributed to reporters.",
                                            "",
                                            " The rest of the slashed value is handled by the `Slash`.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <CanceledSlashPayout<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The amount of currency given to reporters of a slash event which was",
                                            " canceled by extraordinary circumstances (e.g. governance).",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <UnappliedSlashes<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " All unapplied slashes that are queued for later.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <BondedEras<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " A mapping from still-bonded eras to the first session index of that era.",
                                            "",
                                            " Must contains information for eras for the range:",
                                            " `[active_era - bounding_duration; active_era]`",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <ValidatorSlashInEra<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " All slashing events on validators, mapped by era to the highest slash proportion",
                                            " and slash value of the era.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <NominatorSlashInEra<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " All slashing events on nominators, mapped by era to the highest slash value of the era.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <SlashingSpans<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " Slashing spans for stash accounts.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <SpanSlash<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " Records information about the maximum slash of a stash within a slashing span,",
                                            " as well as how much reward has been paid out.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <CurrentPlannedSession<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The last planned session scheduled by the session pallet.",
                                            "",
                                            " This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <DisabledValidators<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " Indices of validators that have offended in the active era. The offenders are disabled for a",
                                            " whole era. For this reason they are kept here - only staking pallet knows about eras. The",
                                            " implementor of [`DisablingStrategy`] defines if a validator should be disabled which",
                                            " implicitly means that the implementor also controls the max number of disabled validators.",
                                            "",
                                            " The vec is always kept sorted so that we can find whether a given validator has previously",
                                            " offended using binary search.",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        (|entries: &mut frame_support::__private::Vec<_>| {
                            {
                                <ChillThreshold<
                                    T,
                                > as frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(
                                    frame_support::__private::metadata_ir::DeprecationStatusIR::NotDeprecated,
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            " The threshold for when users can start calling `chill_other` for other validators /",
                                            " nominators. The threshold is compared to the actual number of validators / nominators",
                                            " (`CountFor*`) in the system compared to the configured max (`Max*Count`).",
                                        ]),
                                    ),
                                    entries,
                                );
                            }
                        })(&mut entries);
                        entries
                    },
                }
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`ValidatorCount`].
            pub fn validator_count() -> u32 {
                <ValidatorCount<T> as frame_support::storage::StorageValue<u32>>::get()
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`MinimumValidatorCount`].
            pub fn minimum_validator_count() -> u32 {
                <MinimumValidatorCount<
                    T,
                > as frame_support::storage::StorageValue<u32>>::get()
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`Invulnerables`].
            pub fn invulnerables() -> Vec<T::AccountId> {
                <Invulnerables<
                    T,
                > as frame_support::storage::StorageValue<Vec<T::AccountId>>>::get()
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`Validators`].
            pub fn validators<KArg>(k: KArg) -> ValidatorPrefs
            where
                KArg: frame_support::__private::codec::EncodeLike<T::AccountId>,
            {
                <Validators<T>>::get(k)
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`Nominators`].
            pub fn nominators<KArg>(k: KArg) -> Option<Nominations<T>>
            where
                KArg: frame_support::__private::codec::EncodeLike<T::AccountId>,
            {
                <Nominators<T>>::get(k)
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`CurrentEra`].
            pub fn current_era() -> Option<EraIndex> {
                <CurrentEra<T> as frame_support::storage::StorageValue<EraIndex>>::get()
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`ActiveEra`].
            pub fn active_era() -> Option<ActiveEraInfo> {
                <ActiveEra<
                    T,
                > as frame_support::storage::StorageValue<ActiveEraInfo>>::get()
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`ErasStartSessionIndex`].
            pub fn eras_start_session_index<KArg>(k: KArg) -> Option<SessionIndex>
            where
                KArg: frame_support::__private::codec::EncodeLike<EraIndex>,
            {
                <ErasStartSessionIndex<
                    T,
                > as frame_support::storage::StorageMap<EraIndex, SessionIndex>>::get(k)
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`ErasStakersClipped`].
            pub fn eras_stakers_clipped<KArg1, KArg2>(
                k1: KArg1,
                k2: KArg2,
            ) -> Exposure<T::AccountId, BalanceOf<T>>
            where
                KArg1: frame_support::__private::codec::EncodeLike<EraIndex>,
                KArg2: frame_support::__private::codec::EncodeLike<T::AccountId>,
            {
                <ErasStakersClipped<
                    T,
                > as frame_support::storage::StorageDoubleMap<
                    EraIndex,
                    T::AccountId,
                    Exposure<T::AccountId, BalanceOf<T>>,
                >>::get(k1, k2)
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`ClaimedRewards`].
            pub fn claimed_rewards<KArg1, KArg2>(k1: KArg1, k2: KArg2) -> Vec<Page>
            where
                KArg1: frame_support::__private::codec::EncodeLike<EraIndex>,
                KArg2: frame_support::__private::codec::EncodeLike<T::AccountId>,
            {
                <ClaimedRewards<
                    T,
                > as frame_support::storage::StorageDoubleMap<
                    EraIndex,
                    T::AccountId,
                    Vec<Page>,
                >>::get(k1, k2)
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`ErasValidatorPrefs`].
            pub fn eras_validator_prefs<KArg1, KArg2>(
                k1: KArg1,
                k2: KArg2,
            ) -> ValidatorPrefs
            where
                KArg1: frame_support::__private::codec::EncodeLike<EraIndex>,
                KArg2: frame_support::__private::codec::EncodeLike<T::AccountId>,
            {
                <ErasValidatorPrefs<
                    T,
                > as frame_support::storage::StorageDoubleMap<
                    EraIndex,
                    T::AccountId,
                    ValidatorPrefs,
                >>::get(k1, k2)
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`ErasValidatorReward`].
            pub fn eras_validator_reward<KArg>(k: KArg) -> Option<BalanceOf<T>>
            where
                KArg: frame_support::__private::codec::EncodeLike<EraIndex>,
            {
                <ErasValidatorReward<
                    T,
                > as frame_support::storage::StorageMap<EraIndex, BalanceOf<T>>>::get(k)
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`ErasRewardPoints`].
            pub fn eras_reward_points<KArg>(k: KArg) -> EraRewardPoints<T::AccountId>
            where
                KArg: frame_support::__private::codec::EncodeLike<EraIndex>,
            {
                <ErasRewardPoints<
                    T,
                > as frame_support::storage::StorageMap<
                    EraIndex,
                    EraRewardPoints<T::AccountId>,
                >>::get(k)
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`ErasTotalStake`].
            pub fn eras_total_stake<KArg>(k: KArg) -> BalanceOf<T>
            where
                KArg: frame_support::__private::codec::EncodeLike<EraIndex>,
            {
                <ErasTotalStake<
                    T,
                > as frame_support::storage::StorageMap<EraIndex, BalanceOf<T>>>::get(k)
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`ForceEra`].
            pub fn force_era() -> Forcing {
                <ForceEra<T> as frame_support::storage::StorageValue<Forcing>>::get()
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`SlashRewardFraction`].
            pub fn slash_reward_fraction() -> Perbill {
                <SlashRewardFraction<
                    T,
                > as frame_support::storage::StorageValue<Perbill>>::get()
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`CanceledSlashPayout`].
            pub fn canceled_payout() -> BalanceOf<T> {
                <CanceledSlashPayout<
                    T,
                > as frame_support::storage::StorageValue<BalanceOf<T>>>::get()
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`SlashingSpans`].
            pub fn slashing_spans<KArg>(k: KArg) -> Option<slashing::SlashingSpans>
            where
                KArg: frame_support::__private::codec::EncodeLike<T::AccountId>,
            {
                <SlashingSpans<
                    T,
                > as frame_support::storage::StorageMap<
                    T::AccountId,
                    slashing::SlashingSpans,
                >>::get(k)
            }
        }
        impl<T: Config> Pallet<T> {
            ///An auto-generated getter for [`CurrentPlannedSession`].
            pub fn current_planned_session() -> SessionIndex {
                <CurrentPlannedSession<
                    T,
                > as frame_support::storage::StorageValue<SessionIndex>>::get()
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageValidatorCount<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageValidatorCount<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "ValidatorCount";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    19u8,
                    142u8,
                    113u8,
                    97u8,
                    36u8,
                    145u8,
                    25u8,
                    45u8,
                    104u8,
                    222u8,
                    171u8,
                    126u8,
                    111u8,
                    86u8,
                    63u8,
                    225u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageMinimumValidatorCount<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageMinimumValidatorCount<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "MinimumValidatorCount";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    180u8,
                    154u8,
                    39u8,
                    56u8,
                    238u8,
                    179u8,
                    8u8,
                    150u8,
                    170u8,
                    203u8,
                    139u8,
                    63u8,
                    180u8,
                    100u8,
                    113u8,
                    189u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageInvulnerables<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageInvulnerables<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "Invulnerables";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    85u8,
                    121u8,
                    41u8,
                    127u8,
                    77u8,
                    251u8,
                    150u8,
                    9u8,
                    231u8,
                    228u8,
                    194u8,
                    235u8,
                    171u8,
                    156u8,
                    228u8,
                    10u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageBonded<T>(core::marker::PhantomData<(T,)>);
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageBonded<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "Bonded";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    62u8,
                    209u8,
                    75u8,
                    69u8,
                    237u8,
                    32u8,
                    208u8,
                    84u8,
                    240u8,
                    94u8,
                    55u8,
                    226u8,
                    84u8,
                    44u8,
                    254u8,
                    112u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageMinNominatorBond<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageMinNominatorBond<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "MinNominatorBond";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    237u8,
                    68u8,
                    28u8,
                    235u8,
                    129u8,
                    50u8,
                    108u8,
                    86u8,
                    38u8,
                    62u8,
                    251u8,
                    182u8,
                    12u8,
                    149u8,
                    194u8,
                    228u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageMinValidatorBond<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageMinValidatorBond<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "MinValidatorBond";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    102u8,
                    111u8,
                    220u8,
                    187u8,
                    71u8,
                    57u8,
                    133u8,
                    179u8,
                    172u8,
                    147u8,
                    61u8,
                    19u8,
                    244u8,
                    172u8,
                    255u8,
                    141u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageMinimumActiveStake<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageMinimumActiveStake<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "MinimumActiveStake";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    250u8,
                    184u8,
                    109u8,
                    38u8,
                    230u8,
                    41u8,
                    227u8,
                    155u8,
                    73u8,
                    3u8,
                    219u8,
                    148u8,
                    120u8,
                    111u8,
                    172u8,
                    116u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageMinCommission<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageMinCommission<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "MinCommission";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    88u8,
                    176u8,
                    201u8,
                    193u8,
                    250u8,
                    108u8,
                    193u8,
                    55u8,
                    89u8,
                    234u8,
                    217u8,
                    180u8,
                    45u8,
                    185u8,
                    238u8,
                    190u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageLedger<T>(core::marker::PhantomData<(T,)>);
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageLedger<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "Ledger";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    66u8,
                    42u8,
                    219u8,
                    87u8,
                    159u8,
                    29u8,
                    191u8,
                    79u8,
                    56u8,
                    134u8,
                    197u8,
                    207u8,
                    163u8,
                    187u8,
                    140u8,
                    196u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStoragePayee<T>(core::marker::PhantomData<(T,)>);
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStoragePayee<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "Payee";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    146u8,
                    32u8,
                    225u8,
                    114u8,
                    190u8,
                    211u8,
                    22u8,
                    96u8,
                    95u8,
                    115u8,
                    241u8,
                    255u8,
                    123u8,
                    74u8,
                    222u8,
                    152u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedCounterPrefixForStorageValidators<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedCounterPrefixForStorageValidators<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "CounterForValidators";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    109u8,
                    220u8,
                    120u8,
                    9u8,
                    198u8,
                    218u8,
                    155u8,
                    182u8,
                    9u8,
                    62u8,
                    226u8,
                    46u8,
                    15u8,
                    218u8,
                    75u8,
                    168u8,
                ]
            }
        }
        impl<T: Config> frame_support::storage::types::CountedStorageMapInstance
        for _GeneratedPrefixForStorageValidators<T> {
            type CounterPrefix = _GeneratedCounterPrefixForStorageValidators<T>;
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageValidators<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageValidators<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "Validators";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    136u8,
                    220u8,
                    222u8,
                    147u8,
                    76u8,
                    101u8,
                    130u8,
                    39u8,
                    238u8,
                    29u8,
                    250u8,
                    252u8,
                    214u8,
                    225u8,
                    105u8,
                    3u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageMaxValidatorsCount<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageMaxValidatorsCount<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "MaxValidatorsCount";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    152u8,
                    194u8,
                    100u8,
                    12u8,
                    218u8,
                    108u8,
                    13u8,
                    128u8,
                    17u8,
                    148u8,
                    168u8,
                    166u8,
                    28u8,
                    105u8,
                    146u8,
                    36u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedCounterPrefixForStorageNominators<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedCounterPrefixForStorageNominators<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "CounterForNominators";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    249u8,
                    155u8,
                    37u8,
                    133u8,
                    45u8,
                    61u8,
                    105u8,
                    65u8,
                    152u8,
                    130u8,
                    218u8,
                    101u8,
                    19u8,
                    117u8,
                    205u8,
                    179u8,
                ]
            }
        }
        impl<T: Config> frame_support::storage::types::CountedStorageMapInstance
        for _GeneratedPrefixForStorageNominators<T> {
            type CounterPrefix = _GeneratedCounterPrefixForStorageNominators<T>;
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageNominators<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageNominators<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "Nominators";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    156u8,
                    106u8,
                    99u8,
                    127u8,
                    98u8,
                    174u8,
                    42u8,
                    241u8,
                    199u8,
                    227u8,
                    30u8,
                    237u8,
                    126u8,
                    150u8,
                    190u8,
                    4u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedCounterPrefixForStorageVirtualStakers<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedCounterPrefixForStorageVirtualStakers<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "CounterForVirtualStakers";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    155u8,
                    100u8,
                    118u8,
                    183u8,
                    241u8,
                    10u8,
                    74u8,
                    207u8,
                    154u8,
                    227u8,
                    102u8,
                    25u8,
                    108u8,
                    239u8,
                    190u8,
                    31u8,
                ]
            }
        }
        impl<T: Config> frame_support::storage::types::CountedStorageMapInstance
        for _GeneratedPrefixForStorageVirtualStakers<T> {
            type CounterPrefix = _GeneratedCounterPrefixForStorageVirtualStakers<T>;
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageVirtualStakers<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageVirtualStakers<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "VirtualStakers";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    191u8,
                    54u8,
                    6u8,
                    185u8,
                    4u8,
                    169u8,
                    143u8,
                    75u8,
                    233u8,
                    220u8,
                    185u8,
                    96u8,
                    210u8,
                    108u8,
                    147u8,
                    235u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageMaxNominatorsCount<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageMaxNominatorsCount<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "MaxNominatorsCount";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    214u8,
                    66u8,
                    192u8,
                    10u8,
                    241u8,
                    25u8,
                    173u8,
                    243u8,
                    13u8,
                    193u8,
                    29u8,
                    50u8,
                    233u8,
                    240u8,
                    136u8,
                    109u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageCurrentEra<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageCurrentEra<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "CurrentEra";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    11u8,
                    106u8,
                    69u8,
                    50u8,
                    30u8,
                    250u8,
                    233u8,
                    42u8,
                    234u8,
                    21u8,
                    224u8,
                    116u8,
                    14u8,
                    199u8,
                    175u8,
                    231u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageActiveEra<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageActiveEra<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "ActiveEra";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    72u8,
                    125u8,
                    244u8,
                    100u8,
                    228u8,
                    74u8,
                    83u8,
                    75u8,
                    166u8,
                    176u8,
                    203u8,
                    179u8,
                    36u8,
                    7u8,
                    181u8,
                    135u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageErasStartSessionIndex<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageErasStartSessionIndex<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "ErasStartSessionIndex";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    173u8,
                    129u8,
                    28u8,
                    214u8,
                    90u8,
                    71u8,
                    13u8,
                    220u8,
                    95u8,
                    29u8,
                    98u8,
                    143u8,
                    240u8,
                    85u8,
                    9u8,
                    130u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageErasStakers<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageErasStakers<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "ErasStakers";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    139u8,
                    222u8,
                    10u8,
                    14u8,
                    168u8,
                    134u8,
                    70u8,
                    5u8,
                    227u8,
                    182u8,
                    142u8,
                    217u8,
                    203u8,
                    45u8,
                    160u8,
                    27u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageErasStakersOverview<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageErasStakersOverview<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "ErasStakersOverview";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    116u8,
                    147u8,
                    234u8,
                    25u8,
                    13u8,
                    10u8,
                    244u8,
                    122u8,
                    204u8,
                    112u8,
                    226u8,
                    84u8,
                    40u8,
                    248u8,
                    177u8,
                    163u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageErasStakersClipped<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageErasStakersClipped<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "ErasStakersClipped";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    66u8,
                    152u8,
                    43u8,
                    157u8,
                    108u8,
                    122u8,
                    204u8,
                    153u8,
                    250u8,
                    169u8,
                    9u8,
                    76u8,
                    145u8,
                    35u8,
                    114u8,
                    194u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageErasStakersPaged<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageErasStakersPaged<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "ErasStakersPaged";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    110u8,
                    207u8,
                    64u8,
                    55u8,
                    60u8,
                    114u8,
                    43u8,
                    3u8,
                    64u8,
                    211u8,
                    214u8,
                    92u8,
                    49u8,
                    26u8,
                    67u8,
                    5u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageClaimedRewards<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageClaimedRewards<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "ClaimedRewards";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    172u8,
                    102u8,
                    71u8,
                    2u8,
                    164u8,
                    87u8,
                    170u8,
                    161u8,
                    88u8,
                    229u8,
                    187u8,
                    69u8,
                    138u8,
                    12u8,
                    55u8,
                    108u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageErasValidatorPrefs<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageErasValidatorPrefs<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "ErasValidatorPrefs";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    104u8,
                    45u8,
                    185u8,
                    45u8,
                    222u8,
                    32u8,
                    161u8,
                    13u8,
                    150u8,
                    208u8,
                    15u8,
                    240u8,
                    233u8,
                    226u8,
                    33u8,
                    192u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageErasValidatorReward<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageErasValidatorReward<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "ErasValidatorReward";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    126u8,
                    110u8,
                    210u8,
                    238u8,
                    80u8,
                    124u8,
                    123u8,
                    68u8,
                    65u8,
                    213u8,
                    158u8,
                    77u8,
                    237u8,
                    68u8,
                    184u8,
                    162u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageErasRewardPoints<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageErasRewardPoints<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "ErasRewardPoints";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    128u8,
                    204u8,
                    101u8,
                    116u8,
                    40u8,
                    22u8,
                    113u8,
                    178u8,
                    153u8,
                    193u8,
                    114u8,
                    125u8,
                    122u8,
                    198u8,
                    140u8,
                    171u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageErasTotalStake<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageErasTotalStake<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "ErasTotalStake";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    161u8,
                    65u8,
                    196u8,
                    254u8,
                    103u8,
                    194u8,
                    209u8,
                    31u8,
                    74u8,
                    16u8,
                    198u8,
                    172u8,
                    167u8,
                    167u8,
                    154u8,
                    4u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageForceEra<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageForceEra<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "ForceEra";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    247u8,
                    218u8,
                    208u8,
                    49u8,
                    115u8,
                    36u8,
                    174u8,
                    202u8,
                    232u8,
                    116u8,
                    75u8,
                    135u8,
                    252u8,
                    149u8,
                    242u8,
                    243u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageMaxStakedRewards<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageMaxStakedRewards<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "MaxStakedRewards";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    196u8,
                    229u8,
                    144u8,
                    67u8,
                    64u8,
                    77u8,
                    254u8,
                    54u8,
                    208u8,
                    202u8,
                    211u8,
                    114u8,
                    191u8,
                    183u8,
                    134u8,
                    163u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageSlashRewardFraction<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageSlashRewardFraction<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "SlashRewardFraction";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    194u8,
                    154u8,
                    3u8,
                    16u8,
                    225u8,
                    187u8,
                    69u8,
                    210u8,
                    12u8,
                    172u8,
                    231u8,
                    124u8,
                    203u8,
                    98u8,
                    201u8,
                    125u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageCanceledSlashPayout<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageCanceledSlashPayout<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "CanceledSlashPayout";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    40u8,
                    220u8,
                    203u8,
                    85u8,
                    155u8,
                    149u8,
                    196u8,
                    1u8,
                    104u8,
                    161u8,
                    178u8,
                    105u8,
                    101u8,
                    129u8,
                    181u8,
                    167u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageUnappliedSlashes<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageUnappliedSlashes<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "UnappliedSlashes";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    4u8,
                    40u8,
                    36u8,
                    23u8,
                    10u8,
                    93u8,
                    180u8,
                    56u8,
                    31u8,
                    227u8,
                    57u8,
                    80u8,
                    57u8,
                    202u8,
                    189u8,
                    36u8,
                ]
            }
        }
        #[doc(hidden)]
        pub(crate) struct _GeneratedPrefixForStorageBondedEras<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageBondedEras<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "BondedEras";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    234u8,
                    7u8,
                    222u8,
                    43u8,
                    143u8,
                    1u8,
                    5u8,
                    22u8,
                    220u8,
                    163u8,
                    247u8,
                    239u8,
                    82u8,
                    247u8,
                    172u8,
                    90u8,
                ]
            }
        }
        #[doc(hidden)]
        pub(crate) struct _GeneratedPrefixForStorageValidatorSlashInEra<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageValidatorSlashInEra<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "ValidatorSlashInEra";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    173u8,
                    110u8,
                    21u8,
                    238u8,
                    123u8,
                    253u8,
                    93u8,
                    85u8,
                    235u8,
                    161u8,
                    1u8,
                    36u8,
                    135u8,
                    211u8,
                    175u8,
                    84u8,
                ]
            }
        }
        #[doc(hidden)]
        pub(crate) struct _GeneratedPrefixForStorageNominatorSlashInEra<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageNominatorSlashInEra<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "NominatorSlashInEra";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    129u8,
                    80u8,
                    8u8,
                    232u8,
                    33u8,
                    11u8,
                    109u8,
                    108u8,
                    247u8,
                    1u8,
                    226u8,
                    46u8,
                    91u8,
                    242u8,
                    113u8,
                    65u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageSlashingSpans<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageSlashingSpans<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "SlashingSpans";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    171u8,
                    106u8,
                    33u8,
                    43u8,
                    192u8,
                    138u8,
                    86u8,
                    3u8,
                    130u8,
                    143u8,
                    51u8,
                    249u8,
                    14u8,
                    196u8,
                    161u8,
                    57u8,
                ]
            }
        }
        #[doc(hidden)]
        pub(crate) struct _GeneratedPrefixForStorageSpanSlash<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageSpanSlash<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "SpanSlash";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    230u8,
                    47u8,
                    111u8,
                    121u8,
                    126u8,
                    190u8,
                    145u8,
                    56u8,
                    223u8,
                    206u8,
                    217u8,
                    66u8,
                    151u8,
                    127u8,
                    234u8,
                    80u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageCurrentPlannedSession<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageCurrentPlannedSession<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "CurrentPlannedSession";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    192u8,
                    211u8,
                    159u8,
                    245u8,
                    119u8,
                    175u8,
                    44u8,
                    198u8,
                    182u8,
                    122u8,
                    195u8,
                    100u8,
                    31u8,
                    169u8,
                    196u8,
                    231u8,
                ]
            }
        }
        #[doc(hidden)]
        pub struct _GeneratedPrefixForStorageDisabledValidators<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageDisabledValidators<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "DisabledValidators";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    90u8,
                    154u8,
                    116u8,
                    190u8,
                    74u8,
                    90u8,
                    125u8,
                    246u8,
                    11u8,
                    1u8,
                    166u8,
                    192u8,
                    50u8,
                    108u8,
                    94u8,
                    32u8,
                ]
            }
        }
        #[doc(hidden)]
        pub(crate) struct _GeneratedPrefixForStorageChillThreshold<T>(
            core::marker::PhantomData<(T,)>,
        );
        impl<T: Config> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageChillThreshold<T> {
            fn pallet_prefix() -> &'static str {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            fn pallet_prefix_hash() -> [u8; 16] {
                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name_hash::<
                    Pallet<T>,
                >()
                    .expect(
                        "No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.",
                    )
            }
            const STORAGE_PREFIX: &'static str = "ChillThreshold";
            fn storage_prefix_hash() -> [u8; 16] {
                [
                    205u8,
                    220u8,
                    73u8,
                    197u8,
                    243u8,
                    8u8,
                    7u8,
                    212u8,
                    116u8,
                    160u8,
                    157u8,
                    112u8,
                    254u8,
                    216u8,
                    165u8,
                    105u8,
                ]
            }
        }
        #[doc(hidden)]
        pub mod __substrate_inherent_check {
            #[doc(hidden)]
            pub use __is_inherent_part_defined_3 as is_inherent_part_defined;
        }
        /// Hidden instance generated to be internally used when module is used without
        /// instance.
        #[doc(hidden)]
        pub type __InherentHiddenInstance = ();
        impl<
            T: Config,
        > frame_support::traits::OnFinalize<
            frame_system::pallet_prelude::BlockNumberFor<T>,
        > for Pallet<T> {
            fn on_finalize(n: frame_system::pallet_prelude::BlockNumberFor<T>) {
                let __within_span__ = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "on_finalize",
                                "pallet_staking::pallet::pallet",
                                ::tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "substrate/frame/staking/src/pallet/mod.rs",
                                ),
                                ::core::option::Option::Some(63u32),
                                ::core::option::Option::Some(
                                    "pallet_staking::pallet::pallet",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if ::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        if match ::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                let __tracing_guard__ = __within_span__.enter();
                <Self as frame_support::traits::Hooks<
                    frame_system::pallet_prelude::BlockNumberFor<T>,
                >>::on_finalize(n)
            }
        }
        impl<
            T: Config,
        > frame_support::traits::OnIdle<frame_system::pallet_prelude::BlockNumberFor<T>>
        for Pallet<T> {
            fn on_idle(
                n: frame_system::pallet_prelude::BlockNumberFor<T>,
                remaining_weight: frame_support::weights::Weight,
            ) -> frame_support::weights::Weight {
                <Self as frame_support::traits::Hooks<
                    frame_system::pallet_prelude::BlockNumberFor<T>,
                >>::on_idle(n, remaining_weight)
            }
        }
        impl<
            T: Config,
        > frame_support::traits::OnPoll<frame_system::pallet_prelude::BlockNumberFor<T>>
        for Pallet<T> {
            fn on_poll(
                n: frame_system::pallet_prelude::BlockNumberFor<T>,
                weight: &mut frame_support::weights::WeightMeter,
            ) {
                <Self as frame_support::traits::Hooks<
                    frame_system::pallet_prelude::BlockNumberFor<T>,
                >>::on_poll(n, weight);
            }
        }
        impl<
            T: Config,
        > frame_support::traits::OnInitialize<
            frame_system::pallet_prelude::BlockNumberFor<T>,
        > for Pallet<T> {
            fn on_initialize(
                n: frame_system::pallet_prelude::BlockNumberFor<T>,
            ) -> frame_support::weights::Weight {
                let __within_span__ = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "on_initialize",
                                "pallet_staking::pallet::pallet",
                                ::tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "substrate/frame/staking/src/pallet/mod.rs",
                                ),
                                ::core::option::Option::Some(63u32),
                                ::core::option::Option::Some(
                                    "pallet_staking::pallet::pallet",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if ::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        if match ::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                let __tracing_guard__ = __within_span__.enter();
                <Self as frame_support::traits::Hooks<
                    frame_system::pallet_prelude::BlockNumberFor<T>,
                >>::on_initialize(n)
            }
        }
        impl<T: Config> frame_support::traits::BeforeAllRuntimeMigrations for Pallet<T> {
            fn before_all_runtime_migrations() -> frame_support::weights::Weight {
                use frame_support::traits::{Get, PalletInfoAccess};
                use frame_support::__private::hashing::twox_128;
                use frame_support::storage::unhashed::contains_prefixed_key;
                let __within_span__ = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "before_all",
                                "pallet_staking::pallet::pallet",
                                ::tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "substrate/frame/staking/src/pallet/mod.rs",
                                ),
                                ::core::option::Option::Some(63u32),
                                ::core::option::Option::Some(
                                    "pallet_staking::pallet::pallet",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if ::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        if match ::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                let __tracing_guard__ = __within_span__.enter();
                let pallet_hashed_prefix = <Self as PalletInfoAccess>::name_hash();
                let exists = contains_prefixed_key(&pallet_hashed_prefix);
                if !exists {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "🐥 New pallet {0:?} detected in the runtime. Initializing the on-chain storage version to match the storage version defined in the pallet: {1:?}",
                                    <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                                        Self,
                                    >()
                                        .unwrap_or("<unknown pallet name>"),
                                    STORAGE_VERSION,
                                ),
                                lvl,
                                &(
                                    frame_support::LOG_TARGET,
                                    "pallet_staking::pallet::pallet",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    };
                    STORAGE_VERSION.put::<Self>();
                    <T as frame_system::Config>::DbWeight::get().reads_writes(1, 1)
                } else {
                    <T as frame_system::Config>::DbWeight::get().reads(1)
                }
            }
        }
        impl<T: Config> frame_support::traits::OnRuntimeUpgrade for Pallet<T> {
            fn on_runtime_upgrade() -> frame_support::weights::Weight {
                let __within_span__ = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "on_runtime_update",
                                "pallet_staking::pallet::pallet",
                                ::tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "substrate/frame/staking/src/pallet/mod.rs",
                                ),
                                ::core::option::Option::Some(63u32),
                                ::core::option::Option::Some(
                                    "pallet_staking::pallet::pallet",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if ::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        if match ::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{ __CALLSITE.metadata().fields().value_set(&[]) },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                let __tracing_guard__ = __within_span__.enter();
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "✅ no migration for {0}",
                                <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                                    Self,
                                >()
                                    .unwrap_or("<unknown pallet name>"),
                            ),
                            lvl,
                            &(
                                frame_support::LOG_TARGET,
                                "pallet_staking::pallet::pallet",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                };
                <Self as frame_support::traits::Hooks<
                    frame_system::pallet_prelude::BlockNumberFor<T>,
                >>::on_runtime_upgrade()
            }
        }
        impl<
            T: Config,
        > frame_support::traits::OffchainWorker<
            frame_system::pallet_prelude::BlockNumberFor<T>,
        > for Pallet<T> {
            fn offchain_worker(n: frame_system::pallet_prelude::BlockNumberFor<T>) {
                <Self as frame_support::traits::Hooks<
                    frame_system::pallet_prelude::BlockNumberFor<T>,
                >>::offchain_worker(n)
            }
        }
        impl<T: Config> frame_support::traits::IntegrityTest for Pallet<T> {
            fn integrity_test() {
                frame_support::__private::sp_io::TestExternalities::default()
                    .execute_with(|| {
                        <Self as frame_support::traits::Hooks<
                            frame_system::pallet_prelude::BlockNumberFor<T>,
                        >>::integrity_test()
                    });
            }
        }
        impl<T: Config> frame_support::sp_runtime::BuildStorage for GenesisConfig<T> {
            fn assimilate_storage(
                &self,
                storage: &mut frame_support::sp_runtime::Storage,
            ) -> std::result::Result<(), std::string::String> {
                frame_support::__private::BasicExternalities::execute_with_storage(
                    storage,
                    || {
                        self.build();
                        Ok(())
                    },
                )
            }
        }
        #[doc(hidden)]
        pub mod __substrate_genesis_config_check {
            #[doc(hidden)]
            pub use __is_genesis_config_defined_4 as is_genesis_config_defined;
            #[doc(hidden)]
            pub use __is_std_macro_defined_for_genesis_4 as is_std_enabled_for_genesis;
        }
        #[doc(hidden)]
        pub mod __substrate_origin_check {
            #[doc(hidden)]
            pub use __is_origin_part_defined_5 as is_origin_part_defined;
        }
        #[doc(hidden)]
        pub mod __substrate_validate_unsigned_check {
            #[doc(hidden)]
            pub use __is_validate_unsigned_part_defined_6 as is_validate_unsigned_part_defined;
        }
        pub use __tt_default_parts_7 as tt_default_parts;
        pub use __tt_extra_parts_7 as tt_extra_parts;
        pub use __tt_default_parts_v2_7 as tt_default_parts_v2;
    }
    /// Check that list is sorted and has no duplicates.
    fn is_sorted_and_unique(list: &[u32]) -> bool {
        list.windows(2).all(|w| w[0] < w[1])
    }
}
extern crate alloc;
use alloc::{collections::btree_map::BTreeMap, vec, vec::Vec};
use codec::{Decode, Encode, HasCompact, MaxEncodedLen};
use frame_support::{
    defensive, defensive_assert,
    traits::{
        ConstU32, Currency, Defensive, DefensiveMax, DefensiveSaturating, Get,
        LockIdentifier,
    },
    weights::Weight, BoundedVec, CloneNoBound, EqNoBound, PartialEqNoBound,
    RuntimeDebugNoBound,
};
use scale_info::TypeInfo;
use sp_runtime::{
    curve::PiecewiseLinear, traits::{AtLeast32BitUnsigned, Convert, StaticLookup, Zero},
    Perbill, Perquintill, Rounding, RuntimeDebug, Saturating,
};
use sp_staking::{
    offence::{Offence, OffenceError, ReportOffence},
    EraIndex, ExposurePage, OnStakingUpdate, Page, PagedExposureMetadata, SessionIndex,
    StakingAccount,
};
pub use sp_staking::{Exposure, IndividualExposure, StakerStatus};
pub use weights::WeightInfo;
pub use pallet::{pallet::*, UseNominatorsAndValidatorsMap, UseValidatorsMap};
pub(crate) const STAKING_ID: LockIdentifier = *b"staking ";
pub(crate) const LOG_TARGET: &str = "runtime::staking";
/// Maximum number of winners (aka. active validators), as defined in the election provider of this
/// pallet.
pub type MaxWinnersOf<T> = <<T as Config>::ElectionProvider as frame_election_provider_support::ElectionProviderBase>::MaxWinners;
/// Maximum number of nominations per nominator.
pub type MaxNominationsOf<T> = <<T as Config>::NominationsQuota as NominationsQuota<
    BalanceOf<T>,
>>::MaxNominations;
/// Counter for the number of "reward" points earned by a given validator.
pub type RewardPoint = u32;
/// The balance type of this pallet.
pub type BalanceOf<T> = <T as Config>::CurrencyBalance;
type PositiveImbalanceOf<T> = <<T as Config>::Currency as Currency<
    <T as frame_system::Config>::AccountId,
>>::PositiveImbalance;
pub type NegativeImbalanceOf<T> = <<T as Config>::Currency as Currency<
    <T as frame_system::Config>::AccountId,
>>::NegativeImbalance;
type AccountIdLookupOf<T> = <<T as frame_system::Config>::Lookup as StaticLookup>::Source;
/// Information regarding the active era (era in used in session).
pub struct ActiveEraInfo {
    /// Index of era.
    pub index: EraIndex,
    /// Moment of start expressed as millisecond from `$UNIX_EPOCH`.
    ///
    /// Start can be none if start hasn't been set for the era yet,
    /// Start is set on the first on_finalize of the era to guarantee usage of `Time`.
    pub start: Option<u64>,
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Encode for ActiveEraInfo {
        fn size_hint(&self) -> usize {
            0_usize
                .saturating_add(::codec::Encode::size_hint(&self.index))
                .saturating_add(::codec::Encode::size_hint(&self.start))
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            ::codec::Encode::encode_to(&self.index, __codec_dest_edqy);
            ::codec::Encode::encode_to(&self.start, __codec_dest_edqy);
        }
    }
    #[automatically_derived]
    impl ::codec::EncodeLike for ActiveEraInfo {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Decode for ActiveEraInfo {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            ::core::result::Result::Ok(ActiveEraInfo {
                index: {
                    let __codec_res_edqy = <EraIndex as ::codec::Decode>::decode(
                        __codec_input_edqy,
                    );
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `ActiveEraInfo::index`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
                start: {
                    let __codec_res_edqy = <Option<
                        u64,
                    > as ::codec::Decode>::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `ActiveEraInfo::start`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
            })
        }
    }
};
impl core::fmt::Debug for ActiveEraInfo {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        fmt.debug_struct("ActiveEraInfo")
            .field("index", &self.index)
            .field("start", &self.start)
            .finish()
    }
}
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl ::scale_info::TypeInfo for ActiveEraInfo {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new_with_replace(
                        "ActiveEraInfo",
                        "pallet_staking",
                        &[],
                    ),
                )
                .type_params(::alloc::vec::Vec::new())
                .docs(
                    &["Information regarding the active era (era in used in session)."],
                )
                .composite(
                    ::scale_info::build::Fields::named()
                        .field(|f| {
                            f
                                .ty::<EraIndex>()
                                .name("index")
                                .type_name("EraIndex")
                                .docs(&["Index of era."])
                        })
                        .field(|f| {
                            f
                                .ty::<Option<u64>>()
                                .name("start")
                                .type_name("Option<u64>")
                                .docs(
                                    &[
                                        "Moment of start expressed as millisecond from `$UNIX_EPOCH`.",
                                        "",
                                        "Start can be none if start hasn't been set for the era yet,",
                                        "Start is set on the first on_finalize of the era to guarantee usage of `Time`.",
                                    ],
                                )
                        }),
                )
        }
    }
};
const _: () = {
    impl ::codec::MaxEncodedLen for ActiveEraInfo {
        fn max_encoded_len() -> ::core::primitive::usize {
            0_usize
                .saturating_add(<EraIndex>::max_encoded_len())
                .saturating_add(<Option<u64>>::max_encoded_len())
        }
    }
};
/// Reward points of an era. Used to split era total payout between validators.
///
/// This points will be used to reward validators and their respective nominators.
pub struct EraRewardPoints<AccountId: Ord> {
    /// Total number of points. Equals the sum of reward points for each validator.
    pub total: RewardPoint,
    /// The reward points earned by a given validator.
    pub individual: BTreeMap<AccountId, RewardPoint>,
}
#[automatically_derived]
impl<AccountId: Ord> ::core::marker::StructuralPartialEq for EraRewardPoints<AccountId> {}
#[automatically_derived]
impl<AccountId: ::core::cmp::PartialEq + Ord> ::core::cmp::PartialEq
for EraRewardPoints<AccountId> {
    #[inline]
    fn eq(&self, other: &EraRewardPoints<AccountId>) -> bool {
        self.total == other.total && self.individual == other.individual
    }
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<AccountId: Ord> ::codec::Encode for EraRewardPoints<AccountId>
    where
        BTreeMap<AccountId, RewardPoint>: ::codec::Encode,
        BTreeMap<AccountId, RewardPoint>: ::codec::Encode,
    {
        fn size_hint(&self) -> usize {
            0_usize
                .saturating_add(::codec::Encode::size_hint(&self.total))
                .saturating_add(::codec::Encode::size_hint(&self.individual))
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            ::codec::Encode::encode_to(&self.total, __codec_dest_edqy);
            ::codec::Encode::encode_to(&self.individual, __codec_dest_edqy);
        }
    }
    #[automatically_derived]
    impl<AccountId: Ord> ::codec::EncodeLike for EraRewardPoints<AccountId>
    where
        BTreeMap<AccountId, RewardPoint>: ::codec::Encode,
        BTreeMap<AccountId, RewardPoint>: ::codec::Encode,
    {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<AccountId: Ord> ::codec::Decode for EraRewardPoints<AccountId>
    where
        BTreeMap<AccountId, RewardPoint>: ::codec::Decode,
        BTreeMap<AccountId, RewardPoint>: ::codec::Decode,
    {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            ::core::result::Result::Ok(EraRewardPoints::<AccountId> {
                total: {
                    let __codec_res_edqy = <RewardPoint as ::codec::Decode>::decode(
                        __codec_input_edqy,
                    );
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `EraRewardPoints::total`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
                individual: {
                    let __codec_res_edqy = <BTreeMap<
                        AccountId,
                        RewardPoint,
                    > as ::codec::Decode>::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `EraRewardPoints::individual`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
            })
        }
    }
};
impl<AccountId: Ord> core::fmt::Debug for EraRewardPoints<AccountId>
where
    AccountId: core::fmt::Debug,
{
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        fmt.debug_struct("EraRewardPoints")
            .field("total", &self.total)
            .field("individual", &self.individual)
            .finish()
    }
}
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl<AccountId: Ord> ::scale_info::TypeInfo for EraRewardPoints<AccountId>
    where
        BTreeMap<AccountId, RewardPoint>: ::scale_info::TypeInfo + 'static,
        AccountId: Ord + ::scale_info::TypeInfo + 'static,
    {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new_with_replace(
                        "EraRewardPoints",
                        "pallet_staking",
                        &[],
                    ),
                )
                .type_params(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::scale_info::TypeParameter::new(
                                "AccountId",
                                ::core::option::Option::Some(
                                    ::scale_info::meta_type::<AccountId>(),
                                ),
                            ),
                        ]),
                    ),
                )
                .docs(
                    &[
                        "Reward points of an era. Used to split era total payout between validators.",
                        "",
                        "This points will be used to reward validators and their respective nominators.",
                    ],
                )
                .composite(
                    ::scale_info::build::Fields::named()
                        .field(|f| {
                            f
                                .ty::<RewardPoint>()
                                .name("total")
                                .type_name("RewardPoint")
                                .docs(
                                    &[
                                        "Total number of points. Equals the sum of reward points for each validator.",
                                    ],
                                )
                        })
                        .field(|f| {
                            f
                                .ty::<BTreeMap<AccountId, RewardPoint>>()
                                .name("individual")
                                .type_name("BTreeMap<AccountId, RewardPoint>")
                                .docs(&["The reward points earned by a given validator."])
                        }),
                )
        }
    }
};
impl<AccountId: Ord> Default for EraRewardPoints<AccountId> {
    fn default() -> Self {
        EraRewardPoints {
            total: Default::default(),
            individual: BTreeMap::new(),
        }
    }
}
/// A destination account for payment.
pub enum RewardDestination<AccountId> {
    /// Pay into the stash account, increasing the amount at stake accordingly.
    Staked,
    /// Pay into the stash account, not increasing the amount at stake.
    Stash,
    #[deprecated(
        note = "`Controller` will be removed after January 2024. Use `Account(controller)` instead."
    )]
    Controller,
    /// Pay into a specified account.
    Account(AccountId),
    /// Receive no reward.
    None,
}
#[automatically_derived]
impl<AccountId> ::core::marker::StructuralPartialEq for RewardDestination<AccountId> {}
#[automatically_derived]
impl<AccountId: ::core::cmp::PartialEq> ::core::cmp::PartialEq
for RewardDestination<AccountId> {
    #[inline]
    fn eq(&self, other: &RewardDestination<AccountId>) -> bool {
        let __self_discr = ::core::intrinsics::discriminant_value(self);
        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
        __self_discr == __arg1_discr
            && match (self, other) {
                (
                    RewardDestination::Account(__self_0),
                    RewardDestination::Account(__arg1_0),
                ) => __self_0 == __arg1_0,
                _ => true,
            }
    }
}
#[automatically_derived]
impl<AccountId: ::core::cmp::Eq> ::core::cmp::Eq for RewardDestination<AccountId> {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<AccountId>;
    }
}
#[automatically_derived]
impl<AccountId: ::core::marker::Copy> ::core::marker::Copy
for RewardDestination<AccountId> {}
#[automatically_derived]
impl<AccountId: ::core::clone::Clone> ::core::clone::Clone
for RewardDestination<AccountId> {
    #[inline]
    fn clone(&self) -> RewardDestination<AccountId> {
        match self {
            RewardDestination::Staked => RewardDestination::Staked,
            RewardDestination::Stash => RewardDestination::Stash,
            RewardDestination::Controller => RewardDestination::Controller,
            RewardDestination::Account(__self_0) => {
                RewardDestination::Account(::core::clone::Clone::clone(__self_0))
            }
            RewardDestination::None => RewardDestination::None,
        }
    }
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<AccountId> ::codec::Encode for RewardDestination<AccountId>
    where
        AccountId: ::codec::Encode,
        AccountId: ::codec::Encode,
    {
        fn size_hint(&self) -> usize {
            1_usize
                + match *self {
                    RewardDestination::Staked => 0_usize,
                    RewardDestination::Stash => 0_usize,
                    RewardDestination::Controller => 0_usize,
                    RewardDestination::Account(ref aa) => {
                        0_usize.saturating_add(::codec::Encode::size_hint(aa))
                    }
                    RewardDestination::None => 0_usize,
                    _ => 0_usize,
                }
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            match *self {
                RewardDestination::Staked => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                }
                RewardDestination::Stash => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                }
                RewardDestination::Controller => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(2usize as ::core::primitive::u8);
                }
                RewardDestination::Account(ref aa) => {
                    __codec_dest_edqy.push_byte(3usize as ::core::primitive::u8);
                    ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                }
                RewardDestination::None => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(4usize as ::core::primitive::u8);
                }
                _ => {}
            }
        }
    }
    #[automatically_derived]
    impl<AccountId> ::codec::EncodeLike for RewardDestination<AccountId>
    where
        AccountId: ::codec::Encode,
        AccountId: ::codec::Encode,
    {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<AccountId> ::codec::Decode for RewardDestination<AccountId>
    where
        AccountId: ::codec::Decode,
        AccountId: ::codec::Decode,
    {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            match __codec_input_edqy
                .read_byte()
                .map_err(|e| {
                    e
                        .chain(
                            "Could not decode `RewardDestination`, failed to read variant byte",
                        )
                })?
            {
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 0usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RewardDestination::<AccountId>::Staked,
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 1usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(RewardDestination::<AccountId>::Stash)
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 2usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RewardDestination::<AccountId>::Controller,
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 3usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(
                            RewardDestination::<
                                AccountId,
                            >::Account({
                                let __codec_res_edqy = <AccountId as ::codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                                match __codec_res_edqy {
                                    ::core::result::Result::Err(e) => {
                                        return ::core::result::Result::Err(
                                            e.chain("Could not decode `RewardDestination::Account.0`"),
                                        );
                                    }
                                    ::core::result::Result::Ok(__codec_res_edqy) => {
                                        __codec_res_edqy
                                    }
                                }
                            }),
                        )
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 4usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(RewardDestination::<AccountId>::None)
                    })();
                }
                _ => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Err(
                            <_ as ::core::convert::Into<
                                _,
                            >>::into(
                                "Could not decode `RewardDestination`, variant doesn't exist",
                            ),
                        )
                    })();
                }
            }
        }
    }
};
impl<AccountId> core::fmt::Debug for RewardDestination<AccountId>
where
    AccountId: core::fmt::Debug,
{
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            Self::Staked => fmt.debug_tuple("RewardDestination::Staked").finish(),
            Self::Stash => fmt.debug_tuple("RewardDestination::Stash").finish(),
            Self::Controller => fmt.debug_tuple("RewardDestination::Controller").finish(),
            Self::Account(ref a0) => {
                fmt.debug_tuple("RewardDestination::Account").field(a0).finish()
            }
            Self::None => fmt.debug_tuple("RewardDestination::None").finish(),
            _ => Ok(()),
        }
    }
}
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl<AccountId> ::scale_info::TypeInfo for RewardDestination<AccountId>
    where
        AccountId: ::scale_info::TypeInfo + 'static,
        AccountId: ::scale_info::TypeInfo + 'static,
    {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new_with_replace(
                        "RewardDestination",
                        "pallet_staking",
                        &[],
                    ),
                )
                .type_params(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::scale_info::TypeParameter::new(
                                "AccountId",
                                ::core::option::Option::Some(
                                    ::scale_info::meta_type::<AccountId>(),
                                ),
                            ),
                        ]),
                    ),
                )
                .docs(&["A destination account for payment."])
                .variant(
                    ::scale_info::build::Variants::new()
                        .variant(
                            "Staked",
                            |v| {
                                v
                                    .index(0usize as ::core::primitive::u8)
                                    .docs(
                                        &[
                                            "Pay into the stash account, increasing the amount at stake accordingly.",
                                        ],
                                    )
                            },
                        )
                        .variant(
                            "Stash",
                            |v| {
                                v
                                    .index(1usize as ::core::primitive::u8)
                                    .docs(
                                        &[
                                            "Pay into the stash account, not increasing the amount at stake.",
                                        ],
                                    )
                            },
                        )
                        .variant(
                            "Controller",
                            |v| v.index(2usize as ::core::primitive::u8),
                        )
                        .variant(
                            "Account",
                            |v| {
                                v
                                    .index(3usize as ::core::primitive::u8)
                                    .fields(
                                        ::scale_info::build::Fields::unnamed()
                                            .field(|f| f.ty::<AccountId>().type_name("AccountId")),
                                    )
                                    .docs(&["Pay into a specified account."])
                            },
                        )
                        .variant(
                            "None",
                            |v| {
                                v
                                    .index(4usize as ::core::primitive::u8)
                                    .docs(&["Receive no reward."])
                            },
                        ),
                )
        }
    }
};
const _: () = {
    impl<AccountId> ::codec::MaxEncodedLen for RewardDestination<AccountId>
    where
        AccountId: ::codec::MaxEncodedLen,
        AccountId: ::codec::MaxEncodedLen,
    {
        fn max_encoded_len() -> ::core::primitive::usize {
            0_usize
                .max(0_usize)
                .max(0_usize)
                .max(0_usize)
                .max(0_usize.saturating_add(<AccountId>::max_encoded_len()))
                .max(0_usize)
                .saturating_add(1)
        }
    }
};
/// Preference of what happens regarding validation.
pub struct ValidatorPrefs {
    /// Reward that validator takes up-front; only the rest is split between themselves and
    /// nominators.
    #[codec(compact)]
    pub commission: Perbill,
    /// Whether or not this validator is accepting more nominations. If `true`, then no nominator
    /// who is not already nominating this validator may nominate them. By default, validators
    /// are accepting nominations.
    pub blocked: bool,
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for ValidatorPrefs {}
#[automatically_derived]
impl ::core::cmp::PartialEq for ValidatorPrefs {
    #[inline]
    fn eq(&self, other: &ValidatorPrefs) -> bool {
        self.commission == other.commission && self.blocked == other.blocked
    }
}
#[automatically_derived]
impl ::core::cmp::Eq for ValidatorPrefs {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Perbill>;
        let _: ::core::cmp::AssertParamIsEq<bool>;
    }
}
#[automatically_derived]
impl ::core::clone::Clone for ValidatorPrefs {
    #[inline]
    fn clone(&self) -> ValidatorPrefs {
        ValidatorPrefs {
            commission: ::core::clone::Clone::clone(&self.commission),
            blocked: ::core::clone::Clone::clone(&self.blocked),
        }
    }
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Encode for ValidatorPrefs {
        fn size_hint(&self) -> usize {
            0_usize
                .saturating_add(
                    ::codec::Encode::size_hint(
                        &<<Perbill as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                            '_,
                            Perbill,
                        >>::RefType::from(&self.commission),
                    ),
                )
                .saturating_add(::codec::Encode::size_hint(&self.blocked))
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            {
                ::codec::Encode::encode_to(
                    &<<Perbill as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                        '_,
                        Perbill,
                    >>::RefType::from(&self.commission),
                    __codec_dest_edqy,
                );
            }
            ::codec::Encode::encode_to(&self.blocked, __codec_dest_edqy);
        }
    }
    #[automatically_derived]
    impl ::codec::EncodeLike for ValidatorPrefs {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Decode for ValidatorPrefs {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            ::core::result::Result::Ok(ValidatorPrefs {
                commission: {
                    let __codec_res_edqy = <<Perbill as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                        __codec_input_edqy,
                    );
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `ValidatorPrefs::commission`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => {
                            __codec_res_edqy.into()
                        }
                    }
                },
                blocked: {
                    let __codec_res_edqy = <bool as ::codec::Decode>::decode(
                        __codec_input_edqy,
                    );
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `ValidatorPrefs::blocked`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
            })
        }
    }
};
impl core::fmt::Debug for ValidatorPrefs {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        fmt.debug_struct("ValidatorPrefs")
            .field("commission", &self.commission)
            .field("blocked", &self.blocked)
            .finish()
    }
}
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl ::scale_info::TypeInfo for ValidatorPrefs {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new_with_replace(
                        "ValidatorPrefs",
                        "pallet_staking",
                        &[],
                    ),
                )
                .type_params(::alloc::vec::Vec::new())
                .docs(&["Preference of what happens regarding validation."])
                .composite(
                    ::scale_info::build::Fields::named()
                        .field(|f| {
                            f
                                .compact::<Perbill>()
                                .name("commission")
                                .type_name("Perbill")
                                .docs(
                                    &[
                                        "Reward that validator takes up-front; only the rest is split between themselves and",
                                        "nominators.",
                                    ],
                                )
                        })
                        .field(|f| {
                            f
                                .ty::<bool>()
                                .name("blocked")
                                .type_name("bool")
                                .docs(
                                    &[
                                        "Whether or not this validator is accepting more nominations. If `true`, then no nominator",
                                        "who is not already nominating this validator may nominate them. By default, validators",
                                        "are accepting nominations.",
                                    ],
                                )
                        }),
                )
        }
    }
};
#[automatically_derived]
impl ::core::default::Default for ValidatorPrefs {
    #[inline]
    fn default() -> ValidatorPrefs {
        ValidatorPrefs {
            commission: ::core::default::Default::default(),
            blocked: ::core::default::Default::default(),
        }
    }
}
const _: () = {
    impl ::codec::MaxEncodedLen for ValidatorPrefs {
        fn max_encoded_len() -> ::core::primitive::usize {
            0_usize
                .saturating_add(<Perbill>::max_encoded_len())
                .saturating_add(<bool>::max_encoded_len())
        }
    }
};
/// Just a Balance/BlockNumber tuple to encode when a chunk of funds will be unlocked.
pub struct UnlockChunk<Balance: HasCompact + MaxEncodedLen> {
    /// Amount of funds to be unlocked.
    #[codec(compact)]
    value: Balance,
    /// Era number at which point it'll be unlocked.
    #[codec(compact)]
    era: EraIndex,
}
#[automatically_derived]
impl<Balance: HasCompact + MaxEncodedLen> ::core::marker::StructuralPartialEq
for UnlockChunk<Balance> {}
#[automatically_derived]
impl<Balance: ::core::cmp::PartialEq + HasCompact + MaxEncodedLen> ::core::cmp::PartialEq
for UnlockChunk<Balance> {
    #[inline]
    fn eq(&self, other: &UnlockChunk<Balance>) -> bool {
        self.value == other.value && self.era == other.era
    }
}
#[automatically_derived]
impl<Balance: ::core::cmp::Eq + HasCompact + MaxEncodedLen> ::core::cmp::Eq
for UnlockChunk<Balance> {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Balance>;
        let _: ::core::cmp::AssertParamIsEq<EraIndex>;
    }
}
#[automatically_derived]
impl<Balance: ::core::clone::Clone + HasCompact + MaxEncodedLen> ::core::clone::Clone
for UnlockChunk<Balance> {
    #[inline]
    fn clone(&self) -> UnlockChunk<Balance> {
        UnlockChunk {
            value: ::core::clone::Clone::clone(&self.value),
            era: ::core::clone::Clone::clone(&self.era),
        }
    }
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<Balance: HasCompact + MaxEncodedLen> ::codec::Encode for UnlockChunk<Balance>
    where
        Balance: ::codec::HasCompact,
    {
        fn size_hint(&self) -> usize {
            0_usize
                .saturating_add(
                    ::codec::Encode::size_hint(
                        &<<Balance as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                            '_,
                            Balance,
                        >>::RefType::from(&self.value),
                    ),
                )
                .saturating_add(
                    ::codec::Encode::size_hint(
                        &<<EraIndex as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                            '_,
                            EraIndex,
                        >>::RefType::from(&self.era),
                    ),
                )
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            {
                ::codec::Encode::encode_to(
                    &<<Balance as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                        '_,
                        Balance,
                    >>::RefType::from(&self.value),
                    __codec_dest_edqy,
                );
            }
            {
                ::codec::Encode::encode_to(
                    &<<EraIndex as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                        '_,
                        EraIndex,
                    >>::RefType::from(&self.era),
                    __codec_dest_edqy,
                );
            }
        }
    }
    #[automatically_derived]
    impl<Balance: HasCompact + MaxEncodedLen> ::codec::EncodeLike
    for UnlockChunk<Balance>
    where
        Balance: ::codec::HasCompact,
    {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<Balance: HasCompact + MaxEncodedLen> ::codec::Decode for UnlockChunk<Balance>
    where
        Balance: ::codec::HasCompact,
    {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            ::core::result::Result::Ok(UnlockChunk::<Balance> {
                value: {
                    let __codec_res_edqy = <<Balance as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                        __codec_input_edqy,
                    );
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `UnlockChunk::value`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => {
                            __codec_res_edqy.into()
                        }
                    }
                },
                era: {
                    let __codec_res_edqy = <<EraIndex as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                        __codec_input_edqy,
                    );
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `UnlockChunk::era`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => {
                            __codec_res_edqy.into()
                        }
                    }
                },
            })
        }
    }
};
impl<Balance: HasCompact + MaxEncodedLen> core::fmt::Debug for UnlockChunk<Balance>
where
    Balance: core::fmt::Debug,
{
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        fmt.debug_struct("UnlockChunk")
            .field("value", &self.value)
            .field("era", &self.era)
            .finish()
    }
}
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl<Balance: HasCompact + MaxEncodedLen> ::scale_info::TypeInfo
    for UnlockChunk<Balance>
    where
        Balance: ::scale_info::scale::HasCompact,
        Balance: HasCompact + MaxEncodedLen + ::scale_info::TypeInfo + 'static,
    {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new_with_replace(
                        "UnlockChunk",
                        "pallet_staking",
                        &[],
                    ),
                )
                .type_params(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::scale_info::TypeParameter::new(
                                "Balance",
                                ::core::option::Option::Some(
                                    ::scale_info::meta_type::<Balance>(),
                                ),
                            ),
                        ]),
                    ),
                )
                .docs(
                    &[
                        "Just a Balance/BlockNumber tuple to encode when a chunk of funds will be unlocked.",
                    ],
                )
                .composite(
                    ::scale_info::build::Fields::named()
                        .field(|f| {
                            f
                                .compact::<Balance>()
                                .name("value")
                                .type_name("Balance")
                                .docs(&["Amount of funds to be unlocked."])
                        })
                        .field(|f| {
                            f
                                .compact::<EraIndex>()
                                .name("era")
                                .type_name("EraIndex")
                                .docs(&["Era number at which point it'll be unlocked."])
                        }),
                )
        }
    }
};
const _: () = {
    impl<Balance: HasCompact + MaxEncodedLen> ::codec::MaxEncodedLen
    for UnlockChunk<Balance>
    where
        Balance: ::codec::HasCompact,
    {
        fn max_encoded_len() -> ::core::primitive::usize {
            0_usize
                .saturating_add(<Balance>::max_encoded_len())
                .saturating_add(<EraIndex>::max_encoded_len())
        }
    }
};
/// The ledger of a (bonded) stash.
///
/// Note: All the reads and mutations to the [`Ledger`], [`Bonded`] and [`Payee`] storage items
/// *MUST* be performed through the methods exposed by this struct, to ensure the consistency of
/// ledger's data and corresponding staking lock
///
/// TODO: move struct definition and full implementation into `/src/ledger.rs`. Currently
/// leaving here to enforce a clean PR diff, given how critical this logic is. Tracking issue
/// <https://github.com/paritytech/substrate/issues/14749>.
#[scale_info(skip_type_params(T))]
pub struct StakingLedger<T: Config> {
    /// The stash account whose balance is actually locked and at stake.
    pub stash: T::AccountId,
    /// The total amount of the stash's balance that we are currently accounting for.
    /// It's just `active` plus all the `unlocking` balances.
    #[codec(compact)]
    pub total: BalanceOf<T>,
    /// The total amount of the stash's balance that will be at stake in any forthcoming
    /// rounds.
    #[codec(compact)]
    pub active: BalanceOf<T>,
    /// Any balance that is becoming free, which may eventually be transferred out of the stash
    /// (assuming it doesn't get slashed first). It is assumed that this will be treated as a first
    /// in, first out queue where the new (higher value) eras get pushed on the back.
    pub unlocking: BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>,
    /// List of eras for which the stakers behind a validator have claimed rewards. Only updated
    /// for validators.
    ///
    /// This is deprecated as of V14 in favor of `T::ClaimedRewards` and will be removed in future.
    /// Refer to issue <https://github.com/paritytech/polkadot-sdk/issues/433>
    pub legacy_claimed_rewards: BoundedVec<EraIndex, T::HistoryDepth>,
    /// The controller associated with this ledger's stash.
    ///
    /// This is not stored on-chain, and is only bundled when the ledger is read from storage.
    /// Use [`controller`] function to get the controller associated with the ledger.
    #[codec(skip)]
    controller: Option<T::AccountId>,
}
const _: () = {
    #[automatically_derived]
    impl<T: Config> ::core::cmp::PartialEq for StakingLedger<T> {
        fn eq(&self, other: &Self) -> bool {
            true && self.stash == other.stash && self.total == other.total
                && self.active == other.active && self.unlocking == other.unlocking
                && self.legacy_claimed_rewards == other.legacy_claimed_rewards
                && self.controller == other.controller
        }
    }
};
const _: () = {
    impl<T: Config> ::core::cmp::Eq for StakingLedger<T> {}
};
const _: () = {
    #[automatically_derived]
    impl<T: Config> ::core::clone::Clone for StakingLedger<T> {
        fn clone(&self) -> Self {
            Self {
                stash: ::core::clone::Clone::clone(&self.stash),
                total: ::core::clone::Clone::clone(&self.total),
                active: ::core::clone::Clone::clone(&self.active),
                unlocking: ::core::clone::Clone::clone(&self.unlocking),
                legacy_claimed_rewards: ::core::clone::Clone::clone(
                    &self.legacy_claimed_rewards,
                ),
                controller: ::core::clone::Clone::clone(&self.controller),
            }
        }
    }
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<T: Config> ::codec::Encode for StakingLedger<T>
    where
        T::AccountId: ::codec::Encode,
        T::AccountId: ::codec::Encode,
        BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>: ::codec::Encode,
        BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>: ::codec::Encode,
        BoundedVec<EraIndex, T::HistoryDepth>: ::codec::Encode,
        BoundedVec<EraIndex, T::HistoryDepth>: ::codec::Encode,
        BalanceOf<T>: ::codec::HasCompact,
        BalanceOf<T>: ::codec::HasCompact,
    {
        fn size_hint(&self) -> usize {
            0_usize
                .saturating_add(::codec::Encode::size_hint(&self.stash))
                .saturating_add(
                    ::codec::Encode::size_hint(
                        &<<BalanceOf<
                            T,
                        > as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                            '_,
                            BalanceOf<T>,
                        >>::RefType::from(&self.total),
                    ),
                )
                .saturating_add(
                    ::codec::Encode::size_hint(
                        &<<BalanceOf<
                            T,
                        > as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                            '_,
                            BalanceOf<T>,
                        >>::RefType::from(&self.active),
                    ),
                )
                .saturating_add(::codec::Encode::size_hint(&self.unlocking))
                .saturating_add(::codec::Encode::size_hint(&self.legacy_claimed_rewards))
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            ::codec::Encode::encode_to(&self.stash, __codec_dest_edqy);
            {
                ::codec::Encode::encode_to(
                    &<<BalanceOf<
                        T,
                    > as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                        '_,
                        BalanceOf<T>,
                    >>::RefType::from(&self.total),
                    __codec_dest_edqy,
                );
            }
            {
                ::codec::Encode::encode_to(
                    &<<BalanceOf<
                        T,
                    > as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                        '_,
                        BalanceOf<T>,
                    >>::RefType::from(&self.active),
                    __codec_dest_edqy,
                );
            }
            ::codec::Encode::encode_to(&self.unlocking, __codec_dest_edqy);
            ::codec::Encode::encode_to(&self.legacy_claimed_rewards, __codec_dest_edqy);
            let _ = &self.controller;
        }
    }
    #[automatically_derived]
    impl<T: Config> ::codec::EncodeLike for StakingLedger<T>
    where
        T::AccountId: ::codec::Encode,
        T::AccountId: ::codec::Encode,
        BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>: ::codec::Encode,
        BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>: ::codec::Encode,
        BoundedVec<EraIndex, T::HistoryDepth>: ::codec::Encode,
        BoundedVec<EraIndex, T::HistoryDepth>: ::codec::Encode,
        BalanceOf<T>: ::codec::HasCompact,
        BalanceOf<T>: ::codec::HasCompact,
    {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<T: Config> ::codec::Decode for StakingLedger<T>
    where
        T::AccountId: ::codec::Decode,
        T::AccountId: ::codec::Decode,
        BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>: ::codec::Decode,
        BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>: ::codec::Decode,
        BoundedVec<EraIndex, T::HistoryDepth>: ::codec::Decode,
        BoundedVec<EraIndex, T::HistoryDepth>: ::codec::Decode,
        BalanceOf<T>: ::codec::HasCompact,
        BalanceOf<T>: ::codec::HasCompact,
        Option<T::AccountId>: Default,
    {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            ::core::result::Result::Ok(StakingLedger::<T> {
                stash: {
                    let __codec_res_edqy = <T::AccountId as ::codec::Decode>::decode(
                        __codec_input_edqy,
                    );
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `StakingLedger::stash`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
                total: {
                    let __codec_res_edqy = <<BalanceOf<
                        T,
                    > as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                        __codec_input_edqy,
                    );
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `StakingLedger::total`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => {
                            __codec_res_edqy.into()
                        }
                    }
                },
                active: {
                    let __codec_res_edqy = <<BalanceOf<
                        T,
                    > as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                        __codec_input_edqy,
                    );
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `StakingLedger::active`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => {
                            __codec_res_edqy.into()
                        }
                    }
                },
                unlocking: {
                    let __codec_res_edqy = <BoundedVec<
                        UnlockChunk<BalanceOf<T>>,
                        T::MaxUnlockingChunks,
                    > as ::codec::Decode>::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `StakingLedger::unlocking`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
                legacy_claimed_rewards: {
                    let __codec_res_edqy = <BoundedVec<
                        EraIndex,
                        T::HistoryDepth,
                    > as ::codec::Decode>::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e
                                    .chain(
                                        "Could not decode `StakingLedger::legacy_claimed_rewards`",
                                    ),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
                controller: ::core::default::Default::default(),
            })
        }
    }
};
const _: () = {
    #[automatically_derived]
    impl<T: Config> ::core::fmt::Debug for StakingLedger<T> {
        fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            fmt.debug_struct("StakingLedger")
                .field("stash", &self.stash)
                .field("total", &self.total)
                .field("active", &self.active)
                .field("unlocking", &self.unlocking)
                .field("legacy_claimed_rewards", &self.legacy_claimed_rewards)
                .field("controller", &self.controller)
                .finish()
        }
    }
};
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl<T: Config> ::scale_info::TypeInfo for StakingLedger<T>
    where
        T::AccountId: ::scale_info::TypeInfo + 'static,
        BalanceOf<T>: ::scale_info::scale::HasCompact,
        BalanceOf<T>: ::scale_info::scale::HasCompact,
        BoundedVec<
            UnlockChunk<BalanceOf<T>>,
            T::MaxUnlockingChunks,
        >: ::scale_info::TypeInfo + 'static,
        BoundedVec<EraIndex, T::HistoryDepth>: ::scale_info::TypeInfo + 'static,
        Option<T::AccountId>: ::scale_info::TypeInfo + 'static,
        T: Config + 'static,
    {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new_with_replace(
                        "StakingLedger",
                        "pallet_staking",
                        &[],
                    ),
                )
                .type_params(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::scale_info::TypeParameter::new(
                                "T",
                                ::core::option::Option::None,
                            ),
                        ]),
                    ),
                )
                .docs(
                    &[
                        "The ledger of a (bonded) stash.",
                        "",
                        "Note: All the reads and mutations to the [`Ledger`], [`Bonded`] and [`Payee`] storage items",
                        "*MUST* be performed through the methods exposed by this struct, to ensure the consistency of",
                        "ledger's data and corresponding staking lock",
                        "",
                        "TODO: move struct definition and full implementation into `/src/ledger.rs`. Currently",
                        "leaving here to enforce a clean PR diff, given how critical this logic is. Tracking issue",
                        "<https://github.com/paritytech/substrate/issues/14749>.",
                    ],
                )
                .composite(
                    ::scale_info::build::Fields::named()
                        .field(|f| {
                            f
                                .ty::<T::AccountId>()
                                .name("stash")
                                .type_name("T::AccountId")
                                .docs(
                                    &[
                                        "The stash account whose balance is actually locked and at stake.",
                                    ],
                                )
                        })
                        .field(|f| {
                            f
                                .compact::<BalanceOf<T>>()
                                .name("total")
                                .type_name("BalanceOf<T>")
                                .docs(
                                    &[
                                        "The total amount of the stash's balance that we are currently accounting for.",
                                        "It's just `active` plus all the `unlocking` balances.",
                                    ],
                                )
                        })
                        .field(|f| {
                            f
                                .compact::<BalanceOf<T>>()
                                .name("active")
                                .type_name("BalanceOf<T>")
                                .docs(
                                    &[
                                        "The total amount of the stash's balance that will be at stake in any forthcoming",
                                        "rounds.",
                                    ],
                                )
                        })
                        .field(|f| {
                            f
                                .ty::<
                                    BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>,
                                >()
                                .name("unlocking")
                                .type_name(
                                    "BoundedVec<UnlockChunk<BalanceOf<T>>, T::MaxUnlockingChunks>",
                                )
                                .docs(
                                    &[
                                        "Any balance that is becoming free, which may eventually be transferred out of the stash",
                                        "(assuming it doesn't get slashed first). It is assumed that this will be treated as a first",
                                        "in, first out queue where the new (higher value) eras get pushed on the back.",
                                    ],
                                )
                        })
                        .field(|f| {
                            f
                                .ty::<BoundedVec<EraIndex, T::HistoryDepth>>()
                                .name("legacy_claimed_rewards")
                                .type_name("BoundedVec<EraIndex, T::HistoryDepth>")
                                .docs(
                                    &[
                                        "List of eras for which the stakers behind a validator have claimed rewards. Only updated",
                                        "for validators.",
                                        "",
                                        "This is deprecated as of V14 in favor of `T::ClaimedRewards` and will be removed in future.",
                                        "Refer to issue <https://github.com/paritytech/polkadot-sdk/issues/433>",
                                    ],
                                )
                        }),
                )
        }
    }
};
const _: () = {
    impl<T: Config> ::codec::MaxEncodedLen for StakingLedger<T>
    where
        T::AccountId: ::codec::MaxEncodedLen,
        T::AccountId: ::codec::MaxEncodedLen,
        BoundedVec<
            UnlockChunk<BalanceOf<T>>,
            T::MaxUnlockingChunks,
        >: ::codec::MaxEncodedLen,
        BoundedVec<
            UnlockChunk<BalanceOf<T>>,
            T::MaxUnlockingChunks,
        >: ::codec::MaxEncodedLen,
        BoundedVec<EraIndex, T::HistoryDepth>: ::codec::MaxEncodedLen,
        BoundedVec<EraIndex, T::HistoryDepth>: ::codec::MaxEncodedLen,
        BalanceOf<T>: ::codec::HasCompact,
        BalanceOf<T>: ::codec::HasCompact,
    {
        fn max_encoded_len() -> ::core::primitive::usize {
            0_usize
                .saturating_add(<T::AccountId>::max_encoded_len())
                .saturating_add(<BalanceOf<T>>::max_encoded_len())
                .saturating_add(<BalanceOf<T>>::max_encoded_len())
                .saturating_add(
                    <BoundedVec<
                        UnlockChunk<BalanceOf<T>>,
                        T::MaxUnlockingChunks,
                    >>::max_encoded_len(),
                )
                .saturating_add(
                    <BoundedVec<EraIndex, T::HistoryDepth>>::max_encoded_len(),
                )
        }
    }
};
/// State of a ledger with regards with its data and metadata integrity.
enum LedgerIntegrityState {
    /// Ledger, bond and corresponding staking lock is OK.
    Ok,
    /// Ledger and/or bond is corrupted. This means that the bond has a ledger with a different
    /// stash than the bonded stash.
    Corrupted,
    /// Ledger was corrupted and it has been killed.
    CorruptedKilled,
    /// Ledger and bond are OK, however the ledger's stash lock is out of sync.
    LockCorrupted,
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for LedgerIntegrityState {}
#[automatically_derived]
impl ::core::cmp::PartialEq for LedgerIntegrityState {
    #[inline]
    fn eq(&self, other: &LedgerIntegrityState) -> bool {
        let __self_discr = ::core::intrinsics::discriminant_value(self);
        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
        __self_discr == __arg1_discr
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for LedgerIntegrityState {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(
            f,
            match self {
                LedgerIntegrityState::Ok => "Ok",
                LedgerIntegrityState::Corrupted => "Corrupted",
                LedgerIntegrityState::CorruptedKilled => "CorruptedKilled",
                LedgerIntegrityState::LockCorrupted => "LockCorrupted",
            },
        )
    }
}
impl<T: Config> StakingLedger<T> {
    /// Remove entries from `unlocking` that are sufficiently old and reduce the
    /// total by the sum of their balances.
    fn consolidate_unlocked(self, current_era: EraIndex) -> Self {
        let mut total = self.total;
        let unlocking: BoundedVec<_, _> = self
            .unlocking
            .into_iter()
            .filter(|chunk| {
                if chunk.era > current_era {
                    true
                } else {
                    total = total.saturating_sub(chunk.value);
                    false
                }
            })
            .collect::<Vec<_>>()
            .try_into()
            .expect(
                "filtering items from a bounded vec always leaves length less than bounds. qed",
            );
        Self {
            stash: self.stash,
            total,
            active: self.active,
            unlocking,
            legacy_claimed_rewards: self.legacy_claimed_rewards,
            controller: self.controller,
        }
    }
    /// Re-bond funds that were scheduled for unlocking.
    ///
    /// Returns the updated ledger, and the amount actually rebonded.
    fn rebond(mut self, value: BalanceOf<T>) -> (Self, BalanceOf<T>) {
        let mut unlocking_balance = BalanceOf::<T>::zero();
        while let Some(last) = self.unlocking.last_mut() {
            if unlocking_balance.defensive_saturating_add(last.value) <= value {
                unlocking_balance += last.value;
                self.active += last.value;
                self.unlocking.pop();
            } else {
                let diff = value.defensive_saturating_sub(unlocking_balance);
                unlocking_balance += diff;
                self.active += diff;
                last.value -= diff;
            }
            if unlocking_balance >= value {
                break;
            }
        }
        (self, unlocking_balance)
    }
    /// Slash the staker for a given amount of balance.
    ///
    /// This implements a proportional slashing system, whereby we set our preference to slash as
    /// such:
    ///
    /// - If any unlocking chunks exist that are scheduled to be unlocked at `slash_era +
    ///   bonding_duration` and onwards, the slash is divided equally between the active ledger and
    ///   the unlocking chunks.
    /// - If no such chunks exist, then only the active balance is slashed.
    ///
    /// Note that the above is only a *preference*. If for any reason the active ledger, with or
    /// without some portion of the unlocking chunks that are more justified to be slashed are not
    /// enough, then the slashing will continue and will consume as much of the active and unlocking
    /// chunks as needed.
    ///
    /// This will never slash more than the given amount. If any of the chunks become dusted, the
    /// last chunk is slashed slightly less to compensate. Returns the amount of funds actually
    /// slashed.
    ///
    /// `slash_era` is the era in which the slash (which is being enacted now) actually happened.
    ///
    /// This calls `Config::OnStakingUpdate::on_slash` with information as to how the slash was
    /// applied.
    pub fn slash(
        &mut self,
        slash_amount: BalanceOf<T>,
        minimum_balance: BalanceOf<T>,
        slash_era: EraIndex,
    ) -> BalanceOf<T> {
        if slash_amount.is_zero() {
            return Zero::zero();
        }
        use sp_runtime::PerThing as _;
        let mut remaining_slash = slash_amount;
        let pre_slash_total = self.total;
        let slashable_chunks_start = slash_era.saturating_add(T::BondingDuration::get());
        let (maybe_proportional, slash_chunks_priority) = {
            if let Some(first_slashable_index) = self
                .unlocking
                .iter()
                .position(|c| c.era >= slashable_chunks_start)
            {
                let affected_indices = first_slashable_index..self.unlocking.len();
                let unbonding_affected_balance = affected_indices
                    .clone()
                    .fold(
                        BalanceOf::<T>::zero(),
                        |sum, i| {
                            if let Some(chunk) = self.unlocking.get(i).defensive() {
                                sum.saturating_add(chunk.value)
                            } else {
                                sum
                            }
                        },
                    );
                let affected_balance = self
                    .active
                    .saturating_add(unbonding_affected_balance);
                let ratio = Perquintill::from_rational_with_rounding(
                        slash_amount,
                        affected_balance,
                        Rounding::Up,
                    )
                    .unwrap_or_else(|_| Perquintill::one());
                (
                    Some(ratio),
                    affected_indices
                        .chain((0..first_slashable_index).rev())
                        .collect::<Vec<_>>(),
                )
            } else {
                (None, (0..self.unlocking.len()).rev().collect::<Vec<_>>())
            }
        };
        {
            let lvl = ::log::Level::Debug;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api::log(
                    format_args!(
                        "[{0:?}] 💸 slashing {1:?} for era {2:?} out of {3:?}, priority: {4:?}, proportional = {5:?}",
                        <frame_system::Pallet<T>>::block_number(),
                        slash_amount,
                        slash_era,
                        self,
                        slash_chunks_priority,
                        maybe_proportional,
                    ),
                    lvl,
                    &(crate::LOG_TARGET, "pallet_staking", ::log::__private_api::loc()),
                    (),
                );
            }
        };
        let mut slash_out_of = |
            target: &mut BalanceOf<T>,
            slash_remaining: &mut BalanceOf<T>|
        {
            let mut slash_from_target = if let Some(ratio) = maybe_proportional {
                ratio.mul_ceil(*target)
            } else {
                *slash_remaining
            }
                .min(*target)
                .min(*slash_remaining);
            *target = *target - slash_from_target;
            if *target < minimum_balance {
                slash_from_target = core::mem::replace(target, Zero::zero())
                    .saturating_add(slash_from_target);
            }
            self.total = self.total.saturating_sub(slash_from_target);
            *slash_remaining = slash_remaining.saturating_sub(slash_from_target);
        };
        slash_out_of(&mut self.active, &mut remaining_slash);
        let mut slashed_unlocking = BTreeMap::<_, _>::new();
        for i in slash_chunks_priority {
            if remaining_slash.is_zero() {
                break;
            }
            if let Some(chunk) = self.unlocking.get_mut(i).defensive() {
                slash_out_of(&mut chunk.value, &mut remaining_slash);
                slashed_unlocking.insert(chunk.era, chunk.value);
            } else {
                break
            }
        }
        self.unlocking.retain(|c| !c.value.is_zero());
        let final_slashed_amount = pre_slash_total.saturating_sub(self.total);
        T::EventListeners::on_slash(
            &self.stash,
            self.active,
            &slashed_unlocking,
            final_slashed_amount,
        );
        final_slashed_amount
    }
}
/// A record of the nominations made by a specific account.
#[codec(mel_bound())]
#[scale_info(skip_type_params(T))]
pub struct Nominations<T: Config> {
    /// The targets of nomination.
    pub targets: BoundedVec<T::AccountId, MaxNominationsOf<T>>,
    /// The era the nominations were submitted.
    ///
    /// Except for initial nominations which are considered submitted at era 0.
    pub submitted_in: EraIndex,
    /// Whether the nominations have been suppressed. This can happen due to slashing of the
    /// validators, or other events that might invalidate the nomination.
    ///
    /// NOTE: this for future proofing and is thus far not used.
    pub suppressed: bool,
}
const _: () = {
    #[automatically_derived]
    impl<T: Config> ::core::cmp::PartialEq for Nominations<T> {
        fn eq(&self, other: &Self) -> bool {
            true && self.targets == other.targets
                && self.submitted_in == other.submitted_in
                && self.suppressed == other.suppressed
        }
    }
};
const _: () = {
    impl<T: Config> ::core::cmp::Eq for Nominations<T> {}
};
#[automatically_derived]
impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for Nominations<T>
where
    T::AccountId: ::core::clone::Clone,
{
    #[inline]
    fn clone(&self) -> Nominations<T> {
        Nominations {
            targets: ::core::clone::Clone::clone(&self.targets),
            submitted_in: ::core::clone::Clone::clone(&self.submitted_in),
            suppressed: ::core::clone::Clone::clone(&self.suppressed),
        }
    }
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<T: Config> ::codec::Encode for Nominations<T>
    where
        BoundedVec<T::AccountId, MaxNominationsOf<T>>: ::codec::Encode,
        BoundedVec<T::AccountId, MaxNominationsOf<T>>: ::codec::Encode,
    {
        fn size_hint(&self) -> usize {
            0_usize
                .saturating_add(::codec::Encode::size_hint(&self.targets))
                .saturating_add(::codec::Encode::size_hint(&self.submitted_in))
                .saturating_add(::codec::Encode::size_hint(&self.suppressed))
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            ::codec::Encode::encode_to(&self.targets, __codec_dest_edqy);
            ::codec::Encode::encode_to(&self.submitted_in, __codec_dest_edqy);
            ::codec::Encode::encode_to(&self.suppressed, __codec_dest_edqy);
        }
    }
    #[automatically_derived]
    impl<T: Config> ::codec::EncodeLike for Nominations<T>
    where
        BoundedVec<T::AccountId, MaxNominationsOf<T>>: ::codec::Encode,
        BoundedVec<T::AccountId, MaxNominationsOf<T>>: ::codec::Encode,
    {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<T: Config> ::codec::Decode for Nominations<T>
    where
        BoundedVec<T::AccountId, MaxNominationsOf<T>>: ::codec::Decode,
        BoundedVec<T::AccountId, MaxNominationsOf<T>>: ::codec::Decode,
    {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            ::core::result::Result::Ok(Nominations::<T> {
                targets: {
                    let __codec_res_edqy = <BoundedVec<
                        T::AccountId,
                        MaxNominationsOf<T>,
                    > as ::codec::Decode>::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `Nominations::targets`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
                submitted_in: {
                    let __codec_res_edqy = <EraIndex as ::codec::Decode>::decode(
                        __codec_input_edqy,
                    );
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `Nominations::submitted_in`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
                suppressed: {
                    let __codec_res_edqy = <bool as ::codec::Decode>::decode(
                        __codec_input_edqy,
                    );
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `Nominations::suppressed`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
            })
        }
    }
};
const _: () = {
    #[automatically_derived]
    impl<T: Config> ::core::fmt::Debug for Nominations<T> {
        fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            fmt.debug_struct("Nominations")
                .field("targets", &self.targets)
                .field("submitted_in", &self.submitted_in)
                .field("suppressed", &self.suppressed)
                .finish()
        }
    }
};
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl<T: Config> ::scale_info::TypeInfo for Nominations<T>
    where
        BoundedVec<T::AccountId, MaxNominationsOf<T>>: ::scale_info::TypeInfo + 'static,
        T: Config + 'static,
    {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new_with_replace(
                        "Nominations",
                        "pallet_staking",
                        &[],
                    ),
                )
                .type_params(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::scale_info::TypeParameter::new(
                                "T",
                                ::core::option::Option::None,
                            ),
                        ]),
                    ),
                )
                .docs(&["A record of the nominations made by a specific account."])
                .composite(
                    ::scale_info::build::Fields::named()
                        .field(|f| {
                            f
                                .ty::<BoundedVec<T::AccountId, MaxNominationsOf<T>>>()
                                .name("targets")
                                .type_name("BoundedVec<T::AccountId, MaxNominationsOf<T>>")
                                .docs(&["The targets of nomination."])
                        })
                        .field(|f| {
                            f
                                .ty::<EraIndex>()
                                .name("submitted_in")
                                .type_name("EraIndex")
                                .docs(
                                    &[
                                        "The era the nominations were submitted.",
                                        "",
                                        "Except for initial nominations which are considered submitted at era 0.",
                                    ],
                                )
                        })
                        .field(|f| {
                            f
                                .ty::<bool>()
                                .name("suppressed")
                                .type_name("bool")
                                .docs(
                                    &[
                                        "Whether the nominations have been suppressed. This can happen due to slashing of the",
                                        "validators, or other events that might invalidate the nomination.",
                                        "",
                                        "NOTE: this for future proofing and is thus far not used.",
                                    ],
                                )
                        }),
                )
        }
    }
};
const _: () = {
    impl<T: Config> ::codec::MaxEncodedLen for Nominations<T> {
        fn max_encoded_len() -> ::core::primitive::usize {
            0_usize
                .saturating_add(
                    <BoundedVec<T::AccountId, MaxNominationsOf<T>>>::max_encoded_len(),
                )
                .saturating_add(<EraIndex>::max_encoded_len())
                .saturating_add(<bool>::max_encoded_len())
        }
    }
};
/// Facade struct to encapsulate `PagedExposureMetadata` and a single page of `ExposurePage`.
///
/// This is useful where we need to take into account the validator's own stake and total exposure
/// in consideration, in addition to the individual nominators backing them.
pub struct PagedExposure<AccountId, Balance: HasCompact + codec::MaxEncodedLen> {
    exposure_metadata: PagedExposureMetadata<Balance>,
    exposure_page: ExposurePage<AccountId, Balance>,
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<AccountId, Balance: HasCompact + codec::MaxEncodedLen> ::codec::Encode
    for PagedExposure<AccountId, Balance>
    where
        PagedExposureMetadata<Balance>: ::codec::Encode,
        PagedExposureMetadata<Balance>: ::codec::Encode,
        ExposurePage<AccountId, Balance>: ::codec::Encode,
        ExposurePage<AccountId, Balance>: ::codec::Encode,
    {
        fn size_hint(&self) -> usize {
            0_usize
                .saturating_add(::codec::Encode::size_hint(&self.exposure_metadata))
                .saturating_add(::codec::Encode::size_hint(&self.exposure_page))
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            ::codec::Encode::encode_to(&self.exposure_metadata, __codec_dest_edqy);
            ::codec::Encode::encode_to(&self.exposure_page, __codec_dest_edqy);
        }
    }
    #[automatically_derived]
    impl<AccountId, Balance: HasCompact + codec::MaxEncodedLen> ::codec::EncodeLike
    for PagedExposure<AccountId, Balance>
    where
        PagedExposureMetadata<Balance>: ::codec::Encode,
        PagedExposureMetadata<Balance>: ::codec::Encode,
        ExposurePage<AccountId, Balance>: ::codec::Encode,
        ExposurePage<AccountId, Balance>: ::codec::Encode,
    {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<AccountId, Balance: HasCompact + codec::MaxEncodedLen> ::codec::Decode
    for PagedExposure<AccountId, Balance>
    where
        PagedExposureMetadata<Balance>: ::codec::Decode,
        PagedExposureMetadata<Balance>: ::codec::Decode,
        ExposurePage<AccountId, Balance>: ::codec::Decode,
        ExposurePage<AccountId, Balance>: ::codec::Decode,
    {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            ::core::result::Result::Ok(PagedExposure::<AccountId, Balance> {
                exposure_metadata: {
                    let __codec_res_edqy = <PagedExposureMetadata<
                        Balance,
                    > as ::codec::Decode>::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e
                                    .chain(
                                        "Could not decode `PagedExposure::exposure_metadata`",
                                    ),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
                exposure_page: {
                    let __codec_res_edqy = <ExposurePage<
                        AccountId,
                        Balance,
                    > as ::codec::Decode>::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `PagedExposure::exposure_page`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
            })
        }
    }
};
impl<AccountId, Balance: HasCompact + codec::MaxEncodedLen> core::fmt::Debug
for PagedExposure<AccountId, Balance>
where
    AccountId: core::fmt::Debug,
    Balance: core::fmt::Debug,
{
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        fmt.debug_struct("PagedExposure")
            .field("exposure_metadata", &self.exposure_metadata)
            .field("exposure_page", &self.exposure_page)
            .finish()
    }
}
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl<AccountId, Balance: HasCompact + codec::MaxEncodedLen> ::scale_info::TypeInfo
    for PagedExposure<AccountId, Balance>
    where
        PagedExposureMetadata<Balance>: ::scale_info::TypeInfo + 'static,
        ExposurePage<AccountId, Balance>: ::scale_info::TypeInfo + 'static,
        AccountId: ::scale_info::TypeInfo + 'static,
        Balance: HasCompact + codec::MaxEncodedLen + ::scale_info::TypeInfo + 'static,
    {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new_with_replace(
                        "PagedExposure",
                        "pallet_staking",
                        &[],
                    ),
                )
                .type_params(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::scale_info::TypeParameter::new(
                                "AccountId",
                                ::core::option::Option::Some(
                                    ::scale_info::meta_type::<AccountId>(),
                                ),
                            ),
                            ::scale_info::TypeParameter::new(
                                "Balance",
                                ::core::option::Option::Some(
                                    ::scale_info::meta_type::<Balance>(),
                                ),
                            ),
                        ]),
                    ),
                )
                .docs(
                    &[
                        "Facade struct to encapsulate `PagedExposureMetadata` and a single page of `ExposurePage`.",
                        "",
                        "This is useful where we need to take into account the validator's own stake and total exposure",
                        "in consideration, in addition to the individual nominators backing them.",
                    ],
                )
                .composite(
                    ::scale_info::build::Fields::named()
                        .field(|f| {
                            f
                                .ty::<PagedExposureMetadata<Balance>>()
                                .name("exposure_metadata")
                                .type_name("PagedExposureMetadata<Balance>")
                        })
                        .field(|f| {
                            f
                                .ty::<ExposurePage<AccountId, Balance>>()
                                .name("exposure_page")
                                .type_name("ExposurePage<AccountId, Balance>")
                        }),
                )
        }
    }
};
#[automatically_derived]
impl<
    AccountId,
    Balance: HasCompact + codec::MaxEncodedLen,
> ::core::marker::StructuralPartialEq for PagedExposure<AccountId, Balance> {}
#[automatically_derived]
impl<
    AccountId: ::core::cmp::PartialEq,
    Balance: ::core::cmp::PartialEq + HasCompact + codec::MaxEncodedLen,
> ::core::cmp::PartialEq for PagedExposure<AccountId, Balance> {
    #[inline]
    fn eq(&self, other: &PagedExposure<AccountId, Balance>) -> bool {
        self.exposure_metadata == other.exposure_metadata
            && self.exposure_page == other.exposure_page
    }
}
#[automatically_derived]
impl<
    AccountId: ::core::cmp::Eq,
    Balance: ::core::cmp::Eq + HasCompact + codec::MaxEncodedLen,
> ::core::cmp::Eq for PagedExposure<AccountId, Balance> {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<PagedExposureMetadata<Balance>>;
        let _: ::core::cmp::AssertParamIsEq<ExposurePage<AccountId, Balance>>;
    }
}
impl<
    AccountId,
    Balance: HasCompact + Copy + AtLeast32BitUnsigned + codec::MaxEncodedLen,
> PagedExposure<AccountId, Balance> {
    /// Create a new instance of `PagedExposure` from legacy clipped exposures.
    pub fn from_clipped(exposure: Exposure<AccountId, Balance>) -> Self {
        Self {
            exposure_metadata: PagedExposureMetadata {
                total: exposure.total,
                own: exposure.own,
                nominator_count: exposure.others.len() as u32,
                page_count: 1,
            },
            exposure_page: ExposurePage {
                page_total: exposure.total,
                others: exposure.others,
            },
        }
    }
    /// Returns total exposure of this validator across pages
    pub fn total(&self) -> Balance {
        self.exposure_metadata.total
    }
    /// Returns total exposure of this validator for the current page
    pub fn page_total(&self) -> Balance {
        self.exposure_page.page_total + self.exposure_metadata.own
    }
    /// Returns validator's own stake that is exposed
    pub fn own(&self) -> Balance {
        self.exposure_metadata.own
    }
    /// Returns the portions of nominators stashes that are exposed in this page.
    pub fn others(&self) -> &Vec<IndividualExposure<AccountId, Balance>> {
        &self.exposure_page.others
    }
}
/// A pending slash record. The value of the slash has been computed but not applied yet,
/// rather deferred for several eras.
pub struct UnappliedSlash<AccountId, Balance: HasCompact> {
    /// The stash ID of the offending validator.
    validator: AccountId,
    /// The validator's own slash.
    own: Balance,
    /// All other slashed stakers and amounts.
    others: Vec<(AccountId, Balance)>,
    /// Reporters of the offence; bounty payout recipients.
    reporters: Vec<AccountId>,
    /// The amount of payout.
    payout: Balance,
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<AccountId, Balance: HasCompact> ::codec::Encode
    for UnappliedSlash<AccountId, Balance>
    where
        AccountId: ::codec::Encode,
        AccountId: ::codec::Encode,
        Balance: ::codec::Encode,
        Balance: ::codec::Encode,
        Vec<(AccountId, Balance)>: ::codec::Encode,
        Vec<(AccountId, Balance)>: ::codec::Encode,
        Vec<AccountId>: ::codec::Encode,
        Vec<AccountId>: ::codec::Encode,
        Balance: ::codec::Encode,
        Balance: ::codec::Encode,
    {
        fn size_hint(&self) -> usize {
            0_usize
                .saturating_add(::codec::Encode::size_hint(&self.validator))
                .saturating_add(::codec::Encode::size_hint(&self.own))
                .saturating_add(::codec::Encode::size_hint(&self.others))
                .saturating_add(::codec::Encode::size_hint(&self.reporters))
                .saturating_add(::codec::Encode::size_hint(&self.payout))
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            ::codec::Encode::encode_to(&self.validator, __codec_dest_edqy);
            ::codec::Encode::encode_to(&self.own, __codec_dest_edqy);
            ::codec::Encode::encode_to(&self.others, __codec_dest_edqy);
            ::codec::Encode::encode_to(&self.reporters, __codec_dest_edqy);
            ::codec::Encode::encode_to(&self.payout, __codec_dest_edqy);
        }
    }
    #[automatically_derived]
    impl<AccountId, Balance: HasCompact> ::codec::EncodeLike
    for UnappliedSlash<AccountId, Balance>
    where
        AccountId: ::codec::Encode,
        AccountId: ::codec::Encode,
        Balance: ::codec::Encode,
        Balance: ::codec::Encode,
        Vec<(AccountId, Balance)>: ::codec::Encode,
        Vec<(AccountId, Balance)>: ::codec::Encode,
        Vec<AccountId>: ::codec::Encode,
        Vec<AccountId>: ::codec::Encode,
        Balance: ::codec::Encode,
        Balance: ::codec::Encode,
    {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl<AccountId, Balance: HasCompact> ::codec::Decode
    for UnappliedSlash<AccountId, Balance>
    where
        AccountId: ::codec::Decode,
        AccountId: ::codec::Decode,
        Balance: ::codec::Decode,
        Balance: ::codec::Decode,
        Vec<(AccountId, Balance)>: ::codec::Decode,
        Vec<(AccountId, Balance)>: ::codec::Decode,
        Vec<AccountId>: ::codec::Decode,
        Vec<AccountId>: ::codec::Decode,
        Balance: ::codec::Decode,
        Balance: ::codec::Decode,
    {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            ::core::result::Result::Ok(UnappliedSlash::<AccountId, Balance> {
                validator: {
                    let __codec_res_edqy = <AccountId as ::codec::Decode>::decode(
                        __codec_input_edqy,
                    );
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `UnappliedSlash::validator`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
                own: {
                    let __codec_res_edqy = <Balance as ::codec::Decode>::decode(
                        __codec_input_edqy,
                    );
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `UnappliedSlash::own`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
                others: {
                    let __codec_res_edqy = <Vec<
                        (AccountId, Balance),
                    > as ::codec::Decode>::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `UnappliedSlash::others`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
                reporters: {
                    let __codec_res_edqy = <Vec<
                        AccountId,
                    > as ::codec::Decode>::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `UnappliedSlash::reporters`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
                payout: {
                    let __codec_res_edqy = <Balance as ::codec::Decode>::decode(
                        __codec_input_edqy,
                    );
                    match __codec_res_edqy {
                        ::core::result::Result::Err(e) => {
                            return ::core::result::Result::Err(
                                e.chain("Could not decode `UnappliedSlash::payout`"),
                            );
                        }
                        ::core::result::Result::Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
            })
        }
    }
};
impl<AccountId, Balance: HasCompact> core::fmt::Debug
for UnappliedSlash<AccountId, Balance>
where
    AccountId: core::fmt::Debug,
    Balance: core::fmt::Debug,
{
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        fmt.debug_struct("UnappliedSlash")
            .field("validator", &self.validator)
            .field("own", &self.own)
            .field("others", &self.others)
            .field("reporters", &self.reporters)
            .field("payout", &self.payout)
            .finish()
    }
}
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl<AccountId, Balance: HasCompact> ::scale_info::TypeInfo
    for UnappliedSlash<AccountId, Balance>
    where
        AccountId: ::scale_info::TypeInfo + 'static,
        Balance: ::scale_info::TypeInfo + 'static,
        Vec<(AccountId, Balance)>: ::scale_info::TypeInfo + 'static,
        Vec<AccountId>: ::scale_info::TypeInfo + 'static,
        Balance: ::scale_info::TypeInfo + 'static,
        AccountId: ::scale_info::TypeInfo + 'static,
        Balance: HasCompact + ::scale_info::TypeInfo + 'static,
    {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new_with_replace(
                        "UnappliedSlash",
                        "pallet_staking",
                        &[],
                    ),
                )
                .type_params(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::scale_info::TypeParameter::new(
                                "AccountId",
                                ::core::option::Option::Some(
                                    ::scale_info::meta_type::<AccountId>(),
                                ),
                            ),
                            ::scale_info::TypeParameter::new(
                                "Balance",
                                ::core::option::Option::Some(
                                    ::scale_info::meta_type::<Balance>(),
                                ),
                            ),
                        ]),
                    ),
                )
                .docs(
                    &[
                        "A pending slash record. The value of the slash has been computed but not applied yet,",
                        "rather deferred for several eras.",
                    ],
                )
                .composite(
                    ::scale_info::build::Fields::named()
                        .field(|f| {
                            f
                                .ty::<AccountId>()
                                .name("validator")
                                .type_name("AccountId")
                                .docs(&["The stash ID of the offending validator."])
                        })
                        .field(|f| {
                            f
                                .ty::<Balance>()
                                .name("own")
                                .type_name("Balance")
                                .docs(&["The validator's own slash."])
                        })
                        .field(|f| {
                            f
                                .ty::<Vec<(AccountId, Balance)>>()
                                .name("others")
                                .type_name("Vec<(AccountId, Balance)>")
                                .docs(&["All other slashed stakers and amounts."])
                        })
                        .field(|f| {
                            f
                                .ty::<Vec<AccountId>>()
                                .name("reporters")
                                .type_name("Vec<AccountId>")
                                .docs(
                                    &["Reporters of the offence; bounty payout recipients."],
                                )
                        })
                        .field(|f| {
                            f
                                .ty::<Balance>()
                                .name("payout")
                                .type_name("Balance")
                                .docs(&["The amount of payout."])
                        }),
                )
        }
    }
};
impl<AccountId, Balance: HasCompact + Zero> UnappliedSlash<AccountId, Balance> {
    /// Initializes the default object using the given `validator`.
    pub fn default_from(validator: AccountId) -> Self {
        Self {
            validator,
            own: Zero::zero(),
            others: ::alloc::vec::Vec::new(),
            reporters: ::alloc::vec::Vec::new(),
            payout: Zero::zero(),
        }
    }
}
/// Something that defines the maximum number of nominations per nominator based on a curve.
///
/// The method `curve` implements the nomination quota curve and should not be used directly.
/// However, `get_quota` returns the bounded maximum number of nominations based on `fn curve` and
/// the nominator's balance.
pub trait NominationsQuota<Balance> {
    /// Strict maximum number of nominations that caps the nominations curve. This value can be
    /// used as the upper bound of the number of votes per nominator.
    type MaxNominations: Get<u32>;
    /// Returns the voter's nomination quota within reasonable bounds [`min`, `max`], where `min`
    /// is 1 and `max` is `Self::MaxNominations`.
    fn get_quota(balance: Balance) -> u32 {
        Self::curve(balance).clamp(1, Self::MaxNominations::get())
    }
    /// Returns the voter's nomination quota based on its balance and a curve.
    fn curve(balance: Balance) -> u32;
}
/// A nomination quota that allows up to MAX nominations for all validators.
pub struct FixedNominationsQuota<const MAX: u32>;
impl<Balance, const MAX: u32> NominationsQuota<Balance> for FixedNominationsQuota<MAX> {
    type MaxNominations = ConstU32<MAX>;
    fn curve(_: Balance) -> u32 {
        MAX
    }
}
/// Means for interacting with a specialized version of the `session` trait.
///
/// This is needed because `Staking` sets the `ValidatorIdOf` of the `pallet_session::Config`
pub trait SessionInterface<AccountId> {
    /// Disable the validator at the given index, returns `false` if the validator was already
    /// disabled or the index is out of bounds.
    fn disable_validator(validator_index: u32) -> bool;
    /// Get the validators from session.
    fn validators() -> Vec<AccountId>;
    /// Prune historical session tries up to but not including the given index.
    fn prune_historical_up_to(up_to: SessionIndex);
}
impl<T: Config> SessionInterface<<T as frame_system::Config>::AccountId> for T
where
    T: pallet_session::Config<ValidatorId = <T as frame_system::Config>::AccountId>,
    T: pallet_session::historical::Config<
        FullIdentification = Exposure<
            <T as frame_system::Config>::AccountId,
            BalanceOf<T>,
        >,
        FullIdentificationOf = ExposureOf<T>,
    >,
    T::SessionHandler: pallet_session::SessionHandler<
        <T as frame_system::Config>::AccountId,
    >,
    T::SessionManager: pallet_session::SessionManager<
        <T as frame_system::Config>::AccountId,
    >,
    T::ValidatorIdOf: Convert<
        <T as frame_system::Config>::AccountId,
        Option<<T as frame_system::Config>::AccountId>,
    >,
{
    fn disable_validator(validator_index: u32) -> bool {
        <pallet_session::Pallet<T>>::disable_index(validator_index)
    }
    fn validators() -> Vec<<T as frame_system::Config>::AccountId> {
        <pallet_session::Pallet<T>>::validators()
    }
    fn prune_historical_up_to(up_to: SessionIndex) {
        <pallet_session::historical::Pallet<T>>::prune_up_to(up_to);
    }
}
impl<AccountId> SessionInterface<AccountId> for () {
    fn disable_validator(_: u32) -> bool {
        true
    }
    fn validators() -> Vec<AccountId> {
        Vec::new()
    }
    fn prune_historical_up_to(_: SessionIndex) {
        ()
    }
}
/// Handler for determining how much of a balance should be paid out on the current era.
pub trait EraPayout<Balance> {
    /// Determine the payout for this era.
    ///
    /// Returns the amount to be paid to stakers in this era, as well as whatever else should be
    /// paid out ("the rest").
    fn era_payout(
        total_staked: Balance,
        total_issuance: Balance,
        era_duration_millis: u64,
    ) -> (Balance, Balance);
}
impl<Balance: Default> EraPayout<Balance> for () {
    fn era_payout(
        _total_staked: Balance,
        _total_issuance: Balance,
        _era_duration_millis: u64,
    ) -> (Balance, Balance) {
        (Default::default(), Default::default())
    }
}
/// Adaptor to turn a `PiecewiseLinear` curve definition into an `EraPayout` impl, used for
/// backwards compatibility.
pub struct ConvertCurve<T>(core::marker::PhantomData<T>);
impl<Balance, T> EraPayout<Balance> for ConvertCurve<T>
where
    Balance: AtLeast32BitUnsigned + Clone + Copy,
    T: Get<&'static PiecewiseLinear<'static>>,
{
    fn era_payout(
        total_staked: Balance,
        total_issuance: Balance,
        era_duration_millis: u64,
    ) -> (Balance, Balance) {
        let (validator_payout, max_payout) = inflation::compute_total_payout(
            T::get(),
            total_staked,
            total_issuance,
            era_duration_millis,
        );
        let rest = max_payout.saturating_sub(validator_payout);
        (validator_payout, rest)
    }
}
/// Mode of era-forcing.
pub enum Forcing {
    /// Not forcing anything - just let whatever happen.
    NotForcing,
    /// Force a new era, then reset to `NotForcing` as soon as it is done.
    /// Note that this will force to trigger an election until a new era is triggered, if the
    /// election failed, the next session end will trigger a new election again, until success.
    ForceNew,
    /// Avoid a new era indefinitely.
    ForceNone,
    /// Force a new era at the end of all sessions indefinitely.
    ForceAlways,
}
#[automatically_derived]
impl ::core::marker::Copy for Forcing {}
#[automatically_derived]
impl ::core::clone::Clone for Forcing {
    #[inline]
    fn clone(&self) -> Forcing {
        *self
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for Forcing {}
#[automatically_derived]
impl ::core::cmp::PartialEq for Forcing {
    #[inline]
    fn eq(&self, other: &Forcing) -> bool {
        let __self_discr = ::core::intrinsics::discriminant_value(self);
        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
        __self_discr == __arg1_discr
    }
}
#[automatically_derived]
impl ::core::cmp::Eq for Forcing {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {}
}
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Encode for Forcing {
        fn size_hint(&self) -> usize {
            1_usize
                + match *self {
                    Forcing::NotForcing => 0_usize,
                    Forcing::ForceNew => 0_usize,
                    Forcing::ForceNone => 0_usize,
                    Forcing::ForceAlways => 0_usize,
                    _ => 0_usize,
                }
        }
        fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            match *self {
                Forcing::NotForcing => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                }
                Forcing::ForceNew => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                }
                Forcing::ForceNone => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(2usize as ::core::primitive::u8);
                }
                Forcing::ForceAlways => {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_dest_edqy.push_byte(3usize as ::core::primitive::u8);
                }
                _ => {}
            }
        }
    }
    #[automatically_derived]
    impl ::codec::EncodeLike for Forcing {}
};
#[allow(deprecated)]
const _: () = {
    #[automatically_derived]
    impl ::codec::Decode for Forcing {
        fn decode<__CodecInputEdqy: ::codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> ::core::result::Result<Self, ::codec::Error> {
            match __codec_input_edqy
                .read_byte()
                .map_err(|e| {
                    e.chain("Could not decode `Forcing`, failed to read variant byte")
                })?
            {
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 0usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(Forcing::NotForcing)
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 1usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || { ::core::result::Result::Ok(Forcing::ForceNew) })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 2usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(Forcing::ForceNone)
                    })();
                }
                #[allow(clippy::unnecessary_cast)]
                __codec_x_edqy if __codec_x_edqy == 3usize as ::core::primitive::u8 => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Ok(Forcing::ForceAlways)
                    })();
                }
                _ => {
                    #[allow(clippy::redundant_closure_call)]
                    return (move || {
                        ::core::result::Result::Err(
                            <_ as ::core::convert::Into<
                                _,
                            >>::into("Could not decode `Forcing`, variant doesn't exist"),
                        )
                    })();
                }
            }
        }
    }
};
impl core::fmt::Debug for Forcing {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            Self::NotForcing => fmt.debug_tuple("Forcing::NotForcing").finish(),
            Self::ForceNew => fmt.debug_tuple("Forcing::ForceNew").finish(),
            Self::ForceNone => fmt.debug_tuple("Forcing::ForceNone").finish(),
            Self::ForceAlways => fmt.debug_tuple("Forcing::ForceAlways").finish(),
            _ => Ok(()),
        }
    }
}
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    impl ::scale_info::TypeInfo for Forcing {
        type Identity = Self;
        fn type_info() -> ::scale_info::Type {
            ::scale_info::Type::builder()
                .path(
                    ::scale_info::Path::new_with_replace(
                        "Forcing",
                        "pallet_staking",
                        &[],
                    ),
                )
                .type_params(::alloc::vec::Vec::new())
                .docs(&["Mode of era-forcing."])
                .variant(
                    ::scale_info::build::Variants::new()
                        .variant(
                            "NotForcing",
                            |v| {
                                v
                                    .index(0usize as ::core::primitive::u8)
                                    .docs(&["Not forcing anything - just let whatever happen."])
                            },
                        )
                        .variant(
                            "ForceNew",
                            |v| {
                                v
                                    .index(1usize as ::core::primitive::u8)
                                    .docs(
                                        &[
                                            "Force a new era, then reset to `NotForcing` as soon as it is done.",
                                            "Note that this will force to trigger an election until a new era is triggered, if the",
                                            "election failed, the next session end will trigger a new election again, until success.",
                                        ],
                                    )
                            },
                        )
                        .variant(
                            "ForceNone",
                            |v| {
                                v
                                    .index(2usize as ::core::primitive::u8)
                                    .docs(&["Avoid a new era indefinitely."])
                            },
                        )
                        .variant(
                            "ForceAlways",
                            |v| {
                                v
                                    .index(3usize as ::core::primitive::u8)
                                    .docs(
                                        &[
                                            "Force a new era at the end of all sessions indefinitely.",
                                        ],
                                    )
                            },
                        ),
                )
        }
    }
};
const _: () = {
    impl ::codec::MaxEncodedLen for Forcing {
        fn max_encoded_len() -> ::core::primitive::usize {
            0_usize.max(0_usize).max(0_usize).max(0_usize).max(0_usize).saturating_add(1)
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Forcing {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                Forcing::NotForcing => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Forcing",
                        0u32,
                        "NotForcing",
                    )
                }
                Forcing::ForceNew => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Forcing",
                        1u32,
                        "ForceNew",
                    )
                }
                Forcing::ForceNone => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Forcing",
                        2u32,
                        "ForceNone",
                    )
                }
                Forcing::ForceAlways => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Forcing",
                        3u32,
                        "ForceAlways",
                    )
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for Forcing {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "variant identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 4",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "NotForcing" => _serde::__private::Ok(__Field::__field0),
                        "ForceNew" => _serde::__private::Ok(__Field::__field1),
                        "ForceNone" => _serde::__private::Ok(__Field::__field2),
                        "ForceAlways" => _serde::__private::Ok(__Field::__field3),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"NotForcing" => _serde::__private::Ok(__Field::__field0),
                        b"ForceNew" => _serde::__private::Ok(__Field::__field1),
                        b"ForceNone" => _serde::__private::Ok(__Field::__field2),
                        b"ForceAlways" => _serde::__private::Ok(__Field::__field3),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<Forcing>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = Forcing;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "enum Forcing")
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match _serde::de::EnumAccess::variant(__data)? {
                        (__Field::__field0, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Forcing::NotForcing)
                        }
                        (__Field::__field1, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Forcing::ForceNew)
                        }
                        (__Field::__field2, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Forcing::ForceNone)
                        }
                        (__Field::__field3, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Forcing::ForceAlways)
                        }
                    }
                }
            }
            #[doc(hidden)]
            const VARIANTS: &'static [&'static str] = &[
                "NotForcing",
                "ForceNew",
                "ForceNone",
                "ForceAlways",
            ];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "Forcing",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<Forcing>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
impl Default for Forcing {
    fn default() -> Self {
        Forcing::NotForcing
    }
}
/// A `Convert` implementation that finds the stash of the given controller account,
/// if any.
pub struct StashOf<T>(core::marker::PhantomData<T>);
impl<T: Config> Convert<T::AccountId, Option<T::AccountId>> for StashOf<T> {
    fn convert(controller: T::AccountId) -> Option<T::AccountId> {
        StakingLedger::<T>::paired_account(StakingAccount::Controller(controller))
    }
}
/// A typed conversion from stash account ID to the active exposure of nominators
/// on that account.
///
/// Active exposure is the exposure of the validator set currently validating, i.e. in
/// `active_era`. It can differ from the latest planned exposure in `current_era`.
pub struct ExposureOf<T>(core::marker::PhantomData<T>);
impl<T: Config> Convert<T::AccountId, Option<Exposure<T::AccountId, BalanceOf<T>>>>
for ExposureOf<T> {
    fn convert(validator: T::AccountId) -> Option<Exposure<T::AccountId, BalanceOf<T>>> {
        <Pallet<T>>::active_era()
            .map(|active_era| <Pallet<T>>::eras_stakers(active_era.index, &validator))
    }
}
/// Filter historical offences out and only allow those from the bonding period.
pub struct FilterHistoricalOffences<T, R> {
    _inner: core::marker::PhantomData<(T, R)>,
}
impl<T, Reporter, Offender, R, O> ReportOffence<Reporter, Offender, O>
for FilterHistoricalOffences<Pallet<T>, R>
where
    T: Config,
    R: ReportOffence<Reporter, Offender, O>,
    O: Offence<Offender>,
{
    fn report_offence(reporters: Vec<Reporter>, offence: O) -> Result<(), OffenceError> {
        let offence_session = offence.session_index();
        let bonded_eras = BondedEras::<T>::get();
        if bonded_eras.first().filter(|(_, start)| offence_session >= *start).is_some() {
            R::report_offence(reporters, offence)
        } else {
            <Pallet<
                T,
            >>::deposit_event(Event::<T>::OldSlashingReportDiscarded {
                session_index: offence_session,
            });
            Ok(())
        }
    }
    fn is_known_offence(offenders: &[Offender], time_slot: &O::TimeSlot) -> bool {
        R::is_known_offence(offenders, time_slot)
    }
}
/// Wrapper struct for Era related information. It is not a pure encapsulation as these storage
/// items can be accessed directly but nevertheless, its recommended to use `EraInfo` where we
/// can and add more functions to it as needed.
pub struct EraInfo<T>(core::marker::PhantomData<T>);
impl<T: Config> EraInfo<T> {
    /// Returns true if validator has one or more page of era rewards not claimed yet.
    pub fn pending_rewards(era: EraIndex, validator: &T::AccountId) -> bool {
        let page_count = if let Some(overview) = <ErasStakersOverview<
            T,
        >>::get(&era, validator) {
            overview.page_count
        } else {
            if <ErasStakers<T>>::contains_key(era, validator) { 1 } else { return false }
        };
        if <Ledger<T>>::get(validator)
            .map(|l| l.legacy_claimed_rewards.contains(&era))
            .unwrap_or_default()
        {
            return false;
        }
        ClaimedRewards::<T>::get(era, validator).len() < page_count as usize
    }
    /// Temporary function which looks at both (1) passed param `T::StakingLedger` for legacy
    /// non-paged rewards, and (2) `T::ClaimedRewards` for paged rewards. This function can be
    /// removed once `T::HistoryDepth` eras have passed and none of the older non-paged rewards
    /// are relevant/claimable.
    pub(crate) fn is_rewards_claimed_with_legacy_fallback(
        era: EraIndex,
        ledger: &StakingLedger<T>,
        validator: &T::AccountId,
        page: Page,
    ) -> bool {
        ledger.legacy_claimed_rewards.binary_search(&era).is_ok()
            || Self::is_rewards_claimed(era, validator, page)
    }
    /// Check if the rewards for the given era and page index have been claimed.
    ///
    /// This is only used for paged rewards. Once older non-paged rewards are no longer
    /// relevant, `is_rewards_claimed_with_legacy_fallback` can be removed and this function can
    /// be made public.
    fn is_rewards_claimed(era: EraIndex, validator: &T::AccountId, page: Page) -> bool {
        ClaimedRewards::<T>::get(era, validator).contains(&page)
    }
    /// Get exposure for a validator at a given era and page.
    ///
    /// This builds a paged exposure from `PagedExposureMetadata` and `ExposurePage` of the
    /// validator. For older non-paged exposure, it returns the clipped exposure directly.
    pub fn get_paged_exposure(
        era: EraIndex,
        validator: &T::AccountId,
        page: Page,
    ) -> Option<PagedExposure<T::AccountId, BalanceOf<T>>> {
        let overview = <ErasStakersOverview<T>>::get(&era, validator);
        if overview.is_none() && page == 0 {
            return Some(
                PagedExposure::from_clipped(<ErasStakersClipped<T>>::get(era, validator)),
            );
        }
        if overview.is_none() {
            return None;
        }
        let overview = overview.expect("checked above; qed");
        let validator_stake = if page == 0 { overview.own } else { Zero::zero() };
        let exposure_page = <ErasStakersPaged<T>>::get((era, validator, page))
            .unwrap_or_default();
        Some(PagedExposure {
            exposure_metadata: PagedExposureMetadata {
                own: validator_stake,
                ..overview
            },
            exposure_page,
        })
    }
    /// Get full exposure of the validator at a given era.
    pub fn get_full_exposure(
        era: EraIndex,
        validator: &T::AccountId,
    ) -> Exposure<T::AccountId, BalanceOf<T>> {
        let overview = <ErasStakersOverview<T>>::get(&era, validator);
        if overview.is_none() {
            return ErasStakers::<T>::get(era, validator);
        }
        let overview = overview.expect("checked above; qed");
        let mut others = Vec::with_capacity(overview.nominator_count as usize);
        for page in 0..overview.page_count {
            let nominators = <ErasStakersPaged<T>>::get((era, validator, page));
            others
                .append(&mut nominators.map(|n| n.others).defensive_unwrap_or_default());
        }
        Exposure {
            total: overview.total,
            own: overview.own,
            others,
        }
    }
    /// Returns the number of pages of exposure a validator has for the given era.
    ///
    /// For eras where paged exposure does not exist, this returns 1 to keep backward compatibility.
    pub(crate) fn get_page_count(era: EraIndex, validator: &T::AccountId) -> Page {
        <ErasStakersOverview<T>>::get(&era, validator)
            .map(|overview| {
                if overview.page_count == 0 && overview.own > Zero::zero() {
                    1
                } else {
                    overview.page_count
                }
            })
            .unwrap_or(1)
    }
    /// Returns the next page that can be claimed or `None` if nothing to claim.
    pub(crate) fn get_next_claimable_page(
        era: EraIndex,
        validator: &T::AccountId,
        ledger: &StakingLedger<T>,
    ) -> Option<Page> {
        if Self::is_non_paged_exposure(era, validator) {
            return match ledger.legacy_claimed_rewards.binary_search(&era) {
                Ok(_) => None,
                Err(_) => Some(0),
            };
        }
        let page_count = Self::get_page_count(era, validator);
        let all_claimable_pages: Vec<Page> = (0..page_count).collect();
        let claimed_pages = ClaimedRewards::<T>::get(era, validator);
        all_claimable_pages.into_iter().find(|p| !claimed_pages.contains(p))
    }
    /// Checks if exposure is paged or not.
    fn is_non_paged_exposure(era: EraIndex, validator: &T::AccountId) -> bool {
        <ErasStakersClipped<T>>::contains_key(&era, validator)
    }
    /// Returns validator commission for this era and page.
    pub(crate) fn get_validator_commission(
        era: EraIndex,
        validator_stash: &T::AccountId,
    ) -> Perbill {
        <ErasValidatorPrefs<T>>::get(&era, validator_stash).commission
    }
    /// Creates an entry to track validator reward has been claimed for a given era and page.
    /// Noop if already claimed.
    pub(crate) fn set_rewards_as_claimed(
        era: EraIndex,
        validator: &T::AccountId,
        page: Page,
    ) {
        let mut claimed_pages = ClaimedRewards::<T>::get(era, validator);
        if claimed_pages.contains(&page) {
            {
                let lvl = ::log::Level::Error;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!(
                            "{0}: {1:?}",
                            ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                            "Trying to set an already claimed reward",
                        ),
                        lvl,
                        &(
                            "runtime::defensive",
                            "pallet_staking",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            };
            if true {
                if !false {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "{0}: {1:?}",
                                ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                "Trying to set an already claimed reward",
                            ),
                        );
                    }
                }
            }
            return;
        }
        claimed_pages.push(page);
        ClaimedRewards::<T>::insert(era, validator, claimed_pages);
    }
    /// Store exposure for elected validators at start of an era.
    pub fn set_exposure(
        era: EraIndex,
        validator: &T::AccountId,
        exposure: Exposure<T::AccountId, BalanceOf<T>>,
    ) {
        let page_size = T::MaxExposurePageSize::get().defensive_max(1);
        let nominator_count = exposure.others.len();
        let expected_page_count = nominator_count
            .defensive_saturating_add((page_size as usize).defensive_saturating_sub(1))
            .saturating_div(page_size as usize);
        let (exposure_metadata, exposure_pages) = exposure.into_pages(page_size);
        if !(exposure_pages.len() == expected_page_count) {
            {
                let lvl = ::log::Level::Error;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!(
                            "{0}: {1:?}: {2:?}",
                            ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                            "exposure_pages.len() == expected_page_count",
                            "unexpected page count",
                        ),
                        lvl,
                        &(
                            "runtime::defensive",
                            "pallet_staking",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            };
            if true {
                if !false {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "{0}: {1:?}: {2:?}",
                                ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                "exposure_pages.len() == expected_page_count",
                                "unexpected page count",
                            ),
                        );
                    }
                }
            }
        }
        <ErasStakersOverview<T>>::insert(era, &validator, &exposure_metadata);
        exposure_pages
            .iter()
            .enumerate()
            .for_each(|(page, paged_exposure)| {
                <ErasStakersPaged<
                    T,
                >>::insert((era, &validator, page as Page), &paged_exposure);
            });
    }
    /// Store total exposure for all the elected validators in the era.
    pub(crate) fn set_total_stake(era: EraIndex, total_stake: BalanceOf<T>) {
        <ErasTotalStake<T>>::insert(era, total_stake);
    }
}
/// Configurations of the benchmarking of the pallet.
pub trait BenchmarkingConfig {
    /// The maximum number of validators to use.
    type MaxValidators: Get<u32>;
    /// The maximum number of nominators to use.
    type MaxNominators: Get<u32>;
}
/// A mock benchmarking config for pallet-staking.
///
/// Should only be used for testing.
#[cfg(feature = "std")]
pub struct TestBenchmarkingConfig;
#[cfg(feature = "std")]
impl BenchmarkingConfig for TestBenchmarkingConfig {
    type MaxValidators = frame_support::traits::ConstU32<100>;
    type MaxNominators = frame_support::traits::ConstU32<100>;
}
/// Controls validator disabling
pub trait DisablingStrategy<T: Config> {
    /// Make a disabling decision. Returns the index of the validator to disable or `None` if no new
    /// validator should be disabled.
    fn decision(
        offender_stash: &T::AccountId,
        slash_era: EraIndex,
        currently_disabled: &Vec<u32>,
    ) -> Option<u32>;
}
/// Implementation of [`DisablingStrategy`] which disables validators from the active set up to a
/// threshold. `DISABLING_LIMIT_FACTOR` is the factor of the maximum disabled validators in the
/// active set. E.g. setting this value to `3` means no more than 1/3 of the validators in the
/// active set can be disabled in an era.
/// By default a factor of 3 is used which is the byzantine threshold.
pub struct UpToLimitDisablingStrategy<const DISABLING_LIMIT_FACTOR: usize = 3>;
impl<
    const DISABLING_LIMIT_FACTOR: usize,
> UpToLimitDisablingStrategy<DISABLING_LIMIT_FACTOR> {
    /// Disabling limit calculated from the total number of validators in the active set. When
    /// reached no more validators will be disabled.
    pub fn disable_limit(validators_len: usize) -> usize {
        validators_len
            .saturating_sub(1)
            .checked_div(DISABLING_LIMIT_FACTOR)
            .unwrap_or_else(|| {
                {
                    let lvl = ::log::Level::Error;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "{0}: {1:?}",
                                ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                                "DISABLING_LIMIT_FACTOR should not be 0",
                            ),
                            lvl,
                            &(
                                "runtime::defensive",
                                "pallet_staking",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                };
                if true {
                    if !false {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "{0}: {1:?}",
                                    ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                    "DISABLING_LIMIT_FACTOR should not be 0",
                                ),
                            );
                        }
                    }
                }
                0
            })
    }
}
impl<T: Config, const DISABLING_LIMIT_FACTOR: usize> DisablingStrategy<T>
for UpToLimitDisablingStrategy<DISABLING_LIMIT_FACTOR> {
    fn decision(
        offender_stash: &T::AccountId,
        slash_era: EraIndex,
        currently_disabled: &Vec<u32>,
    ) -> Option<u32> {
        let active_set = T::SessionInterface::validators();
        if currently_disabled.len() >= Self::disable_limit(active_set.len()) {
            {
                let lvl = ::log::Level::Debug;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!(
                            "[{0:?}] 💸 Won\'t disable: reached disabling limit {1:?}",
                            <frame_system::Pallet<T>>::block_number(),
                            Self::disable_limit(active_set.len()),
                        ),
                        lvl,
                        &(
                            crate::LOG_TARGET,
                            "pallet_staking",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            };
            return None;
        }
        if ActiveEra::<T>::get().map(|e| e.index).unwrap_or_default() > slash_era {
            {
                let lvl = ::log::Level::Debug;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!(
                            "[{0:?}] 💸 Won\'t disable: current_era {1:?} > slash_era {2:?}",
                            <frame_system::Pallet<T>>::block_number(),
                            Pallet::<T>::current_era().unwrap_or_default(),
                            slash_era,
                        ),
                        lvl,
                        &(
                            crate::LOG_TARGET,
                            "pallet_staking",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            };
            return None;
        }
        let offender_idx = if let Some(idx) = active_set
            .iter()
            .position(|i| i == offender_stash)
        {
            idx as u32
        } else {
            {
                let lvl = ::log::Level::Debug;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!(
                            "[{0:?}] 💸 Won\'t disable: offender not in active set",
                            <frame_system::Pallet<T>>::block_number(),
                        ),
                        lvl,
                        &(
                            crate::LOG_TARGET,
                            "pallet_staking",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            };
            return None;
        };
        {
            let lvl = ::log::Level::Debug;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api::log(
                    format_args!(
                        "[{0:?}] 💸 Will disable {1:?}",
                        <frame_system::Pallet<T>>::block_number(),
                        offender_idx,
                    ),
                    lvl,
                    &(crate::LOG_TARGET, "pallet_staking", ::log::__private_api::loc()),
                    (),
                );
            }
        };
        Some(offender_idx)
    }
}
